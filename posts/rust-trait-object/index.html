<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="Rust中的多态 - Trait Object">
<meta itemprop="description" content="Rust是一门静态类型语言，变量的类型一旦确定就不能更改。如果使用一个容器，则容器内部数据类型也必须完全一致，这会少一些灵活性。Rust中的 Trait 不但可以用作范型约束（Trait Bounds），也可以单独使用，我们叫 Trait Object，用它可以间接地实现动态类型。">
<meta itemprop="datePublished" content="2020-07-27T17:49:22&#43;08:00" />
<meta itemprop="dateModified" content="2020-07-27T17:49:22&#43;08:00" />
<meta itemprop="wordCount" content="2531">



<meta itemprop="keywords" content="rust,trait,heterogeneous," /><meta property="og:title" content="Rust中的多态 - Trait Object" />
<meta property="og:description" content="Rust是一门静态类型语言，变量的类型一旦确定就不能更改。如果使用一个容器，则容器内部数据类型也必须完全一致，这会少一些灵活性。Rust中的 Trait 不但可以用作范型约束（Trait Bounds），也可以单独使用，我们叫 Trait Object，用它可以间接地实现动态类型。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xiaopengli89.github.io/posts/rust-trait-object/" />
<meta property="article:published_time" content="2020-07-27T17:49:22+08:00" />
<meta property="article:modified_time" content="2020-07-27T17:49:22+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Rust中的多态 - Trait Object"/>
<meta name="twitter:description" content="Rust是一门静态类型语言，变量的类型一旦确定就不能更改。如果使用一个容器，则容器内部数据类型也必须完全一致，这会少一些灵活性。Rust中的 Trait 不但可以用作范型约束（Trait Bounds），也可以单独使用，我们叫 Trait Object，用它可以间接地实现动态类型。"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Rust中的多态 - Trait Object</title>
	<link rel="stylesheet" href="https://xiaopengli89.github.io/css/style.min.eac77496566fd7d5768fd650ddb0b2b181ca6a2d7c5fdd6fe6b8ba4bf47e566f.css" integrity="sha256-6sd0llZv19V2j9ZQ3bCysYHKai18X91v5ri6S/R+Vm8=" crossorigin="anonymous">
	
	<link rel="stylesheet" href="https://atelierbram.github.io/syntax-highlighting/archive/assets/css/prism/prism-base16-railscasts.dark.css">
	<link rel="stylesheet" href="https://xiaopengli89.github.io/css/site.css">
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://xiaopengli89.github.io">Torigoth</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://xiaopengli89.github.io/posts/">Posts</a>
				<a href="https://xiaopengli89.github.io/tags/">Tags</a>
				<a href="https://xiaopengli89.github.io/about/">About</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<span class="hdr-social hide-in-mobile"><a href="mailto:x.friday@outlook.com" target="_blank" rel="noopener me" title="Email"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg></a><a href="https://www.linkedin.com/in/%E5%B0%8F%E9%B9%8F-%E6%9D%8E-078a86124/" target="_blank" rel="noopener me" title="Linkedin"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle></svg></a><a href="https://github.com/xiaopengli89" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://xiaopengli89.github.io/posts/">Posts</a></li>
			<li><a href="https://xiaopengli89.github.io/tags/">Tags</a></li>
			<li><a href="https://xiaopengli89.github.io/about/">About</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Jul 27, 2020</span></div>
				<h1>Rust中的多态 - Trait Object</h1>
			</header>
			<div class="content">
				<p>Rust是一门静态类型语言，变量的类型一旦确定就不能更改。如果使用一个容器，则容器内部数据类型也必须完全一致，这会少一些灵活性。Rust中的 <code>Trait</code> 不但可以用作范型约束（<code>Trait Bounds</code>），也可以单独使用，我们叫 <code>Trait Object</code>，用它可以间接地实现动态类型。</p>
<h2 id="动态大小类型dst">动态大小类型（DST）<a href="#动态大小类型dst" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>在Rust的内存布局模型中，一般每个类型都有唯一确定的类型大小，很多情况下类型默认由编译器实现了 <code>Sized</code>。但是Rust中也存在类型大小不确定的情况，比较典型的有：</p>
<ol>
<li>切片（<code>slice</code>)</li>
<li>最后一个字段大小不确定的结构体</li>
<li><code>Trait Object</code></li>
</ol>
<p>这3种情况下，类型大小将不确定，我们将这些类型叫做动态大小类型（DST）。由于DST的类型大小无法确定，因此无法在栈上直接分配内存空间，变量必须通过指针间接引用。</p>
<p>切片是数组的部分连续引用，由头指针和长度构成。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Slice</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">head</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">size</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><pre><code class="language-none" data-lang="none">0: E     &lt;-- head: 2
1: E     |   size: 4
2: E &lt;----
3: E     |
4: E     |
5: E &lt;----
6: E
7: E
</code></pre><p>切片由 <code>Range</code> 运算符和中括号构造，利用 <code>Range</code> 中的 <code>starting_index</code> 和 <code>ending_index</code> 确定头指针和长度信息：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">sli</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">..</span><span class="o">=</span><span class="mi">3</span><span class="p">];</span><span class="w">
</span></code></pre></div><p>自定义DST结构体的话，只需要在结构中内嵌唯一一个DST类型，并且是在最后一个字段，而目前唯一能构造这种结构体的方式是通过范型：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Foo</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">f1</span>: <span class="kt">bool</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">f2</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">f3</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">foo</span>: <span class="kp">&amp;</span><span class="nc">Foo</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">i32</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Foo</span>::<span class="o">&lt;</span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">f1</span>: <span class="nc">false</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">f2</span>: <span class="mi">1</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">f3</span>: <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span><span class="w">
</span><span class="w"></span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Foo</span>::<span class="o">&lt;</span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">f1</span>: <span class="nc">false</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">f2</span>: <span class="mi">1</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">f3</span>: <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">],</span><span class="w">
</span><span class="w"></span><span class="p">};</span><span class="w">
</span></code></pre></div><p><code>Trait Object</code> 则是实现了固定 <code>Trait</code> 集合的不同类型的实例，并且通过胖指针隐藏了具体的类型和方法实现信息。通过 <code>Trait Object</code> 可以实现动态地修改变量类型，动态地调用不同方法实现（动态分发），即其他编程语言里的多态性。</p>
<h2 id="trait-object-的实现"><code>Trait Object</code> 的实现<a href="#trait-object-的实现" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>为了实现不同的类型能被一个变量或容器持有，<code>Trait Object</code> 内部本身只有 <code>data</code> 和 <code>vtable</code> 字段构成，并且2个字段都是指针，直接类型大小其实也是确定的。其中 <code>data</code> 指向具体的类型实例，而 <code>vtable</code> 则是指向实现了 <code>Trait</code> 的方法集合：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">TraitObject</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">data</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">vtable</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="p">(),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>由于 <code>Trait Object</code> 属于DST的一种，因此构造时必须通过指针间接引用，并且需要在 <code>Trait</code> 前附加 <code>dyn</code> 关键字，通常可以由 <code>&amp;dyn SomeTrait</code> 或 <code>Box&lt;dyn SomeTrait&gt;</code> 2种方式来构造：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foo1</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foo2</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo1</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo2</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">bar</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Foo1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Foo2</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>可以构造一个 <code>Trait Object</code> 实例查看内部的数据构成：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">f1</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">f2</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foo</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">f1</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">f2</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;foo&#39;s address = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">foo</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Foo::f1 = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span>::<span class="n">f1</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Foo::f2 = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span>::<span class="n">f2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">bar</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">foo</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">vtable</span><span class="p">)</span>: <span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">mem</span>::<span class="n">transmute</span><span class="p">(</span><span class="n">bar</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;data = {}, vtable = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">vtable</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">vtable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vtable</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;[{}, {}, {}, {}, {}]&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="o">*</span><span class="n">vtable</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="o">*</span><span class="n">vtable</span><span class="p">.</span><span class="n">offset</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w">
</span><span class="w">		</span><span class="o">*</span><span class="n">vtable</span><span class="p">.</span><span class="n">offset</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w">
</span><span class="w">		</span><span class="o">*</span><span class="n">vtable</span><span class="p">.</span><span class="n">offset</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="w">
</span><span class="w">		</span><span class="o">*</span><span class="n">vtable</span><span class="p">.</span><span class="n">offset</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span><span class="w">
</span><span class="w">	</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>打印出的结果：</p>
<pre><code class="language-none" data-lang="none">foo's address = 140729104675248
Foo::f1 = 94428356803312
Foo::f2 = 94428356803328
data = 140729104675248, vtable = 94428357017888
[94428356801504, 0, 1, 94428356803312, 94428356803328]
</code></pre><p>可以看到变量 <code>foo</code> 的内存地址就是 <code>data</code> 的值，而 <code>Foo::f1</code> 和 <code>Foo::f2</code> 方法的地址分别出现在 <code>vtable</code> 的第3和第4个位置上，这样程序运行期间就可以动态确定对象和需要调用的方法了。</p>
<p><strong>NOTE:</strong> <code>vtable</code> 的第0个位置保存的是对象的析构方法地址，第1个位置保存的是对象的类型大小（这里因为样例的 <code>Foo</code> 结构为空，所以等于0），第2个位置保存的是对象的内存对齐大小（由于 <code>Foo</code> 结构的类型大小为0，所以对齐大小为1字节）。<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<h2 id="限制">限制<a href="#限制" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>虽然 <code>Trait Object</code> 具有范型不具备的灵活性，并且某些情况下甚至不得不通过它来实现（比如异步运行时中需要保存 <code>Future</code> 对象），但 <code>Trait Object</code> 在使用上还有些局限性，一些特性不能运用在它上面。</p>
<ol>
<li>只能绑定一个 <code>Trait</code>， 除了 <a href="https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits">auto traits</a> 和 <a href="https://doc.rust-lang.org/reference/items/traits.html#supertraits">supertraits</a> 外，不能附加其他 <code>Trait</code>，比如不能如下定义一个 <code>Trait Object</code>：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">type</span> <span class="nc">SomeType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">TraitA</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">TraitB</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></div><ol start="2">
<li>无法定义范型方法（<code>object safe</code> <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> 条件之一）：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">say</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">p</span>: <span class="nc">T</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foo</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">say</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">p</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">bar</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Foo</span><span class="p">);</span><span class="w"> </span><span class="c1">// 无法编译通过
</span></code></pre></div><ol start="3">
<li>除 <code>receiver</code> 外的 <code>Self</code> 类型声明（<code>object safe</code> <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> 条件之一）：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">say</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foo</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">say</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">bar</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Foo</span><span class="p">);</span><span class="w"> </span><span class="c1">// 无法编译通过
</span></code></pre></div><ol start="4">
<li>无法定义关联函数（<code>Associated Functions</code>）（<code>object safe</code> <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> 条件之一）：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">hello</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foo</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">hello</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">bar</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Foo</span><span class="p">);</span><span class="w"> </span><span class="c1">// 无法编译通过
</span></code></pre></div><ol start="5">
<li>只能定义一个生命周期：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">type</span> <span class="nc">SomeType</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="na">&#39;b</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">TraitA</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="na">&#39;a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="na">&#39;b</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 无法编译通过
</span></code></pre></div><ol start="6">
<li><code>Trait</code> 本身不能附加 <code>Self: Sized</code> 约束（<code>object safe</code> <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> 条件之一）：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Self</span>: <span class="nb">Sized</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foo</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">bar</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Foo</span><span class="p">);</span><span class="w"> </span><span class="c1">// 无法编译通过
</span></code></pre></div><ol start="7">
<li>不能定义关联常量（<code>object safe</code> <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> 条件之一）：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">ID</span>: <span class="kt">u32</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foo</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">ID</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">bar</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Foo</span><span class="p">);</span><span class="w"> </span><span class="c1">// 无法编译通过
</span></code></pre></div><ol start="8">
<li>不允许 <code>opt-out bounds</code>：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">type</span> <span class="nc">SomeType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">TraitA</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 无法编译通过
</span></code></pre></div><h2 id="通过-self-sized-约束将特定方法排除在-vtable-外">通过 <code>Self: Sized</code> 约束将特定方法排除在 <code>vtable</code> 外<a href="#通过-self-sized-约束将特定方法排除在-vtable-外" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>有时候我们希望把某些不具备 <code>object-safe</code> 条件的方法排除在 <code>vtable</code> 外，比如范型方法、除了 <code>receiver</code> 外的 <code>Self</code> 类型声明、关联函数，相当于生成一个具备 <code>object-safe</code> 的子集。这时候只需要在方法上附加 <code>where Self: Sized</code> 约束即可：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">say</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">hello</span><span class="p">()</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">set</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foo</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">say</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">set</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">bar</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Foo</span><span class="p">);</span><span class="w"> </span><span class="c1">// 编译通过
</span></code></pre></div><p>之所以能通过这种方式来标记，是因为 <a href="https://doc.rust-lang.org/reference/special-types-and-traits.html#sized"><code>implementation items</code> 默认不会被编译器实现 <code>Sized</code></a>。当然这些被排除的方法在 <code>Trait Object</code> 上也无法调用。</p>
<h2 id="trait-object-的生命周期推导"><code>Trait Object</code> 的生命周期推导<a href="#trait-object-的生命周期推导" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>由于 <code>Trait Object</code> 内可能包含引用，因此也需要在定义时描述其生命周期，不过大多数时候编译器都能在上下文中推断出所需的生命周期，规则如下<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>：</p>
<blockquote>
<p>如果一个trait对象作为一个类型参数传递到泛型中，那么它的生命约束会从它包含的类型中推断</p>
<ol>
<li>如果包含的类型中有唯一的约束，那么就使用这个约束。</li>
<li>如果包含的类型中有超过一个约束，那么必须显式指定约束。</li>
</ol>
<p>如果以上都不适用，那么：</p>
<ol>
<li>如果trait是以单个生命周期约束定义的，那么就使用这个约束</li>
<li>如果所有生命周期约束都是 &lsquo;static 的，那么就使用 &lsquo;static 作为约束</li>
<li>如果trait没有生命周期约束，那么它的生命周期将会从表达式中推断，如果不在表达式中，那么就是 &lsquo;static 的</li>
</ol>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// For the following trait...
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// These two are the same as Box&lt;T&gt; has no lifetime bound on T
</span><span class="c1"></span><span class="k">type</span> <span class="nc">T1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">type</span> <span class="nc">T2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// ...and so are these:
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// ...so are these, because &amp;&#39;a T requires T: &#39;a
</span><span class="c1"></span><span class="k">type</span> <span class="nc">T3</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">type</span> <span class="nc">T4</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="na">&#39;a</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// std::cell::Ref&lt;&#39;a, T&gt; also requires T: &#39;a, so these are the same
</span><span class="c1"></span><span class="k">type</span> <span class="nc">T5</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="n">Ref</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">type</span> <span class="nc">T6</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="n">Ref</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// This is an example of an error.
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">TwoBounds</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="na">&#39;b</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="na">&#39;a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="na">&#39;b</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">f1</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">f2</span>: <span class="kp">&amp;</span><span class="na">&#39;b</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">f3</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">type</span> <span class="nc">T7</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="na">&#39;b</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TwoBounds</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="na">&#39;b</span><span class="p">,</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="c1">//                                  ^^^^^^^
</span><span class="c1">// Error: the lifetime bound for this object type cannot be deduced from context
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// For the following trait...
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="n">Bar</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span>: <span class="na">&#39;a</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// ...these two are the same:
</span><span class="c1"></span><span class="k">type</span> <span class="nc">T1</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">type</span> <span class="nc">T2</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// ...and so are these:
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="na">&#39;a</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><h2 id="与范型相比有什么优劣">与范型相比有什么优劣<a href="#与范型相比有什么优劣" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>范型会在编译期间展开成具体的类型以及方法，因此可以在编译期间确定对象的类型内存布局、方法地址，这属于静态分发；而 <code>Trait Object</code> 是在程序运行期间通过指针间接确定具体对象的类型内存布局和方法地址，这属于动态分发。</p>
<p>优势：</p>
<ol>
<li>能实现多态，动态地修改类型和调用方法，实现动态容器。</li>
<li>没有代码膨胀问题，范型由于每个类型和方法都需要独立展开，而 <code>Trait Object</code> 不需要这么做，因此可以生成更小的代码尺寸。</li>
</ol>
<p>劣势：</p>
<ol>
<li>上面提到的各种限制。</li>
<li>由于动态分发需要在程序运行期间通过指针间接访问数据和调用方法，有一定的性能开销。</li>
</ol>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>空元组（<code>()</code>）和零尺寸类型的类型大小为0，内存对齐大小为1。- <a href="https://doc.rust-lang.org/reference/type-layout.html#tuple-layout">Type Layout</a> <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>即对象安全。- <a href="https://doc.rust-lang.org/reference/items/traits.html#object-safety">Object Safety</a> <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p><a href="https://doc.rust-lang.org/reference/lifetime-elision.html#default-trait-object-lifetimes">Default trait object lifetimes</a> 和 <a href="https://github.com/whfuyn/rust-blog/blob/master/posts/Rust%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%B8%B8%E8%A7%81%E8%AF%AF%E8%A7%A3.md#6-%E8%A3%85%E7%AE%B1%E7%9A%84trait%E5%AF%B9%E8%B1%A1%E6%B2%A1%E6%9C%89%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Rust生命周期的常见误解</a> <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://xiaopengli89.github.io/tags/rust">rust</a></span><span class="tag"><a href="https://xiaopengli89.github.io/tags/trait">trait</a></span><span class="tag"><a href="https://xiaopengli89.github.io/tags/heterogeneous">heterogeneous</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>2531 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2020-07-27 17:49 &#43;0800</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="next-post" href="https://xiaopengli89.github.io/posts/goroutine-rs/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;Newer</span><br><span>用Rust实现一个Goroutine</span>
			</a>
			<a class="prev-post" href="https://xiaopengli89.github.io/posts/rust-lifetime-variance/">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>Rust中的生命周期及变性</span>
			</a>
		</div>
		<div id="comments" class="thin">
</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2020 <a href="https://xiaopengli89.github.io">Xiaopeng Li</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://xiaopengli89.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://xiaopengli89.github.io/js/bundle.min.4a9a0ac3d2217822c7865b4161e6c2a71de1d70492264337755427898dd718f6.js" integrity="sha256-SpoKw9IheCLHhltBYebCpx3h1wSSJkM3dVQniY3XGPY=" crossorigin="anonymous"></script>
	
<script src="https://cdn.bootcdn.net/ajax/libs/prism/1.20.0/prism.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/prism/1.20.0/plugins/autoloader/prism-autoloader.min.js"></script>
<script>Prism.plugins.autoloader.languages_path = 'https://cdn.bootcdn.net/ajax/libs/prism/1.20.0/components/'</script>



</body>

</html>
