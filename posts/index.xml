<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Torigoth</title>
		<link>https://xiaopengli89.github.io/posts/</link>
		<description>Recent content in Posts on Torigoth</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Sat, 08 Aug 2020 20:13:04 +0800</lastBuildDate>
		<atom:link href="https://xiaopengli89.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Crossbeam的无锁并发Channel解析</title>
			<link>https://xiaopengli89.github.io/posts/crossbeam-channel/</link>
			<pubDate>Sat, 08 Aug 2020 20:13:04 +0800</pubDate>
			
			<guid>https://xiaopengli89.github.io/posts/crossbeam-channel/</guid>
			<description>&lt;p&gt;&lt;a href=&#34;https://crates.io/crates/crossbeam&#34;&gt;crossbeam&lt;/a&gt;是一个提供并发编程的工具库，实现了诸如&lt;code&gt;原子Cell&lt;/code&gt;、&lt;code&gt;工作窃取双端队列&lt;/code&gt;、&lt;code&gt;分段队列&lt;/code&gt;、
&lt;code&gt;多生产者多消费者Channel&lt;/code&gt;等无锁并发数据结构，在运行时、调度器、线程同步等领域应用广泛。&lt;/p&gt;
&lt;p&gt;虽然Rust标准库中也提供了用于线程同步的&lt;code&gt;mpsc::channel&lt;/code&gt;，不过内置的channel实现算法和crossbeam不同，也不支持多个消费者。&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p><a href="https://crates.io/crates/crossbeam">crossbeam</a>是一个提供并发编程的工具库，实现了诸如<code>原子Cell</code>、<code>工作窃取双端队列</code>、<code>分段队列</code>、
<code>多生产者多消费者Channel</code>等无锁并发数据结构，在运行时、调度器、线程同步等领域应用广泛。</p>
<p>虽然Rust标准库中也提供了用于线程同步的<code>mpsc::channel</code>，不过内置的channel实现算法和crossbeam不同，也不支持多个消费者。</p>
<p>标准库的<code>mpsc::channel</code>使用的是
<a href="http://www.1024cores.net/home/lock-free-algorithms/queues/non-intrusive-mpsc-node-based-queue">Non-intrusive MPSC node-based queue</a>
算法，这个算法在多生产者单消费者的模型下性能非常高，下图对比了Rust内置channel、crossbeam的分段队列、Scala MSQ、Java ConcurrentLinkedQueue在
多生产者单消费者模型下的基准测试：</p>
<figure>
    <img src="https://aturon.github.io/blog/public/bench-mpsc.png"/> 
</figure>

<p>可以发现Rust内置channel和crossbeam的分段队列在基准测试中的表现要明显优于Scala/Java的Jvm平台，原因在于Jvm平台使用了垃圾收集器（GC）。
在多生产者单消费者模型下，生产的速率大于消费，这会导致数据积压越来越多，进而Jvm在GC时需要扫描的对象也愈来愈多，花费在GC上的时间也就越多。</p>
<p>而crossbeam在实现无锁并发结构时，采用了基于代的内存回收方式<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>，这种算法的内存管理开销和数据对象的数量无关，只和线程的数量相关，因此在
以上模型中可以表现出更好的一致性和可预测性。不过Rust中的所有权系统已经保证了内存安全，那为什么还需要做额外的内存回收呢？这个问题的关键点
就在要实现无锁并发结构。如果使用标准库中的Arc自然就不会有内存回收的问题，可Arc是有锁的。关于基于代的内存回收也是一个比较大的话题，
这篇文章不会深入讨论。</p>
<p>而在多生产者多消费者的模型中，crossbeam同样具有相当的性能优势，以下是多生产者多消费者模型下的基准测试：</p>
<figure>
    <img src="https://aturon.github.io/blog/public/bench-mpmc.png"/> 
</figure>

<h2 id="无锁并发channel">无锁并发Channel</h2>
<pre><code class="language-none" data-lang="none">[0]   ----&gt;[0]  
[1]   |    [1]
[2]   |    [2]
[3]   |    [3]
 .    |     .
 .    |     .
[N]----    [N]----
</code></pre><p>在crossbeam的无锁并发Channel结构中，最核心的算法思想也是分段，每次需要分配额外的空间时，一次分配一个块（Block），一个Block内包含了多个Slot（槽）。
而在进行读写数据时，先通过原子操作获取Slot的操作权限，并发操作不需要等数据完整地写入或读取，将竞争的临界区尽可能地缩小。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="sd">/// Unbounded channel implemented as a linked list.
</span><span class="sd">///
</span><span class="sd">/// Each message sent into the channel is assigned a sequence number, i.e. an index. Indices are
</span><span class="sd">/// represented as numbers of type `usize` and wrap on overflow.
</span><span class="sd">///
</span><span class="sd">/// Consecutive messages are grouped into blocks in order to put less pressure on the allocator and
</span><span class="sd">/// improve cache efficiency.
</span><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Channel</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="sd">/// The head of the channel.
</span><span class="sd"></span><span class="w">    </span><span class="n">head</span>: <span class="nc">CachePadded</span><span class="o">&lt;</span><span class="n">Position</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// The tail of the channel.
</span><span class="sd"></span><span class="w">    </span><span class="n">tail</span>: <span class="nc">CachePadded</span><span class="o">&lt;</span><span class="n">Position</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// Receivers waiting while the channel is empty and not disconnected.
</span><span class="sd"></span><span class="w">    </span><span class="n">receivers</span>: <span class="nc">SyncWaker</span><span class="p">,</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// Indicates that dropping a `Channel&lt;T&gt;` may drop messages of type `T`.
</span><span class="sd"></span><span class="w">    </span><span class="n">_marker</span>: <span class="nc">PhantomData</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Channel最外层就是由Block组成的链表。</p>
<p>可以发现表头和表尾都使用了CachePadded这个结构，这个结构和高速缓存的缓存行（cache line）优化有关。CachePadded这个结构的类型大小等于
cache line的整数倍，同时足够容纳类型T，这样就可以避免2个对象同处于一个cache line内，带来的好处就是修改某个对象不会使其他对象所在的线程cache line失效。</p>
<p>而receivers字段保存了当channel为空时阻塞的消费者线程，当写入新数据后，可以从中有条件地唤醒消费者线程，底层实现基于
<a href="https://doc.rust-lang.org/std/sync/struct.Condvar.html">条件变量</a>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="sd">/// A position in a channel.
</span><span class="sd"></span><span class="cp">#[derive(Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Position</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="sd">/// The index in the channel.
</span><span class="sd"></span><span class="w">    </span><span class="n">index</span>: <span class="nc">AtomicUsize</span><span class="p">,</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// The block in the linked list.
</span><span class="sd"></span><span class="w">    </span><span class="n">block</span>: <span class="nc">AtomicPtr</span><span class="o">&lt;</span><span class="n">Block</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Position结构中index保存了表头或表尾在整个Channel中的索引位置，block则是指向块的原子指针。</p>
<p><strong>NOTE:</strong> 需要注意的是index需要去除低位的元信息后才是真正的索引位置。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Each block covers one &#34;lap&#34; of indices.
</span><span class="c1"></span><span class="k">const</span><span class="w"> </span><span class="n">LAP</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="c1">// The maximum number of messages a block can hold.
</span><span class="c1"></span><span class="k">const</span><span class="w"> </span><span class="n">BLOCK_CAP</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="n">LAP</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// ..
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="sd">/// A block in a linked list.
</span><span class="sd">///
</span><span class="sd">/// Each block in the list can hold up to `BLOCK_CAP` messages.
</span><span class="sd"></span><span class="k">struct</span> <span class="nc">Block</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="sd">/// The next block in the linked list.
</span><span class="sd"></span><span class="w">    </span><span class="n">next</span>: <span class="nc">AtomicPtr</span><span class="o">&lt;</span><span class="n">Block</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// Slots for messages.
</span><span class="sd"></span><span class="w">    </span><span class="n">slots</span>: <span class="p">[</span><span class="n">Slot</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="n">BLOCK_CAP</span><span class="p">],</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在Block结构中next保存了下一个Block的原子指针，slots则是当前Block的所有槽，每个槽可以保存一个数据，可以看到目前一个Block内有31个槽。</p>
<p><strong>NOTE:</strong> 之所以BLOCK_CAP的值取2的幂次减1，是因为在通过index取模计算在Block中的偏移量时，可以利用位运算优化。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="sd">/// A slot in a block.
</span><span class="sd"></span><span class="k">struct</span> <span class="nc">Slot</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="sd">/// The message.
</span><span class="sd"></span><span class="w">    </span><span class="n">msg</span>: <span class="nc">UnsafeCell</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// The state of the slot.
</span><span class="sd"></span><span class="w">    </span><span class="n">state</span>: <span class="nc">AtomicUsize</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在Slot结构中msg用于保存数据，state则是目前这个Slot的状态，这个状态也是非常关键的，基于这个状态才能实现最小化竞争临界区。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="sd">/// Sends a message into the channel.
</span><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">send</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">_deadline</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Instant</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">SendTimeoutError</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Token</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w">	</span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">start_send</span><span class="p">(</span><span class="n">token</span><span class="p">));</span><span class="w">
</span><span class="w">	</span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="bp">self</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">token</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w">
</span><span class="w">			</span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="n">SendTimeoutError</span>::<span class="n">Disconnected</span><span class="p">)</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>当需要send一个数据时，大体上分为3步：</p>
<ol>
<li>获取下一个槽的操作权限</li>
<li>写入数据</li>
<li>设置已写入状态</li>
</ol>
<p>而只有第一步是会有竞争的，只要完成了第一步，其他线程的send操作就可以马上进行。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="sd">/// The token type for the list flavor.
</span><span class="sd"></span><span class="cp">#[derive(Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">ListToken</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="sd">/// The block of slots.
</span><span class="sd"></span><span class="w">    </span><span class="n">block</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// The offset into the block.
</span><span class="sd"></span><span class="w">    </span><span class="n">offset</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>其中的Token主要是为第一步和第二步提供桥梁，获取到槽的操作权限后，相关信息会通过Token传递给write方法去写数据。</p>
<p>在<code>start_send</code>方法中：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Calculate the offset of the index into the block.
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tail</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">SHIFT</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">LAP</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>偏移量offset从index去除低位元信息后取模计算而来。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// If we reached the end of the block, wait until the next one is installed.
</span><span class="c1"></span><span class="k">if</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">BLOCK_CAP</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">backoff</span><span class="p">.</span><span class="n">snooze</span><span class="p">();</span><span class="w">
</span><span class="w">	</span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Ordering</span>::<span class="n">Acquire</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">block</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Ordering</span>::<span class="n">Acquire</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="k">continue</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>当offset等于Block的容量时，说明其他线程正在创建新的Block，因此这里会利用backoff来等待：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[inline]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">snooze</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">step</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">SPIN_LIMIT</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">step</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="n">atomic</span>::<span class="n">spin_loop_hint</span><span class="p">();</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="cp">#[cfg(not(feature = </span><span class="s">&#34;std&#34;</span><span class="cp">))]</span><span class="w">
</span><span class="w">		</span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">step</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="n">atomic</span>::<span class="n">spin_loop_hint</span><span class="p">();</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">		</span><span class="cp">#[cfg(feature = </span><span class="s">&#34;std&#34;</span><span class="cp">)]</span><span class="w">
</span><span class="w">		</span>::<span class="n">std</span>::<span class="n">thread</span>::<span class="n">yield_now</span><span class="p">();</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">step</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">YIELD_LIMIT</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="bp">self</span><span class="p">.</span><span class="n">step</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">step</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>snooze</code>方法的实现部分借鉴了Mutex，在前面一定周期内进行自旋，并且自旋的次数会依次递增，直到YIELD_LIMIT，当超过一定周期后，就让出CPU。</p>
<p><strong>NOTE:</strong> 在no_std环境下会一直使用自旋方式来等待。</p>
<p><a href="https://github.com/Pslydhh">Pslydhh</a>在
<a href="https://github.com/crossbeam-rs/crossbeam-channel/pull/88">Move the tail pointer forward instead of only spinning #88</a>
中提出了一种其他线程协助链接下一个Block的做法，不过这种做法在竞争的情况下会有多个next block被创建，而只有一个被链接上，
这会导致额外的内存分配和回收开销。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// If we&#39;re going to have to install the next block, allocate it in advance in order to
</span><span class="c1">// make the wait for other threads as short as possible.
</span><span class="c1"></span><span class="k">if</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">BLOCK_CAP</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">next_block</span><span class="p">.</span><span class="n">is_none</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">next_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Block</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">()));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>当offset + 1等于BLOCK_CAP，并且next_block为空时，此时需要创建下一个Block。（如果next_block不为空，说明之前创建过一次，但是链接时被抢先了）</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// If this is the first message to be sent into the channel, we need to allocate the
</span><span class="c1">// first block and install it.
</span><span class="c1"></span><span class="k">if</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">is_null</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">into_raw</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Block</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">()));</span><span class="w">
</span><span class="w">
</span><span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="w">
</span><span class="w">		</span><span class="p">.</span><span class="n">tail</span><span class="w">
</span><span class="w">		</span><span class="p">.</span><span class="n">block</span><span class="w">
</span><span class="w">		</span><span class="p">.</span><span class="n">compare_and_swap</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="n">new</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">Release</span><span class="p">)</span><span class="w">
</span><span class="w">		</span><span class="o">==</span><span class="w"> </span><span class="n">block</span><span class="w">
</span><span class="w">	</span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">block</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">new</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">Release</span><span class="p">);</span><span class="w">
</span><span class="w">		</span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="n">next_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">from_raw</span><span class="p">(</span><span class="n">new</span><span class="p">))</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">		</span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Ordering</span>::<span class="n">Acquire</span><span class="p">);</span><span class="w">
</span><span class="w">		</span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">block</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Ordering</span>::<span class="n">Acquire</span><span class="p">);</span><span class="w">
</span><span class="w">		</span><span class="k">continue</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>而当block为空时，说明是第一次向Channel发送消息，因此需要先创建第一个Block，这里可以看到Channel的初始化是惰性的，从Channel的构造方法也可以看到这一点：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="sd">/// Creates a new unbounded channel.
</span><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">Channel</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="n">head</span>: <span class="nc">CachePadded</span>::<span class="n">new</span><span class="p">(</span><span class="n">Position</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="n">block</span>: <span class="nc">AtomicPtr</span>::<span class="n">new</span><span class="p">(</span><span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">()),</span><span class="w">
</span><span class="w">			</span><span class="n">index</span>: <span class="nc">AtomicUsize</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w">
</span><span class="w">		</span><span class="p">}),</span><span class="w">
</span><span class="w">		</span><span class="n">tail</span>: <span class="nc">CachePadded</span>::<span class="n">new</span><span class="p">(</span><span class="n">Position</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="n">block</span>: <span class="nc">AtomicPtr</span>::<span class="n">new</span><span class="p">(</span><span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">()),</span><span class="w">
</span><span class="w">			</span><span class="n">index</span>: <span class="nc">AtomicUsize</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w">
</span><span class="w">		</span><span class="p">}),</span><span class="w">
</span><span class="w">		</span><span class="n">receivers</span>: <span class="nc">SyncWaker</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">		</span><span class="n">_marker</span>: <span class="nc">PhantomData</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">new_tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">SHIFT</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// Try advancing the tail forward.
</span><span class="c1"></span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="w">
</span><span class="w">	</span><span class="n">tail</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">new_tail</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">Ordering</span>::<span class="n">SeqCst</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">Ordering</span>::<span class="n">Acquire</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="c1">// If we&#39;ve reached the end of the block, install the next one.
</span><span class="c1"></span><span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">BLOCK_CAP</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="kd">let</span><span class="w"> </span><span class="n">next_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">into_raw</span><span class="p">(</span><span class="n">next_block</span><span class="p">.</span><span class="n">unwrap</span><span class="p">());</span><span class="w">
</span><span class="w">			</span><span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">block</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">next_block</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">Release</span><span class="p">);</span><span class="w">
</span><span class="w">			</span><span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">SHIFT</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">Release</span><span class="p">);</span><span class="w">
</span><span class="w">			</span><span class="p">(</span><span class="o">*</span><span class="n">block</span><span class="p">).</span><span class="n">next</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">next_block</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">Release</span><span class="p">);</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">		</span><span class="n">token</span><span class="p">.</span><span class="n">list</span><span class="p">.</span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="w">
</span><span class="w">		</span><span class="n">token</span><span class="p">.</span><span class="n">list</span><span class="p">.</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span><span class="w">
</span><span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="p">},</span><span class="w">
</span><span class="w">	</span><span class="nb">Err</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w">
</span><span class="w">		</span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">block</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Ordering</span>::<span class="n">Acquire</span><span class="p">);</span><span class="w">
</span><span class="w">		</span><span class="n">backoff</span><span class="p">.</span><span class="n">spin</span><span class="p">();</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>随后将index增加1，原子替换当前的index。注意到这里替换使用的是<code>compare_exchange_weak</code>方法，这是因为此时的代码本身处于一个循环中，这在部分硬件平台上
会带来更好的性能，如果使用compare_exchange，内部本身还有一个更复杂的循环用于屏蔽虚假失败，而这里我们并不需要区分虚假失败，相关的内容可以查阅
<a href="https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange">手册</a>和<a href="https://en.wikipedia.org/wiki/Load-link/store-conditional">维基百科</a>。</p>
<p>当成功替换了index后，如果是新创建了Block则需要将这个Block链接到之前的尾端，而这时临界区已经完成，其他线程的操作可以进行下去，
最后修改Token的block和offset信息。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="sd">/// Writes a message into the channel.
</span><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">write</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">token</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Token</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="c1">// If there is no slot, the channel is disconnected.
</span><span class="c1"></span><span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="n">token</span><span class="p">.</span><span class="n">list</span><span class="p">.</span><span class="n">block</span><span class="p">.</span><span class="n">is_null</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">	</span><span class="c1">// Write the message into the slot.
</span><span class="c1"></span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">token</span><span class="p">.</span><span class="n">list</span><span class="p">.</span><span class="n">block</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">Block</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">token</span><span class="p">.</span><span class="n">list</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">slot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">block</span><span class="p">).</span><span class="n">slots</span><span class="p">.</span><span class="n">get_unchecked</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="n">slot</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">write</span><span class="p">(</span><span class="n">MaybeUninit</span>::<span class="n">new</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span><span class="w">
</span><span class="w">	</span><span class="n">slot</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">fetch_or</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">Release</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">	</span><span class="c1">// Wake a sleeping receiver.
</span><span class="c1"></span><span class="w">	</span><span class="bp">self</span><span class="p">.</span><span class="n">receivers</span><span class="p">.</span><span class="n">notify</span><span class="p">();</span><span class="w">
</span><span class="w">	</span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>而<code>write</code>方法就比较简单了，写入数据，设置已写入状态，最后通知被阻塞的消费者线程。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="sd">/// Receives a message from the channel.
</span><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">recv</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">deadline</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Instant</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">RecvTimeoutError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Token</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w">	</span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="c1">// Try receiving a message several times.
</span><span class="c1"></span><span class="w">		</span><span class="kd">let</span><span class="w"> </span><span class="n">backoff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Backoff</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">		</span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">start_recv</span><span class="p">(</span><span class="n">token</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">				</span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">					</span><span class="k">return</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">token</span><span class="p">).</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="n">RecvTimeoutError</span>::<span class="n">Disconnected</span><span class="p">);</span><span class="w">
</span><span class="w">				</span><span class="p">}</span><span class="w">
</span><span class="w">			</span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="n">backoff</span><span class="p">.</span><span class="n">is_completed</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">				</span><span class="k">break</span><span class="p">;</span><span class="w">
</span><span class="w">			</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">				</span><span class="n">backoff</span><span class="p">.</span><span class="n">snooze</span><span class="p">();</span><span class="w">
</span><span class="w">			</span><span class="p">}</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">deadline</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="n">Instant</span>::<span class="n">now</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">				</span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">RecvTimeoutError</span>::<span class="n">Timeout</span><span class="p">);</span><span class="w">
</span><span class="w">			</span><span class="p">}</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">		</span><span class="c1">// Prepare for blocking until a sender wakes us up.
</span><span class="c1"></span><span class="w">		</span><span class="n">Context</span>::<span class="n">with</span><span class="p">(</span><span class="o">|</span><span class="n">cx</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="kd">let</span><span class="w"> </span><span class="n">oper</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Operation</span>::<span class="n">hook</span><span class="p">(</span><span class="n">token</span><span class="p">);</span><span class="w">
</span><span class="w">			</span><span class="bp">self</span><span class="p">.</span><span class="n">receivers</span><span class="p">.</span><span class="n">register</span><span class="p">(</span><span class="n">oper</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">			</span><span class="c1">// Has the channel become ready just now?
</span><span class="c1"></span><span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="bp">self</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">is_disconnected</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">				</span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cx</span><span class="p">.</span><span class="n">try_select</span><span class="p">(</span><span class="n">Selected</span>::<span class="n">Aborted</span><span class="p">);</span><span class="w">
</span><span class="w">			</span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">			</span><span class="c1">// Block the current thread.
</span><span class="c1"></span><span class="w">			</span><span class="kd">let</span><span class="w"> </span><span class="n">sel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cx</span><span class="p">.</span><span class="n">wait_until</span><span class="p">(</span><span class="n">deadline</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">			</span><span class="k">match</span><span class="w"> </span><span class="n">sel</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">				</span><span class="n">Selected</span>::<span class="n">Waiting</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">unreachable</span><span class="o">!</span><span class="p">(),</span><span class="w">
</span><span class="w">				</span><span class="n">Selected</span>::<span class="n">Aborted</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Selected</span>::<span class="n">Disconnected</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">					</span><span class="bp">self</span><span class="p">.</span><span class="n">receivers</span><span class="p">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">oper</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">					</span><span class="c1">// If the channel was disconnected, we still have to check for remaining
</span><span class="c1"></span><span class="w">					</span><span class="c1">// messages.
</span><span class="c1"></span><span class="w">				</span><span class="p">}</span><span class="w">
</span><span class="w">				</span><span class="n">Selected</span>::<span class="n">Operation</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">			</span><span class="p">}</span><span class="w">
</span><span class="w">		</span><span class="p">});</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>recv数据时，过程其实类似：</p>
<ol>
<li>获取下一个槽的操作权限</li>
<li>等待槽的已写入状态</li>
<li>读取数据</li>
</ol>
<p>当Channel为空时，采取的策略是自旋、让出CPU、睡眠线程，这样的策略在高并发实践中也非常常见。</p>
<p>在<code>start_recv</code>方法中：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">if</span><span class="w"> </span><span class="n">new_head</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">MARK_BIT</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">atomic</span>::<span class="n">fence</span><span class="p">(</span><span class="n">Ordering</span>::<span class="n">SeqCst</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Ordering</span>::<span class="n">Relaxed</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">	</span><span class="c1">// If the tail equals the head, that means the channel is empty.
</span><span class="c1"></span><span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">SHIFT</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">SHIFT</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="c1">// If the channel is disconnected...
</span><span class="c1"></span><span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">MARK_BIT</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="c1">// ...then receive an error.
</span><span class="c1"></span><span class="w">			</span><span class="n">token</span><span class="p">.</span><span class="n">list</span><span class="p">.</span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr</span>::<span class="n">null</span><span class="p">();</span><span class="w">
</span><span class="w">			</span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="c1">// Otherwise, the receive operation is not ready.
</span><span class="c1"></span><span class="w">			</span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">	</span><span class="c1">// If head and tail are not in the same block, set `MARK_BIT` in head.
</span><span class="c1"></span><span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">head</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">SHIFT</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">LAP</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="n">tail</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">SHIFT</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">LAP</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="n">new_head</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">MARK_BIT</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>head的MARK_BIT标记为0时，当前Block是最后一个Block，如果head与tail的index相同，则说明Channel为空。
tail的MARK_BIT标记不为0时，说明Channel已disconnected（生产者数量为0），不会再有新消息，此时抛出一个错误。
由于处于并发环境下，当此时的head和tail不处于同一个Block时，还需要设置head的MARK_BIT标记。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// The block can be null here only if the first message is being sent into the channel.
</span><span class="c1">// In that case, just wait until it gets initialized.
</span><span class="c1"></span><span class="k">if</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">is_null</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">backoff</span><span class="p">.</span><span class="n">snooze</span><span class="p">();</span><span class="w">
</span><span class="w">	</span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Ordering</span>::<span class="n">Acquire</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">block</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Ordering</span>::<span class="n">Acquire</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="k">continue</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>当block为空时，说明第一条消息正在创建Block，这里就进行等待。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Try moving the head index forward.
</span><span class="c1"></span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="w">
</span><span class="w">	</span><span class="n">head</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">new_head</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">Ordering</span>::<span class="n">SeqCst</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">Ordering</span>::<span class="n">Acquire</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="c1">// If we&#39;ve reached the end of the block, move to the next one.
</span><span class="c1"></span><span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">BLOCK_CAP</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="kd">let</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">block</span><span class="p">).</span><span class="n">wait_next</span><span class="p">();</span><span class="w">
</span><span class="w">			</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">next_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">new_head</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">MARK_BIT</span><span class="p">).</span><span class="n">wrapping_add</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">SHIFT</span><span class="p">);</span><span class="w">
</span><span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">).</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Ordering</span>::<span class="n">Relaxed</span><span class="p">).</span><span class="n">is_null</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">				</span><span class="n">next_index</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">MARK_BIT</span><span class="p">;</span><span class="w">
</span><span class="w">			</span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">			</span><span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">block</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">Release</span><span class="p">);</span><span class="w">
</span><span class="w">			</span><span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">next_index</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">Release</span><span class="p">);</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">		</span><span class="n">token</span><span class="p">.</span><span class="n">list</span><span class="p">.</span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="w">
</span><span class="w">		</span><span class="n">token</span><span class="p">.</span><span class="n">list</span><span class="p">.</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span><span class="w">
</span><span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="p">},</span><span class="w">
</span><span class="w">	</span><span class="nb">Err</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">h</span><span class="p">;</span><span class="w">
</span><span class="w">		</span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">block</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Ordering</span>::<span class="n">Acquire</span><span class="p">);</span><span class="w">
</span><span class="w">		</span><span class="n">backoff</span><span class="p">.</span><span class="n">spin</span><span class="p">();</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>然后替换head，成功替换后，如果已到达当前Block的末端，则移动到下一个Block。同样，如果下一个Block正在创建，则需要等待，同时MARK_BIT也需要做相应设置。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="sd">/// Reads a message from the channel.
</span><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">read</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">token</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Token</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="n">token</span><span class="p">.</span><span class="n">list</span><span class="p">.</span><span class="n">block</span><span class="p">.</span><span class="n">is_null</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="c1">// The channel is disconnected.
</span><span class="c1"></span><span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(());</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">	</span><span class="c1">// Read the message.
</span><span class="c1"></span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">token</span><span class="p">.</span><span class="n">list</span><span class="p">.</span><span class="n">block</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">Block</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">token</span><span class="p">.</span><span class="n">list</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">slot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">block</span><span class="p">).</span><span class="n">slots</span><span class="p">.</span><span class="n">get_unchecked</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="n">slot</span><span class="p">.</span><span class="n">wait_write</span><span class="p">();</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slot</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">read</span><span class="p">().</span><span class="n">assume_init</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">	</span><span class="c1">// Destroy the block if we&#39;ve reached the end, or if another thread wanted to destroy but
</span><span class="c1"></span><span class="w">	</span><span class="c1">// couldn&#39;t because we were busy reading from the slot.
</span><span class="c1"></span><span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">BLOCK_CAP</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="n">Block</span>::<span class="n">destroy</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">slot</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">fetch_or</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">AcqRel</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">DESTROY</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="n">Block</span>::<span class="n">destroy</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">	</span><span class="nb">Ok</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在<code>read</code>方法中，如果对应的Slot正在写入，则需要等待其写入完成。而如果已到达当前Block的末端，则需要销毁这个Block。</p>
<p>不过由于处于并发环境，当获取到Slot的操作权限后，其他线程的操作已经可以进行下去，那么就会出现上一个Block的Slot还在读取过程中的情况，这时候Slot的DESTROY位
会被设置。这种情况下，读取完成的线程需要负责Block的销毁工作。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="sd">/// Sets the `DESTROY` bit in slots starting from `start` and destroys the block.
</span><span class="sd"></span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">destroy</span><span class="p">(</span><span class="n">this</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">Block</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">start</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="c1">// It is not necessary to set the `DESTROY` bit in the last slot because that slot has
</span><span class="c1"></span><span class="w">	</span><span class="c1">// begun destruction of the block.
</span><span class="c1"></span><span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">start</span><span class="p">..</span><span class="n">BLOCK_CAP</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="kd">let</span><span class="w"> </span><span class="n">slot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">).</span><span class="n">slots</span><span class="p">.</span><span class="n">get_unchecked</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">		</span><span class="c1">// Mark the `DESTROY` bit if a thread is still using the slot.
</span><span class="c1"></span><span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="n">slot</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Ordering</span>::<span class="n">Acquire</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">READ</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="w">			</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">slot</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">fetch_or</span><span class="p">(</span><span class="n">DESTROY</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">AcqRel</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">READ</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="w">		</span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="c1">// If a thread is still using the slot, it will continue destruction of the block.
</span><span class="c1"></span><span class="w">			</span><span class="k">return</span><span class="p">;</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">	</span><span class="c1">// No thread is using the block, now it is safe to destroy it.
</span><span class="c1"></span><span class="w">	</span><span class="n">drop</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">from_raw</span><span class="p">(</span><span class="n">this</span><span class="p">));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>从<code>destroy</code>方法的实现看，在销毁前需要先设置DESTROY位，如果某个Slot还在读取过程中，则跳出。直到所有Slot都不在被使用后，执行销毁。</p>
<h2 id="创建和销毁channel">创建和销毁Channel</h2>
<p>以上内容是无锁并发Channel的最核心部分：如何使发送和接收消息的并发临界区最小化。不过由于crossbeam的Channel是多生产者多消费者模型，在生产者或消费者
不再存在时，还需要执行清理、销毁Channel操作。</p>
<p>当生产者或消费者一方不再存在时，我们称为disconnected；只有当生产者和消费者都不再存在时，才会完全销毁Channel。</p>
<p>而crossbeam是通过Counter这个结构来记录生产者和消费者数量的：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="sd">/// Reference counter internals.
</span><span class="sd"></span><span class="k">struct</span> <span class="nc">Counter</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="sd">/// The number of senders associated with the channel.
</span><span class="sd"></span><span class="w">    </span><span class="n">senders</span>: <span class="nc">AtomicUsize</span><span class="p">,</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// The number of receivers associated with the channel.
</span><span class="sd"></span><span class="w">    </span><span class="n">receivers</span>: <span class="nc">AtomicUsize</span><span class="p">,</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// Set to `true` if the last sender or the last receiver reference deallocates the channel.
</span><span class="sd"></span><span class="w">    </span><span class="n">destroy</span>: <span class="nc">AtomicBool</span><span class="p">,</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// The internal channel.
</span><span class="sd"></span><span class="w">    </span><span class="n">chan</span>: <span class="nc">C</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="sd">/// Wraps a channel into the reference counter.
</span><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">(</span><span class="n">chan</span>: <span class="nc">C</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="n">Sender</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Receiver</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">into_raw</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Counter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">senders</span>: <span class="nc">AtomicUsize</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">receivers</span>: <span class="nc">AtomicUsize</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">destroy</span>: <span class="nc">AtomicBool</span>::<span class="n">new</span><span class="p">(</span><span class="kc">false</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">chan</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}));</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Sender</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Receiver</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>从构造方法中也能看到，Sender和Receiver共享了一个Counter的裸指针。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Sender</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="sd">/// Acquires another sender reference.
</span><span class="sd"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Sender</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">counter</span><span class="p">().</span><span class="n">senders</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">Relaxed</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="c1">// Cloning senders and calling `mem::forget` on the clones could potentially overflow the
</span><span class="c1"></span><span class="w">        </span><span class="c1">// counter. It&#39;s very difficult to recover sensibly from such degenerate scenarios so we
</span><span class="c1"></span><span class="w">        </span><span class="c1">// just abort when the count becomes very large.
</span><span class="c1"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="kt">isize</span>::<span class="n">MAX</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">process</span>::<span class="n">abort</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="n">Sender</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">counter</span>: <span class="nc">self</span><span class="p">.</span><span class="n">counter</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Receiver</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="sd">/// Acquires another receiver reference.
</span><span class="sd"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Receiver</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">counter</span><span class="p">().</span><span class="n">receivers</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">Relaxed</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="c1">// Cloning receivers and calling `mem::forget` on the clones could potentially overflow the
</span><span class="c1"></span><span class="w">        </span><span class="c1">// counter. It&#39;s very difficult to recover sensibly from such degenerate scenarios so we
</span><span class="c1"></span><span class="w">        </span><span class="c1">// just abort when the count becomes very large.
</span><span class="c1"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="kt">isize</span>::<span class="n">MAX</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">process</span>::<span class="n">abort</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="n">Receiver</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">counter</span>: <span class="nc">self</span><span class="p">.</span><span class="n">counter</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Sender和Receiver的<code>acquire</code>方法分别用于增加生产者和消费者，实现方法则是通过增加原子计数。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Sender</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="sd">/// Releases the sender reference.
</span><span class="sd"></span><span class="w">    </span><span class="sd">///
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// Function `disconnect` will be called if this is the last sender reference.
</span><span class="sd"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">release</span><span class="o">&lt;</span><span class="n">F</span>: <span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">C</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">disconnect</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">counter</span><span class="p">().</span><span class="n">senders</span><span class="p">.</span><span class="n">fetch_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">AcqRel</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">counter</span><span class="p">().</span><span class="n">chan</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">counter</span><span class="p">().</span><span class="n">destroy</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">AcqRel</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">drop</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">from_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">counter</span><span class="p">));</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Receiver</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="sd">/// Releases the receiver reference.
</span><span class="sd"></span><span class="w">    </span><span class="sd">///
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// Function `disconnect` will be called if this is the last receiver reference.
</span><span class="sd"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">release</span><span class="o">&lt;</span><span class="n">F</span>: <span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">C</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">disconnect</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">counter</span><span class="p">().</span><span class="n">receivers</span><span class="p">.</span><span class="n">fetch_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">AcqRel</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">counter</span><span class="p">().</span><span class="n">chan</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">counter</span><span class="p">().</span><span class="n">destroy</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">AcqRel</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">drop</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">from_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">counter</span><span class="p">));</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>release</code>方法分别用于释放生产者和消费者，并且当一方的计数归0时，需要执行<code>disconnect</code>方法用于唤醒所有处于等待中的消费者线程和设置disconneted位标记，
这样当已经被disconnected标记后的生产者和消费者再进行操作时就会产生对应的错误。</p>
<p>当生产者和消费者都设置过destroy字段后，销毁Counter并间接析构Channel：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Channel</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Ordering</span>::<span class="n">Relaxed</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Ordering</span>::<span class="n">Relaxed</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">block</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Ordering</span>::<span class="n">Relaxed</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="c1">// Erase the lower bits.
</span><span class="c1"></span><span class="w">        </span><span class="n">head</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">!</span><span class="p">((</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">SHIFT</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">tail</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">!</span><span class="p">((</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">SHIFT</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// Drop all messages between head and tail and deallocate the heap-allocated blocks.
</span><span class="c1"></span><span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">head</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">SHIFT</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">LAP</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">BLOCK_CAP</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="c1">// Drop the message in the slot.
</span><span class="c1"></span><span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">slot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">block</span><span class="p">).</span><span class="n">slots</span><span class="p">.</span><span class="n">get_unchecked</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span><span class="w">
</span><span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="n">slot</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">get</span><span class="p">();</span><span class="w">
</span><span class="w">                    </span><span class="n">p</span><span class="p">.</span><span class="n">as_mut_ptr</span><span class="p">().</span><span class="n">drop_in_place</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="c1">// Deallocate the block and move to the next one.
</span><span class="c1"></span><span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">block</span><span class="p">).</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Ordering</span>::<span class="n">Relaxed</span><span class="p">);</span><span class="w">
</span><span class="w">                    </span><span class="n">drop</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">from_raw</span><span class="p">(</span><span class="n">block</span><span class="p">));</span><span class="w">
</span><span class="w">                    </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next</span><span class="p">;</span><span class="w">
</span><span class="w">                </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">                </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">.</span><span class="n">wrapping_add</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">SHIFT</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="c1">// Deallocate the last remaining block.
</span><span class="c1"></span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">block</span><span class="p">.</span><span class="n">is_null</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">drop</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">from_raw</span><span class="p">(</span><span class="n">block</span><span class="p">));</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Channel的析构方法会依次销毁每个Block中的每个Slot。</p>
<h2 id="小结">小结</h2>
<p>无锁并发Channel作为crossbeam中的并发数据结构之一，在多任务系统上提供了足够好的伸缩性，实现方式也非常精妙，我们可以在诸多Rust并发应用中看到它的身影。</p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="https://aturon.github.io/blog/2015/08/27/epoch/">Lock-freedom without garbage collection</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/44347642">Rust PR：Mostly-LF -&gt; Lock-Free</a></li>
<li><a href="https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange">https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange</a></li>
<li><a href="https://stackoverflow.com/questions/25199838/understanding-stdatomiccompare-exchange-weak-in-c11">Understanding std::atomic::compare_exchange_weak() in C++11</a></li>
<li><a href="https://en.wikipedia.org/wiki/Load-link/store-conditional">Load-link/store-conditional</a></li>
</ol>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Epoch-based memory reclamation - <a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf">Practical lock-freedom</a> <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>]]></content>
		</item>
		
		<item>
			<title>用Rust实现一个Goroutine</title>
			<link>https://xiaopengli89.github.io/posts/goroutine-rs/</link>
			<pubDate>Wed, 05 Aug 2020 14:11:03 +0800</pubDate>
			
			<guid>https://xiaopengli89.github.io/posts/goroutine-rs/</guid>
			<description>&lt;p&gt;这几天本来是想实现下Go1.14中的信号抢占调度器，不过结果还是遇到了难点，主要在于如何获取到信号处理前的上下文信息。
这篇文章用于记录下实现的过程，尽管最终只实现了协作式调度，
但还是整理出了目前用户态实现异步抢占或类抢占的实现方式。&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>这几天本来是想实现下Go1.14中的信号抢占调度器，不过结果还是遇到了难点，主要在于如何获取到信号处理前的上下文信息。
这篇文章用于记录下实现的过程，尽管最终只实现了协作式调度，
但还是整理出了目前用户态实现异步抢占或类抢占的实现方式。</p>
<h2 id="gmp模型">GMP模型</h2>
<p>关于GMP模型的解析网上已经有不少文章，因此不在这里做重复式的搬运。</p>
<p>在这里我对于M和P的实现是直接基于<code>thread_local</code>的，也没有去实现工作窃取，简单看下P的结构定义：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Processor</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">tx</span>: <span class="nc">Sender</span><span class="o">&lt;</span><span class="n">Goroutine</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">tx_new</span>: <span class="nc">Sender</span><span class="o">&lt;</span><span class="n">TaskInfo</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">rx</span>: <span class="nc">Receiver</span><span class="o">&lt;</span><span class="n">Goroutine</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">rx_new</span>: <span class="nc">Receiver</span><span class="o">&lt;</span><span class="n">TaskInfo</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">current</span>: <span class="nc">Cell</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Goroutine</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">safe_point</span>: <span class="nc">AtomicBool</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">private_stack</span>: <span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>其中几个<code>Sender</code>和<code>Receiver</code>用于任务的提交和获取，<code>current</code>保存当前正在运行的G，
<code>safe_point</code>用于标记目前是否处于安全抢占点，不过由于抢占处于未完成状态，因此实际不会用到它，
<code>private_stack</code>是每个P独立的私有栈空间，主要作用是当一个G运行结束后，需要回收G的栈空间时作为回收操作的上下文。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">thread_local</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">PROCESSOR</span>: <span class="nc">Processor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Processor</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Processor</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// 栈默认空间大小
</span><span class="c1"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">STACK_SIZE</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// processor私有栈，用于回收goroutine时的上下文
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">layout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Layout</span>::<span class="n">from_size_align_unchecked</span><span class="p">(</span><span class="n">Self</span>::<span class="n">STACK_SIZE</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">alloc</span><span class="p">(</span><span class="n">layout</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">bp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">stack</span><span class="p">.</span><span class="n">offset</span><span class="p">(</span><span class="n">Self</span>::<span class="n">STACK_SIZE</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">isize</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bp</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mpsc</span>::<span class="n">channel</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tx_new</span><span class="p">,</span><span class="w"> </span><span class="n">rx_new</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mpsc</span>::<span class="n">channel</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">tx</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">tx_new</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">rx</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">rx_new</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">current</span>: <span class="nc">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">safe_point</span>: <span class="nc">AtomicBool</span>::<span class="n">new</span><span class="p">(</span><span class="kc">false</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">private_stack</span>: <span class="p">(</span><span class="n">bp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>当需要提交一个新任务时，会通过<code>tx_new</code>投递一个<code>TaskInfo</code>进来，而<code>TaskInfo</code>主要描述了任务需要执行的代码和栈空间：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">TaskInfo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">task</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">stack_size</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>对于<code>task</code>用闭包还是遇到了个问题，那就是在代码跳转时，怎么获取到匿名闭包的<code>call</code>方法地址（当然还有其捕获的变量）。
于是参考了<a href="https://cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/final-200-lines-of-code">Green Threads Explained in 200 Lines of Rust</a>
这篇文章，作者是直接使用了函数指针，这种方式虽然可以直接从函数指针获取到其代码地址，
但同时也失去了闭包的灵活性，比如在2个G之间需要通信时，需要通过闭包捕获进<code>channel</code>。</p>
<p>不过后来还是利用闭包的内存布局实现了闭包作为任务入口。</p>
<p>由于闭包在内存布局上是个胖指针，因此可以提取出<code>data</code>和<code>vtable</code>，然后分别利用C的调用约定，传递进一个全局函数中，
再在那个全局函数中把参数恢复成闭包并执行。</p>
<p>并且这样还带来了一个好处，就是可以在全局函数中做G的清理工作。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// ...
</span><span class="c1">// 从新任务队列获取
</span><span class="c1">// 分配栈空间
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">layout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Layout</span>::<span class="n">from_size_align_unchecked</span><span class="p">(</span><span class="n">stack_size</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">alloc</span><span class="p">(</span><span class="n">layout</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">bp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">stack</span><span class="p">.</span><span class="n">offset</span><span class="p">(</span><span class="n">stack_size</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">isize</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bp</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="bp">self</span><span class="p">.</span><span class="n">current</span><span class="w">
</span><span class="w">		</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">Goroutine</span>::<span class="n">new</span><span class="p">(</span><span class="n">stack_size</span><span class="p">,</span><span class="w"> </span><span class="n">stack</span><span class="p">,</span><span class="w"> </span><span class="n">layout</span><span class="p">)));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">into_raw</span><span class="p">(</span><span class="n">task</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="c1">// task是个胖指针, data和vtable需要单独传递
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">vtable</span><span class="p">)</span>: <span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">mem</span>::<span class="n">transmute</span><span class="p">(</span><span class="n">task</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// 修改栈指针并跳转
</span><span class="c1"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;mov rsp, {sp}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;mov rbp, {bp}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;mov rdi, {data}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;mov rsi, {vtable}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;call {launch}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="n">bp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">bp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="n">vtable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">vtable</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="n">launch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sym</span><span class="w"> </span><span class="n">launch</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">unreachable</span><span class="o">!</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="c1">// ...
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">launch</span><span class="p">(</span><span class="n">data</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">vtable</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// 恢复FnOnce
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mem</span>::<span class="n">transmute</span><span class="p">((</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">vtable</span><span class="p">));</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">from_raw</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="c1">// 执行任务
</span><span class="c1"></span><span class="w">    </span><span class="n">f</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">PROCESSOR</span><span class="p">.</span><span class="n">with</span><span class="p">(</span><span class="o">|</span><span class="n">p</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// 切换到processor私有栈空间以回收goroutine的栈空间
</span><span class="c1"></span><span class="w">        </span><span class="c1">// 永不返回
</span><span class="c1"></span><span class="w">        </span><span class="n">p</span><span class="p">.</span><span class="n">context_to_private</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">})</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>当G执行完成后，需要清理其栈空间，不过不能直接在G的上下文中执行清理工作，因为回收自身会造成段错误。</p>
<p>因此需要先切换到P本身附带的一个私有栈空间，再去执行清理工作。</p>
<p>清理完成后，还需要检查当前运行时是否已经退出，比如当主Goroutine运行结束后会关闭运行时。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// 必须在processor私有栈空间执行
</span><span class="c1">// 永不返回
</span><span class="c1"></span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">dealloc_current</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">PROCESSOR</span><span class="p">.</span><span class="n">with</span><span class="p">(</span><span class="o">|</span><span class="n">p</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// 回收已完成的goroutine栈空间
</span><span class="c1"></span><span class="w">        </span><span class="n">p</span><span class="p">.</span><span class="n">dealloc_current</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="c1">// 检查退出
</span><span class="c1"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">RT</span><span class="p">.</span><span class="n">is_shutdown</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">libc</span>::<span class="n">pthread_exit</span><span class="p">(</span><span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">());</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="c1">// 运行下一个goroutine，永不返回
</span><span class="c1"></span><span class="w">        </span><span class="n">p</span><span class="p">.</span><span class="n">run</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">})</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Processor</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">context_to_private</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">                </span><span class="s">&#34;mov rbp, {bp}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="s">&#34;mov rsp, {sp}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="s">&#34;call {dealloc_current}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="n">bp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">private_stack</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">private_stack</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="n">dealloc_current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sym</span><span class="w"> </span><span class="n">dealloc_current</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">unreachable</span><span class="o">!</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">dealloc_current</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">current</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">take</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">dealloc</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">stack</span><span class="p">,</span><span class="w"> </span><span class="n">current</span><span class="p">.</span><span class="n">layout</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>然后是看下G的定义：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Context</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">ucontext</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">libc</span>::<span class="n">ucontext_t</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Goroutine</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// 上下文
</span><span class="c1"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">cx</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Context</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="c1">// 栈大小
</span><span class="c1"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">stack_size</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="c1">// 栈空间
</span><span class="c1"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">stack</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="c1">// 内存布局
</span><span class="c1"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">layout</span>: <span class="nc">Layout</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Goroutine</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">stack_size</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">stack</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">layout</span>: <span class="nc">Layout</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">cx</span>: <span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">stack_size</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">stack</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">layout</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>G的结构其实就非常简单了，主要就是调度时需要的上下文以及清理G时需要的栈空间布局信息。</p>
<p>由于我这里没有实现工作窃取，那调度器的实现其实也就非常简单了，主要的工作就是从<code>tx_new</code>获取新任务，
以及从<code>tx</code>获取之前被调度走的未完成的任务。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// 运行下一个goroutine，永不返回
</span><span class="c1"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">TaskInfo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">task</span><span class="p">,</span><span class="w"> </span><span class="n">stack_size</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">rx_new</span><span class="p">.</span><span class="n">try_recv</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="c1">// 从新任务队列获取
</span><span class="c1"></span><span class="w">			</span><span class="c1">// 分配栈空间
</span><span class="c1"></span><span class="w">			</span><span class="kd">let</span><span class="w"> </span><span class="n">layout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Layout</span>::<span class="n">from_size_align_unchecked</span><span class="p">(</span><span class="n">stack_size</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">			</span><span class="kd">let</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">alloc</span><span class="p">(</span><span class="n">layout</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">			</span><span class="kd">let</span><span class="w"> </span><span class="n">bp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">stack</span><span class="p">.</span><span class="n">offset</span><span class="p">(</span><span class="n">stack_size</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">isize</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">			</span><span class="kd">let</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bp</span><span class="p">;</span><span class="w">
</span><span class="w">			</span><span class="p">{</span><span class="w">
</span><span class="w">				</span><span class="bp">self</span><span class="p">.</span><span class="n">current</span><span class="w">
</span><span class="w">					</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">Goroutine</span>::<span class="n">new</span><span class="p">(</span><span class="n">stack_size</span><span class="p">,</span><span class="w"> </span><span class="n">stack</span><span class="p">,</span><span class="w"> </span><span class="n">layout</span><span class="p">)));</span><span class="w">
</span><span class="w">			</span><span class="p">}</span><span class="w">
</span><span class="w">			</span><span class="kd">let</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">into_raw</span><span class="p">(</span><span class="n">task</span><span class="p">);</span><span class="w">
</span><span class="w">			</span><span class="c1">// task是个胖指针, data和vtable需要单独传递
</span><span class="c1"></span><span class="w">			</span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">vtable</span><span class="p">)</span>: <span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">mem</span>::<span class="n">transmute</span><span class="p">(</span><span class="n">task</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">			</span><span class="c1">// 修改栈指针并跳转
</span><span class="c1"></span><span class="w">			</span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">				</span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">					</span><span class="s">&#34;mov rsp, {sp}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">					</span><span class="s">&#34;mov rbp, {bp}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">					</span><span class="s">&#34;mov rdi, {data}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">					</span><span class="s">&#34;mov rsi, {vtable}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">					</span><span class="s">&#34;call {launch}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">					</span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w">					</span><span class="n">bp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">bp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w">					</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w">
</span><span class="w">					</span><span class="n">vtable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">vtable</span><span class="p">,</span><span class="w">
</span><span class="w">					</span><span class="n">launch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sym</span><span class="w"> </span><span class="n">launch</span><span class="p">,</span><span class="w">
</span><span class="w">				</span><span class="p">);</span><span class="w">
</span><span class="w">			</span><span class="p">}</span><span class="w">
</span><span class="w">			</span><span class="n">unreachable</span><span class="o">!</span><span class="p">();</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">g_next</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">rx</span><span class="p">.</span><span class="n">try_recv</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="c1">// 从运行队列获取
</span><span class="c1"></span><span class="w">			</span><span class="kd">let</span><span class="w"> </span><span class="n">cx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_next</span><span class="p">.</span><span class="n">cx</span><span class="p">.</span><span class="n">as_ref</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">			</span><span class="kd">let</span><span class="w"> </span><span class="n">ucontext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cx</span><span class="p">.</span><span class="n">ucontext</span><span class="p">.</span><span class="n">as_ref</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">_</span><span class="p">;</span><span class="w">
</span><span class="w">			</span><span class="p">{</span><span class="w">
</span><span class="w">				</span><span class="bp">self</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">g_next</span><span class="p">));</span><span class="w">
</span><span class="w">			</span><span class="p">}</span><span class="w">
</span><span class="w">			</span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">				</span><span class="c1">// 恢复上下文
</span><span class="c1"></span><span class="w">				</span><span class="n">libc</span>::<span class="n">setcontext</span><span class="p">(</span><span class="n">ucontext</span><span class="p">);</span><span class="w">
</span><span class="w">			</span><span class="p">}</span><span class="w">
</span><span class="w">			</span><span class="n">unreachable</span><span class="o">!</span><span class="p">();</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span><span class="w">
</span><span class="w">			</span><span class="k">continue</span><span class="p">;</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>调度方法需要保存当前的上下文，之后将任务重新放回队列尾端，执行下一个任务。</p>
<p>需要注意的是，当目前的G下次被重新调度时，恢复上下文后执行的指令就是保存的那个地址后的一个指令，为了避免被无限调度（刚恢复又申请调度），
需要一个标记来区分是不是恢复后的上下文。并且这个标记不能成为上下文快照的一部分，也就是读取和修改必须是内存操作。
如果仅仅用一个栈上变量来作为标记是不行的，因为该变量可能会被写入寄存器，获取上下文后再修改它对于下次恢复时是不可见的，
因为会被作为上下文快照的一部分被恢复成之前的值。</p>
<p>另外需要注意的是：</p>
<ol>
<li>初始化标记</li>
<li>获取上下文快照</li>
<li>修改标记</li>
<li>调度</li>
</ol>
<p>这4步操作是不能被编译器或CPU指令重排优化的，否则会UB。这里我使用<code>read_volatile</code>和<code>write_volatile</code>来确保内存操作和屏障：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">Processor</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="c1">// 保存当前现场并运行下一个goroutine，永不返回
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">sched</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="nc">Context</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">current</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">take</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// 保存现场
</span><span class="c1"></span><span class="w">            </span><span class="n">current</span><span class="p">.</span><span class="n">cx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="c1">// 添加到队列尾端
</span><span class="c1"></span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">tx</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">current</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">run</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">do_sched</span><span class="p">(</span><span class="n">p</span>: <span class="kp">&amp;</span><span class="nc">Processor</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">cx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">cx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mem</span>::<span class="n">zeroed</span>::<span class="o">&lt;</span><span class="n">libc</span>::<span class="n">ucontext_t</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">libc</span>::<span class="n">getcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">cx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">_</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">ptr</span>::<span class="n">read_volatile</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skip</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">return</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">ptr</span>::<span class="n">write_volatile</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">cx</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 调度，永不返回
</span><span class="c1"></span><span class="w">    </span><span class="n">p</span><span class="p">.</span><span class="n">sched</span><span class="p">(</span><span class="n">Context</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">ucontext</span>: <span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">cx</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">});</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// 主动申请调度
</span><span class="c1"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">sched</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">PROCESSOR</span><span class="p">.</span><span class="n">with</span><span class="p">(</span><span class="n">do_sched</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>运行时的实现方面，初始化工作就是创建线程（M），并启动其Processor：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Runtime</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">thread_num</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="c1">// 与Processor通信
</span><span class="c1"></span><span class="w">    </span><span class="n">goroutine_tx</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">ProcessorChannel</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">is_shutdown</span>: <span class="nc">AtomicBool</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">ProcessorChannel</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">tx</span>: <span class="nc">Sender</span><span class="o">&lt;</span><span class="n">TaskInfo</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">pid</span>: <span class="nc">libc</span>::<span class="n">pthread_t</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">lock</span>: <span class="nc">AtomicBool</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Runtime</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">thread_num</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">goroutine_tx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[];</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tx2</span><span class="p">,</span><span class="w"> </span><span class="n">rx2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mpsc</span>::<span class="n">channel</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="n">thread_num</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">tx2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tx2</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="n">libc</span>::<span class="n">pthread_self</span><span class="p">()</span><span class="w">
</span><span class="w">                </span><span class="p">};</span><span class="w">
</span><span class="w">                </span><span class="n">PROCESSOR</span><span class="p">.</span><span class="n">with</span><span class="p">(</span><span class="o">|</span><span class="n">p</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">tx_new</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">                    </span><span class="n">tx2</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">ProcessorChannel</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                        </span><span class="n">tx</span><span class="p">,</span><span class="w">
</span><span class="w">                        </span><span class="n">pid</span><span class="p">,</span><span class="w">
</span><span class="w">                        </span><span class="n">lock</span>: <span class="nc">AtomicBool</span>::<span class="n">new</span><span class="p">(</span><span class="kc">false</span><span class="p">),</span><span class="w">
</span><span class="w">                    </span><span class="p">})</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">                    </span><span class="c1">// 启动processor
</span><span class="c1"></span><span class="w">                    </span><span class="n">p</span><span class="p">.</span><span class="n">run</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="p">});</span><span class="w">
</span><span class="w">            </span><span class="p">});</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="n">thread_num</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">goroutine_tx</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">rx2</span><span class="p">.</span><span class="n">recv</span><span class="p">().</span><span class="n">unwrap</span><span class="p">());</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">thread_num</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">goroutine_tx</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">is_shutdown</span>: <span class="nc">AtomicBool</span>::<span class="n">new</span><span class="p">(</span><span class="kc">false</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>投递新任务可以指定G需要的栈空间大小，由于可能在不同的M上启动新的G，而<code>Sender</code>是非线程安全的，因此使用了自旋保护：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">Processor</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// 使用默认栈大小启动一个goroutine
</span><span class="c1"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">go</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnOnce</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">go_with_stack_size</span><span class="p">(</span><span class="n">Processor</span>::<span class="n">STACK_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 指定栈大小启动一个goroutine
</span><span class="c1"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">go_with_stack_size</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">stack_size</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnOnce</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SystemTime</span>::<span class="n">now</span><span class="p">()</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">duration_since</span><span class="p">(</span><span class="n">SystemTime</span>::<span class="n">UNIX_EPOCH</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">as_nanos</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">thread_num</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">f</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="c1">// 获取锁
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">goroutine_tx</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">
</span><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">lock</span><span class="p">.</span><span class="n">compare_and_swap</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">SeqCst</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">		</span><span class="c1">// 投递任务
</span><span class="c1"></span><span class="w">        </span><span class="n">p</span><span class="p">.</span><span class="n">tx</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">TaskInfo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">stack_size</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">task</span>: <span class="nc">f</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">})</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="c1">// 释放锁
</span><span class="c1"></span><span class="w">        </span><span class="n">p</span><span class="p">.</span><span class="n">lock</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">SeqCst</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>最后是关闭运行时方法, 主要用于主Goroutine退出时执行：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">Processor</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// 关闭runtime
</span><span class="c1"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">shutdown</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">is_shutdown</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">SeqCst</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">is_shutdown</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">is_shutdown</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Ordering</span>::<span class="n">SeqCst</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>关于运行时的初始化，我简单地实现了个Lazy加载器，不过最近
<a href="https://github.com/rust-lang/rust/pull/72414">Add lazy initialization primitives to std #72414</a>
也已经合并进标准库，以后很多项目都不必依赖<a href="https://crates.io/crates/once_cell">once_cell</a>或
<a href="https://crates.io/crates/lazy_static">lazy_static</a>了。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Lazy</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">fn</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">inner</span>: <span class="nc">Cell</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">once</span>: <span class="nc">Once</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">init</span>: <span class="nc">Cell</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Lazy</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">inner</span>: <span class="nc">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">once</span>: <span class="nc">Once</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">            </span><span class="n">init</span>: <span class="nc">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">f</span><span class="p">)),</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Lazy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span>::<span class="n">Target</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">once</span><span class="p">.</span><span class="n">call_once</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">init</span><span class="p">.</span><span class="n">take</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">init</span><span class="p">()));</span><span class="w">
</span><span class="w">        </span><span class="p">});</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;*</span><span class="n">p</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="n">p</span><span class="p">.</span><span class="n">as_ref</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Lazy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// ...
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// M线程数
</span><span class="c1"></span><span class="k">static</span><span class="w"> </span><span class="n">THREAD_NUM</span>: <span class="nc">AtomicUsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AtomicUsize</span>::<span class="n">new</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// 初始化Runtime
</span><span class="c1"></span><span class="k">pub</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">RT</span>: <span class="nc">Lazy</span><span class="o">&lt;</span><span class="n">Runtime</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Lazy</span>::<span class="n">new</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">Runtime</span>::<span class="n">new</span><span class="p">(</span><span class="n">THREAD_NUM</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Ordering</span>::<span class="n">SeqCst</span><span class="p">)));</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[allow(dead_code)]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">set_thread_num</span><span class="p">(</span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">THREAD_NUM</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">SeqCst</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在Go中，main函数其实并不是程序的真正入口，而是作为一个独立的G运行的。
为此我利用Rust的属性宏将原本的main函数做了包装，主要工作在于：</p>
<ol>
<li>启动前配置线程数</li>
<li>生成主Goroutine并投递进运行时</li>
<li>使用<code>channel</code>实现主Goroutine与主线程通信，主线程监控其退出</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[proc_macro_attribute]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="n">attr</span>: <span class="nc">TokenStream</span><span class="p">,</span><span class="w"> </span><span class="n">item</span>: <span class="nc">TokenStream</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TokenStream</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">args</span>: <span class="nc">AttributeArgs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">syn</span>::<span class="n">parse_macro_input</span><span class="o">!</span><span class="p">(</span><span class="n">attr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">AttributeArgs</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">next</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">thread_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">meta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">NestedMeta</span>::<span class="n">Meta</span><span class="p">(</span><span class="n">meta</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">meta</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;invalid attrs&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">Meta</span>::<span class="n">NameValue</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">meta</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">v</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;invalid attrs&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">seg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">segments</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">next</span><span class="p">().</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;invalid attrs&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">ident</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seg</span><span class="p">.</span><span class="n">ident</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">ident</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s">&#34;thread_num&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;invalid attrs&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">Lit</span>::<span class="n">Int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">lit</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">n</span><span class="p">.</span><span class="n">base10_parse</span>::<span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;invalid attrs&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;thread_num must be at least 1&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">n</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="mi">2</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">syn</span>::<span class="n">parse_macro_input</span><span class="o">!</span><span class="p">(</span><span class="n">item</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">syn</span>::<span class="n">ItemFn</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">input</span><span class="p">.</span><span class="n">sig</span><span class="p">.</span><span class="n">output</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">input</span><span class="p">.</span><span class="n">sig</span><span class="p">.</span><span class="n">ident</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">input</span><span class="p">.</span><span class="n">block</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">input</span><span class="p">.</span><span class="n">attrs</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s">&#34;main&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;only the main function can be tagged with #[goroutine_rs::main]&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">quote</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="err">#</span><span class="n">ret</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// 设置线程池大小
</span><span class="c1"></span><span class="w">            </span>::<span class="n">goroutine_rs</span>::<span class="n">set_thread_num</span><span class="p">(</span><span class="err">#</span><span class="n">thread_num</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="c1">// 主goroutine函数
</span><span class="c1"></span><span class="w">            </span><span class="err">#</span><span class="p">(</span><span class="err">#</span><span class="n">attrs</span><span class="p">)</span><span class="o">*</span><span class="w">
</span><span class="w">            </span><span class="k">fn</span> <span class="nf">go_main</span><span class="p">()</span><span class="w"> </span><span class="err">#</span><span class="n">ret</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="err">#</span><span class="n">body</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>::<span class="n">std</span>::<span class="n">sync</span>::<span class="n">mpsc</span>::<span class="n">channel</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="c1">// 把主goroutine函数作为一个goroutine运行
</span><span class="c1"></span><span class="w">            </span>::<span class="n">goroutine_rs</span>::<span class="n">RT</span><span class="p">.</span><span class="n">go</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">go_main</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="n">tx</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">r</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">                </span>::<span class="n">goroutine_rs</span>::<span class="n">RT</span><span class="p">.</span><span class="n">shutdown</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="p">});</span><span class="w">
</span><span class="w">            </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span>::<span class="n">std</span>::<span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span>::<span class="n">std</span>::<span class="n">time</span>::<span class="n">Duration</span>::<span class="n">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span><span class="w">
</span><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rx</span><span class="p">.</span><span class="n">try_recv</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="c1">// 主goroutine退出
</span><span class="c1"></span><span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w">
</span><span class="w">                </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">into</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在启动时就可以像这样来运行main函数了：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[goroutine_rs::main(thread_num = 2)]</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>尝试运行个样例：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[goroutine_rs::main(thread_num = 1)]</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mpsc</span>::<span class="n">channel</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">RT</span><span class="p">.</span><span class="n">go</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;goroutine 1&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tx</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">sched</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">});</span><span class="w">
</span><span class="w">	</span><span class="n">RT</span><span class="p">.</span><span class="n">go</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;goroutine 2&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">sched</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">});</span><span class="w">
</span><span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rx</span><span class="p">.</span><span class="n">try_recv</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;msg from goroutine 1: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">sched</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><pre><code class="language-none" data-lang="none">...
goroutine 1
goroutine 2
msg from goroutine 1: 1
goroutine 1
goroutine 2
msg from goroutine 1: 1
goroutine 1
goroutine 2
msg from goroutine 1: 1
goroutine 1
goroutine 2
msg from goroutine 1: 1
goroutine 1
goroutine 2
msg from goroutine 1: 1
...
</code></pre><p>可以看到3个Goroutine（main函数本身就是个G）会交替执行，并且Goroutine之间可以使用<code>channel</code>来通信。</p>
<h2 id="关于抢占式调度">关于抢占式调度</h2>
<p>目前Go1.14中实现了一个基于信号的异步抢占式调度器，之前的各种实现其实都是伪抢占式，通过编译器或各种IO调用插入调度代码，
来实现看似不需要用户主动调用<code>sched</code>方法。</p>
<p>不过在信号发生时如何保存之前的上下文却是个问题，这里先要从操作系统内核调度线程开始理。</p>
<p>当一个线程正处于运行状态，操作系统内核如果要执行抢占，必须先获取到CPU的使用权，而这一步是由中断来实现的。
中断可以打断CPU的执行指令流，强制跳转至中断处理程序，当内核在执行抢占时，需要将目前的寄存器状态保存起来，而保存的位置是在内核栈中。
然后从下一个需要运行的线程内核栈中恢复上次保存的寄存器状态信息，完成线程的抢占操作。</p>
<p>信号发生时其实并不会马上去执行信号处理函数，而是设置进程的信号位。当进程被重新调度时，内核会检查其信号位，
并从信号处理函数表中查找到注册的信号处理函数，然后在用户栈上分配信号处理函数的函数栈（如果为信号处理函数配置了独立的栈空间，
则会在这个独立的栈空间中执行信号处理函数），跳转到信号处理函数开始处理信号。信号处理完成后，再回到内核态，恢复之前的上下文并开始执行原来的指令。</p>
<p>需要注意的是，信号处理函数的第三个参数<code>ucontext_t</code>并不是之前的上下文，至少是不完整的，不能直接将其保存起来。可以看下几篇相关的文章：</p>
<ol>
<li><a href="https://willnewton.name/2014/03/27/setcontext-and-signal-handlers/">setcontext and signal handlers</a></li>
<li><a href="http://zwillow.blogspot.com/2007/04/linux-signal-handling-is-broken.html">Linux signal handling is broken</a></li>
<li><a href="https://bugzilla.redhat.com/show_bug.cgi?id=170248">Calling setcontext with the ucontext_t supplied to a SA_SIGINFO signal handler segfaults</a></li>
</ol>
<p>随后我在glibc的<a href="https://code.woboq.org/userspace/glibc/debug/segfault.c.html">segfault.c</a>中寻找相关线索：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* This function is called when a segmentation fault is caught.  The system
</span><span class="cm">   is in an unstable state now.  This means especially that malloc() might
</span><span class="cm">   not work anymore.  */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">catch_segfault</span> <span class="p">(</span><span class="kt">int</span> <span class="n">signal</span><span class="p">,</span> <span class="n">SIGCONTEXT</span> <span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">**</span><span class="n">arr</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sigaction</span> <span class="n">sa</span><span class="p">;</span>
  <span class="n">uintptr_t</span> <span class="n">pc</span><span class="p">;</span>
  <span class="cm">/* This is the name of the file we are writing to.  If none is given
</span><span class="cm">     or we cannot write to this file write to stderr.  */</span>
  <span class="n">fd</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fname</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">O_TRUNC</span> <span class="o">|</span> <span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">O_CREAT</span><span class="p">,</span> <span class="mo">0666</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">fd</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="n">WRITE_STRING</span> <span class="p">(</span><span class="s">&#34;*** &#34;</span><span class="p">);</span>
  <span class="n">write_strsignal</span> <span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">signal</span><span class="p">);</span>
  <span class="n">WRITE_STRING</span> <span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="cp">#ifdef REGISTER_DUMP
</span><span class="cp"></span>  <span class="n">REGISTER_DUMP</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="cp"></span>  <span class="n">WRITE_STRING</span> <span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">Backtrace:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
  <span class="cm">/* Get the backtrace.  */</span>

  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>其中<code>SIGCONTEXT</code>和<code>REGISTER_DUMP</code>2个宏分别定义在<a href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/x86_64/sigcontextinfo.h.html">sigcontextinfo.h</a>
和<a href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/x86_64/register-dump.h.html">register-dump.h</a>中。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span>
<span class="nf">register_dump</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">ucontext_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">regs</span><span class="p">[</span><span class="mi">25</span><span class="p">][</span><span class="mi">16</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">fpregs</span><span class="p">[</span><span class="mi">30</span><span class="p">][</span><span class="mi">8</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">xmmregs</span><span class="p">[</span><span class="mi">16</span><span class="p">][</span><span class="mi">32</span><span class="p">];</span>
  <span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span><span class="p">[</span><span class="mi">147</span><span class="p">];</span>
  <span class="n">size_t</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="cp">#define ADD_STRING(str) \
</span><span class="cp">  iov[nr].iov_base = (char *) str;                                              \
</span><span class="cp">  iov[nr].iov_len = strlen (str);                                              \
</span><span class="cp">  ++nr
</span><span class="cp">#define ADD_MEM(str, len) \
</span><span class="cp">  iov[nr].iov_base = str;                                                      \
</span><span class="cp">  iov[nr].iov_len = len;                                                      \
</span><span class="cp">  ++nr
</span><span class="cp"></span>  <span class="cm">/* Generate strings of register contents.  */</span>
  <span class="n">hexvalue</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">uc_mcontext</span><span class="p">.</span><span class="n">gregs</span><span class="p">[</span><span class="n">REG_RAX</span><span class="p">],</span> <span class="n">regs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">16</span><span class="p">);</span>
  <span class="n">hexvalue</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">uc_mcontext</span><span class="p">.</span><span class="n">gregs</span><span class="p">[</span><span class="n">REG_RBX</span><span class="p">],</span> <span class="n">regs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">16</span><span class="p">);</span>

  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>发现<code>register_dump</code>函数还是直接使用了<code>ucontext_t</code>，并且我怀疑dump出来的寄存器信息同样是不完整的。</p>
<p>那Go1.14的信号抢占又是如何实现的呢？我翻阅了几个Proposal，其中3个我认为是关键的：</p>
<ol>
<li><a href="https://github.com/golang/proposal/blob/master/design/24543/safe-points-everywhere.md">Proposal: Safe-points everywhere for non-cooperative goroutine preemption</a></li>
<li><a href="https://github.com/golang/proposal/blob/master/design/24543/conservative-inner-frame.md">Proposal: Conservative inner-frame scanning for non-cooperative goroutine preemption</a></li>
<li><a href="https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md">Proposal: Non-cooperative goroutine preemption</a></li>
</ol>
<p>在第1个Proposal中，作者写到：</p>
<blockquote>
<p>I propose that we implement fully non-cooperative preemption by recording enough metadata to allow safe-points (almost) everywhere.</p>
<p>To do this, we would modify the compiler to produce register maps in addition to stack maps,
and to emit these for as many program counters as possible.
The runtime would use a signal (or GetThreadContext on Windows, or a note on Plan9) to retrieve each thread&rsquo;s register state,
from which it could get the stack and register map for the interrupted PC.
The garbage collector would then treat live pointers in registers just as it treats live pointers on the stack.</p>
</blockquote>
<p>也就是说Go的编译器在尽可能多的指令后保存了寄存器的状态信息，此举为在信号处理函数中获取线程寄存器状态提供了支持。</p>
<p>不仅如此，该Proposal也为调用注入（<code>Call injection</code>）提供了支持，调用注入可以在信号处理和调试器方法调用方面提供极大的便利
（因为之前的寄存器状态不会被污染）。</p>
<p>比如在信号处理函数退出后，需要在原来的指令前插入执行一些指令。可以看一个例子，在异步抢占中非常关键的一个函数：<code>asyncPreempt</code>，
这个函数由不同平台的汇编实现，<a href="https://github.com/golang/go/blob/master/src/runtime/preempt_amd64.s">这里是amd64平台实现</a>。
而它需要在信号处理函数中注入到之前的指令前，相当于在原来的指令地址调用它，实现注入的方式就是把原来的指令地址压入栈中，然后修改IP寄存器，
其实也就是手动完成<code>call</code>指令。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">sigctxt</span><span class="p">)</span> <span class="nf">pushCall</span><span class="p">(</span><span class="nx">targetPC</span><span class="p">,</span> <span class="nx">resumePC</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Make it look like we called target at resumePC.
</span><span class="c1"></span>	<span class="nx">sp</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">rsp</span><span class="p">())</span>
	<span class="nx">sp</span> <span class="o">-=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span> <span class="p">=</span> <span class="nx">resumePC</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">set_rsp</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">set_rip</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">targetPC</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>在异常处理和调试器中调用方法都依赖于调用注入的支持，而它们又都是建立在
<a href="https://github.com/golang/proposal/blob/master/design/24543/safe-points-everywhere.md">Proposal 1</a>
的实现之上。</p>
<p>不过遗憾的是，这样的特性只能由编译器来实现。</p>
<p>另外在<code>tokio</code>中看到一个比较有意思的类似任务抢占的调度策略，这个调度策略在<code>tokio 0.2.14</code>版本中添加进来。</p>
<p>Rust中的异步模型是基于Future的，当一个Future处于执行状态时，只要它的IO资源一直处于就绪状态，那它将会一直执行下去而不会被重新调度。
从总吞吐量的角度看，这其实也是合理的策略，毕竟CPU一直处于负载状态，如果来回切换Future，反而会产生额外的开销。
可是在某些特殊情况下，这就会带来非常大的Future饥饿问题（或者叫负载不均衡），同一个Future一直占有CPU资源，其他Future就没有执行的机会了。</p>
<p>尽管tokio中有<code>yield_now</code>方法用于强制调度，不过这必须由用户显式调用，大多数场景下都不会直接使用，毕竟每次都切换Future也不是我们期望的。</p>
<p>其实这个问题是被关联发现的，<a href="https://github.com/denoland/deno">Deno</a>的作者<a href="https://github.com/ry">Ryan Dahl</a>使用tokio作为Deno的底层运行时，
他在使用<a href="https://github.com/hyperium/hyper">Hyper</a>做测试时，发现了非常高的尾延迟（tail latencies），导致这些尾延迟的原因就是前面所说的那种情况
（IO资源一直处于就绪状态）。</p>
<p>而Hyper在<a href="https://github.com/hyperium/hyper/pull/1829">PR #1829</a>中通过强制调度那些IO资源一直处于就绪状态的连接来解决这个尾延迟问题。
而同样的问题其实在Node.js中也被解决过，Node.js为每个IO资源设定了限制，当达到限制后将会被强制调度。</p>
<p>Hyper虽然解决了这个问题，但其实经过仔细想，这个问题由异步运行时来解决会更有价值，这样所有在这个运行时上的Future都可以利用到这种策略的优势。</p>
<p>因此tokio为每个Future引入操作预算（<code>operation budget</code>），每次异步操作（调用<code>.await</code>）时，都会减少操作预算，当操作预算为0时，无论IO资源是否就绪，
都会强制返回Pending，而这会使当前Future被调度，此时Future的操作预算会被重置。</p>
<p>当然这样的策略并不能算是真正的抢占，其一在于Future消耗的资源计算仅限于IO，没有计算其CPU资源消耗，其二是调度点只能处于<code>.await</code>处，
无法在Future正常运行过程中打断。</p>
<h2 id="小结">小结</h2>
<p>虽然到最后还是没有找到可以在用户空间实现异步抢占的方法（不依赖于编译器实现的情况下），不过还是找到了一些有价值的思路，
之后会再尝试寻找其他的解决办法。</p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="https://cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/final-200-lines-of-code">Green Threads Explained in 200 Lines of Rust</a></li>
<li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E5%99%A8">Go 语言调度器与 Goroutine 实现原理 | Go 语言设计与实现</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/77598393">Linux中的信号处理机制</a></li>
<li><a href="https://changkun.de/golang/zh-cn/part2runtime/ch06sched/preemption/">协作与抢占</a></li>
<li><a href="https://github.com/golang/proposal/blob/master/design/24543/safe-points-everywhere.md">Proposal: Safe-points everywhere for non-cooperative goroutine preemption</a></li>
<li><a href="https://github.com/golang/proposal/blob/master/design/24543/conservative-inner-frame.md">Proposal: Conservative inner-frame scanning for non-cooperative goroutine preemption</a></li>
<li><a href="https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md">Proposal: Non-cooperative goroutine preemption</a></li>
<li><a href="https://code.woboq.org/userspace/glibc/debug/segfault.c.html">glibc/debug/segfault.c</a></li>
<li><a href="https://deploy-preview-422--tokio.netlify.app/blog/2020-04-preemption/">Reducing tail latencies with automatic cooperative task yielding</a></li>
</ol>]]></content>
		</item>
		
		<item>
			<title>Rust中的多态 - Trait Object</title>
			<link>https://xiaopengli89.github.io/posts/rust-trait-object/</link>
			<pubDate>Mon, 27 Jul 2020 17:49:22 +0800</pubDate>
			
			<guid>https://xiaopengli89.github.io/posts/rust-trait-object/</guid>
			<description>&lt;p&gt;Rust是一门静态类型语言，变量的类型一旦确定就不能更改。如果使用一个容器，则容器内部数据类型也必须完全一致，这会少一些灵活性。Rust中的 &lt;code&gt;Trait&lt;/code&gt; 不但可以用作范型约束（&lt;code&gt;Trait Bounds&lt;/code&gt;），也可以单独使用，我们叫 &lt;code&gt;Trait Object&lt;/code&gt;，用它可以间接地实现动态类型。&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>Rust是一门静态类型语言，变量的类型一旦确定就不能更改。如果使用一个容器，则容器内部数据类型也必须完全一致，这会少一些灵活性。Rust中的 <code>Trait</code> 不但可以用作范型约束（<code>Trait Bounds</code>），也可以单独使用，我们叫 <code>Trait Object</code>，用它可以间接地实现动态类型。</p>
<h2 id="动态大小类型dst">动态大小类型（DST）</h2>
<p>在Rust的内存布局模型中，一般每个类型都有唯一确定的类型大小，很多情况下类型默认由编译器实现了 <code>Sized</code>。但是Rust中也存在类型大小不确定的情况，比较典型的有：</p>
<ol>
<li>切片（<code>slice</code>)</li>
<li>最后一个字段大小不确定的结构体</li>
<li><code>Trait Object</code></li>
</ol>
<p>这3种情况下，类型大小将不确定，我们将这些类型叫做动态大小类型（DST）。由于DST的类型大小无法确定，因此无法在栈上直接分配内存空间，变量必须通过指针间接引用。</p>
<p>切片是数组的部分连续引用，由头指针和长度构成。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Slice</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">head</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">size</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><pre><code class="language-none" data-lang="none">0: E     &lt;-- head: 2
1: E     |   size: 4
2: E &lt;----
3: E     |
4: E     |
5: E &lt;----
6: E
7: E
</code></pre><p>切片由 <code>Range</code> 运算符和中括号构造，利用 <code>Range</code> 中的 <code>starting_index</code> 和 <code>ending_index</code> 确定头指针和长度信息：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">sli</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">..</span><span class="o">=</span><span class="mi">3</span><span class="p">];</span><span class="w">
</span></code></pre></div><p>自定义DST结构体的话，只需要在结构中内嵌唯一一个DST类型，并且是在最后一个字段，而目前唯一能构造这种结构体的方式是通过范型：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Foo</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">f1</span>: <span class="kt">bool</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">f2</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">f3</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">foo</span>: <span class="kp">&amp;</span><span class="nc">Foo</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">i32</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Foo</span>::<span class="o">&lt;</span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">f1</span>: <span class="nc">false</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">f2</span>: <span class="mi">1</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">f3</span>: <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span><span class="w">
</span><span class="w"></span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Foo</span>::<span class="o">&lt;</span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">f1</span>: <span class="nc">false</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">f2</span>: <span class="mi">1</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">f3</span>: <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">],</span><span class="w">
</span><span class="w"></span><span class="p">};</span><span class="w">
</span></code></pre></div><p><code>Trait Object</code> 则是实现了固定 <code>Trait</code> 集合的不同类型的实例，并且通过胖指针隐藏了具体的类型和方法实现信息。通过 <code>Trait Object</code> 可以实现动态地修改变量类型，动态地调用不同方法实现（动态分发），即其他编程语言里的多态性。</p>
<h2 id="trait-object-的实现"><code>Trait Object</code> 的实现</h2>
<p>为了实现不同的类型能被一个变量或容器持有，<code>Trait Object</code> 内部本身只有 <code>data</code> 和 <code>vtable</code> 字段构成，并且2个字段都是指针，直接类型大小其实也是确定的。其中 <code>data</code> 指向具体的类型实例，而 <code>vtable</code> 则是指向实现了 <code>Trait</code> 的方法集合：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">TraitObject</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">data</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">vtable</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="p">(),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>由于 <code>Trait Object</code> 属于DST的一种，因此构造时必须通过指针间接引用，并且需要在 <code>Trait</code> 前附加 <code>dyn</code> 关键字，通常可以由 <code>&amp;dyn SomeTrait</code> 或 <code>Box&lt;dyn SomeTrait&gt;</code> 2种方式来构造：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foo1</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foo2</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo1</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo2</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">bar</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Foo1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Foo2</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>可以构造一个 <code>Trait Object</code> 实例查看内部的数据构成：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">f1</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">f2</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foo</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">f1</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">f2</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;foo&#39;s address = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">foo</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Foo::f1 = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span>::<span class="n">f1</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Foo::f2 = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span>::<span class="n">f2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">bar</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">foo</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">vtable</span><span class="p">)</span>: <span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">mem</span>::<span class="n">transmute</span><span class="p">(</span><span class="n">bar</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;data = {}, vtable = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">vtable</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">vtable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vtable</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;[{}, {}, {}, {}, {}]&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="o">*</span><span class="n">vtable</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="o">*</span><span class="n">vtable</span><span class="p">.</span><span class="n">offset</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w">
</span><span class="w">		</span><span class="o">*</span><span class="n">vtable</span><span class="p">.</span><span class="n">offset</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w">
</span><span class="w">		</span><span class="o">*</span><span class="n">vtable</span><span class="p">.</span><span class="n">offset</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="w">
</span><span class="w">		</span><span class="o">*</span><span class="n">vtable</span><span class="p">.</span><span class="n">offset</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span><span class="w">
</span><span class="w">	</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>打印出的结果：</p>
<pre><code class="language-none" data-lang="none">foo's address = 140729104675248
Foo::f1 = 94428356803312
Foo::f2 = 94428356803328
data = 140729104675248, vtable = 94428357017888
[94428356801504, 0, 1, 94428356803312, 94428356803328]
</code></pre><p>可以看到变量 <code>foo</code> 的内存地址就是 <code>data</code> 的值，而 <code>Foo::f1</code> 和 <code>Foo::f2</code> 方法的地址分别出现在 <code>vtable</code> 的第3和第4个位置上，这样程序运行期间就可以动态确定对象和需要调用的方法了。</p>
<p><strong>NOTE:</strong> <code>vtable</code> 的第0个位置保存的是对象的析构方法地址，第1个位置保存的是对象的类型大小（这里因为样例的 <code>Foo</code> 结构为空，所以等于0），第2个位置保存的是对象的内存对齐大小（由于 <code>Foo</code> 结构的类型大小为0，所以对齐大小为1字节）。<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<h2 id="限制">限制</h2>
<p>虽然 <code>Trait Object</code> 具有范型不具备的灵活性，并且某些情况下甚至不得不通过它来实现（比如异步运行时中需要保存 <code>Future</code> 对象），但 <code>Trait Object</code> 在使用上还有些局限性，一些特性不能运用在它上面。</p>
<ol>
<li>只能绑定一个 <code>Trait</code>， 除了 <a href="https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits">auto traits</a> 和 <a href="https://doc.rust-lang.org/reference/items/traits.html#supertraits">supertraits</a> 外，不能附加其他 <code>Trait</code>，比如不能如下定义一个 <code>Trait Object</code>：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">type</span> <span class="nc">SomeType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">TraitA</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">TraitB</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></div><ol start="2">
<li>无法定义范型方法（<code>object safe</code> <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> 条件之一）：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">say</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">p</span>: <span class="nc">T</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foo</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">say</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">p</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">bar</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Foo</span><span class="p">);</span><span class="w"> </span><span class="c1">// 无法编译通过
</span></code></pre></div><ol start="3">
<li>除 <code>receiver</code> 外的 <code>Self</code> 类型声明（<code>object safe</code> <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> 条件之一）：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">say</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foo</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">say</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">bar</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Foo</span><span class="p">);</span><span class="w"> </span><span class="c1">// 无法编译通过
</span></code></pre></div><ol start="4">
<li>无法定义关联函数（<code>Associated Functions</code>）（<code>object safe</code> <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> 条件之一）：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">hello</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foo</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">hello</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">bar</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Foo</span><span class="p">);</span><span class="w"> </span><span class="c1">// 无法编译通过
</span></code></pre></div><ol start="5">
<li>只能定义一个生命周期：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">type</span> <span class="nc">SomeType</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="na">&#39;b</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">TraitA</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="na">&#39;a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="na">&#39;b</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 无法编译通过
</span></code></pre></div><ol start="6">
<li><code>Trait</code> 本身不能附加 <code>Self: Sized</code> 约束（<code>object safe</code> <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> 条件之一）：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Self</span>: <span class="nb">Sized</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foo</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">bar</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Foo</span><span class="p">);</span><span class="w"> </span><span class="c1">// 无法编译通过
</span></code></pre></div><ol start="7">
<li>不能定义关联常量（<code>object safe</code> <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> 条件之一）：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">ID</span>: <span class="kt">u32</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foo</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">ID</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">bar</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Foo</span><span class="p">);</span><span class="w"> </span><span class="c1">// 无法编译通过
</span></code></pre></div><ol start="8">
<li>不允许 <code>opt-out bounds</code>：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">type</span> <span class="nc">SomeType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">TraitA</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 无法编译通过
</span></code></pre></div><h2 id="通过-self-sized-约束将特定方法排除在-vtable-外">通过 <code>Self: Sized</code> 约束将特定方法排除在 <code>vtable</code> 外</h2>
<p>有时候我们希望把某些不具备 <code>object-safe</code> 条件的方法排除在 <code>vtable</code> 外，比如范型方法、除了 <code>receiver</code> 外的 <code>Self</code> 类型声明、关联函数，相当于生成一个具备 <code>object-safe</code> 的子集。这时候只需要在方法上附加 <code>where Self: Sized</code> 约束即可：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">say</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">hello</span><span class="p">()</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">set</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foo</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">say</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">set</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">bar</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Foo</span><span class="p">);</span><span class="w"> </span><span class="c1">// 编译通过
</span></code></pre></div><p>之所以能通过这种方式来标记，是因为 <a href="https://doc.rust-lang.org/reference/special-types-and-traits.html#sized"><code>implementation items</code> 默认不会被编译器实现 <code>Sized</code></a>。当然这些被排除的方法在 <code>Trait Object</code> 上也无法调用。</p>
<h2 id="trait-object-的生命周期推导"><code>Trait Object</code> 的生命周期推导</h2>
<p>由于 <code>Trait Object</code> 内可能包含引用，因此也需要在定义时描述其生命周期，不过大多数时候编译器都能在上下文中推断出所需的生命周期，规则如下<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>：</p>
<blockquote>
<p>如果一个trait对象作为一个类型参数传递到泛型中，那么它的生命约束会从它包含的类型中推断</p>
<ol>
<li>如果包含的类型中有唯一的约束，那么就使用这个约束。</li>
<li>如果包含的类型中有超过一个约束，那么必须显式指定约束。</li>
</ol>
<p>如果以上都不适用，那么：</p>
<ol>
<li>如果trait是以单个生命周期约束定义的，那么就使用这个约束</li>
<li>如果所有生命周期约束都是 &lsquo;static 的，那么就使用 &lsquo;static 作为约束</li>
<li>如果trait没有生命周期约束，那么它的生命周期将会从表达式中推断，如果不在表达式中，那么就是 &lsquo;static 的</li>
</ol>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// For the following trait...
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// These two are the same as Box&lt;T&gt; has no lifetime bound on T
</span><span class="c1"></span><span class="k">type</span> <span class="nc">T1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">type</span> <span class="nc">T2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// ...and so are these:
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// ...so are these, because &amp;&#39;a T requires T: &#39;a
</span><span class="c1"></span><span class="k">type</span> <span class="nc">T3</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">type</span> <span class="nc">T4</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="na">&#39;a</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// std::cell::Ref&lt;&#39;a, T&gt; also requires T: &#39;a, so these are the same
</span><span class="c1"></span><span class="k">type</span> <span class="nc">T5</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="n">Ref</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">type</span> <span class="nc">T6</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="n">Ref</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// This is an example of an error.
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">TwoBounds</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="na">&#39;b</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="na">&#39;a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="na">&#39;b</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">f1</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">f2</span>: <span class="kp">&amp;</span><span class="na">&#39;b</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">f3</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">type</span> <span class="nc">T7</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="na">&#39;b</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TwoBounds</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="na">&#39;b</span><span class="p">,</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="c1">//                                  ^^^^^^^
</span><span class="c1">// Error: the lifetime bound for this object type cannot be deduced from context
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// For the following trait...
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="n">Bar</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span>: <span class="na">&#39;a</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// ...these two are the same:
</span><span class="c1"></span><span class="k">type</span> <span class="nc">T1</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">type</span> <span class="nc">T2</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// ...and so are these:
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="na">&#39;a</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><h2 id="与范型相比有什么优劣">与范型相比有什么优劣</h2>
<p>范型会在编译期间展开成具体的类型以及方法，因此可以在编译期间确定对象的类型内存布局、方法地址，这属于静态分发；而 <code>Trait Object</code> 是在程序运行期间通过指针间接确定具体对象的类型内存布局和方法地址，这属于动态分发。</p>
<p>优势：</p>
<ol>
<li>能实现多态，动态地修改类型和调用方法，实现动态容器。</li>
<li>没有代码膨胀问题，范型由于每个类型和方法都需要独立展开，而 <code>Trait Object</code> 不需要这么做，因此可以生成更小的代码尺寸。</li>
</ol>
<p>劣势：</p>
<ol>
<li>上面提到的各种限制。</li>
<li>由于动态分发需要在程序运行期间通过指针间接访问数据和调用方法，有一定的性能开销。</li>
</ol>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>空元组（<code>()</code>）和零尺寸类型的类型大小为0，内存对齐大小为1。- <a href="https://doc.rust-lang.org/reference/type-layout.html#tuple-layout">Type Layout</a> <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>即对象安全。- <a href="https://doc.rust-lang.org/reference/items/traits.html#object-safety">Object Safety</a> <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p><a href="https://doc.rust-lang.org/reference/lifetime-elision.html#default-trait-object-lifetimes">Default trait object lifetimes</a> 和 <a href="https://github.com/whfuyn/rust-blog/blob/master/posts/Rust%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%B8%B8%E8%A7%81%E8%AF%AF%E8%A7%A3.md#6-%E8%A3%85%E7%AE%B1%E7%9A%84trait%E5%AF%B9%E8%B1%A1%E6%B2%A1%E6%9C%89%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Rust生命周期的常见误解</a> <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>]]></content>
		</item>
		
		<item>
			<title>Rust中的生命周期及变性</title>
			<link>https://xiaopengli89.github.io/posts/rust-lifetime-variance/</link>
			<pubDate>Fri, 24 Jul 2020 15:03:06 +0800</pubDate>
			
			<guid>https://xiaopengli89.github.io/posts/rust-lifetime-variance/</guid>
			<description>生命周期简介 Rust中没有垃圾收集器（Garbage Collection），而是通过编译器静态分析变量的生命周期（lifetime）以及一套</description>
			<content type="html"><![CDATA[<h2 id="生命周期简介">生命周期简介</h2>
<p>Rust中没有垃圾收集器（<code>Garbage Collection</code>），而是通过编译器静态分析变量的生命周期（<code>lifetime</code>）以及一套自己的规则来实现内存安全。</p>
<p>比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">a</span>: <span class="kp">&amp;</span><span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>以上代码对生命周期展开后：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="na">&#39;life_a</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">a</span>: <span class="kp">&amp;</span><span class="na">&#39;life_a</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="na">&#39;life_b</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">		</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;life_b</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w">	</span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>由于 <code>life_a</code> 的生命周期大于 <code>life_b</code> ，变量 <code>b</code> 被析构后，变量a将不能再持有变量b的引用，因此无法编译通过：</p>
<pre><code class="language-none" data-lang="none">error[E0597]: `b` does not live long enough
 --&gt; src/lib.rs:5:13
  |
5 |         a = &amp;b;
  |             ^^ borrowed value does not live long enough
6 |     }
  |     - `b` dropped here while still borrowed
7 |     println!(&quot;{}&quot;, a);
  |                    - borrow later used here
</code></pre><h2 id="生命周期的变性">生命周期的变性</h2>
<p>在Rust里没有OOP中的继承，因此变性在Rust中特指生命周期的变换规则。</p>
<p>如果将上面的代码反过来：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">b</span>: <span class="kp">&amp;</span><span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>展开后：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="na">&#39;life_a</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="na">&#39;life_b</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="kd">let</span><span class="w"> </span><span class="n">b</span>: <span class="kp">&amp;</span><span class="na">&#39;life_b</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w">		</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;life_b</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>由于变量 <code>a</code> 具有 <code>'life_a</code> 的生命周期，如果用更范型的写法描述变量 <code>a</code> 的类型，那应该是 <code>a: T where T: 'life_a</code> 。那 <code>&amp;'life_b T: 'life_a</code> ，当 <code>'life_a</code> 大于 <code>'life_b</code>（记作 <code>'life_a: 'life_b</code>）时，将是安全的。</p>
<p>两个生命周期类型，如果存在 <code>'a: 'b</code> 关系，则称类型 <code>'a</code> 是类型 <code>'b</code> 的子类型，称类型 <code>'b</code> 是类型 <code>'a</code> 的父类型。</p>
<p><strong>NOTE:</strong> 在Rust中，生命周期也是一种类型。</p>
<p>在类型构造的过程中:</p>
<ol>
<li>如果可以由子类型代替父类型，称之为 <code>协变</code>。</li>
<li>如果可以由父类型代替子类型，称之为 <code>逆变</code>。</li>
<li>如果类型不可替换，称之为 <code>不变</code>。</li>
</ol>
<p>对于借用来说，借用本身总是协变的，如有：<code>&amp;'a T</code> 或 <code>&amp;'a mut T</code> ，并且 <code>'b: 'a</code> ，则总可以用 <code>&amp;'b T</code> / <code>&amp;'b mut T</code> 的类型代替 <code>&amp;'a T</code> / <code>&amp;'a mut T</code>，但对于 <code>T</code> 却有其他要求：</p>
<ol>
<li>如果是不可变借用或不可变裸指针，由于 <code>T</code> 是只读的, 因此 <code>T</code> 是协变的。</li>
<li>如果是可变借用或可变裸指针，由于可以修改 <code>T</code> ，因此 <code>T</code> 是不变的，否则将可能将子类型的数据修改为父类型造成悬垂引用/指针：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Foo</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">a</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">d</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="n">a</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="p">};</span><span class="w">
</span><span class="w">	</span><span class="n">f</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>以上代码将不会编译通过，因为可能通过 <code>f.a</code> 修改变量 <code>c</code>。以及以下例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">write_a</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span>: <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;foo&#34;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;bar&#34;</span><span class="p">.</span><span class="n">to_owned</span><span class="p">();</span><span class="w">
</span><span class="w">	</span><span class="n">write_a</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">as_str</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>函数 <code>write_a</code> 调用时类型 <code>T</code> 是 <code>&amp;'life_b str</code> ，如果第一个参数 <code>&amp;mut &amp;'static str</code> 协变为 <code>&amp;mut &amp;'life_b str</code>，则可能会将 <code>&amp;'static str</code> 的数据修改为 <code>&amp;'life_b str</code>，造成悬垂指针。</p>
<p>而对于函数 <code>fn(T) -&gt; U</code> ，对于 <code>T</code> 是逆变的，对于 <code>U</code> 是协变的：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">f1</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="na">&#39;b</span>: <span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_p</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="na">&#39;b</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="o">&amp;</span><span class="mi">1</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foo</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="na">&#39;b</span>: <span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">f</span>: <span class="nc">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="na">&#39;b</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">f</span>: <span class="nc">f1</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">};</span><span class="w">
</span></code></pre></div><p>上面的代码可以编译通过。其中对于 <code>T</code> 逆变，是因为变量 <code>foo</code> 的 <code>f</code> 字段需要一个能处理子类型 <code>'b</code> 的函数，而传入了一个能处理父类型 <code>'a</code> 的函数，相当于传入了一个功能更强的函数，因此是安全的；对于 <code>U</code> 协变，<code>f</code> 字段要求的函数需要返回一个父类型，而传入的函数能返回一个子类型，这当然也是安全的。</p>
<p><strong>NOTE:</strong> 其实对于函数定义的逆变，就等价于函数调用时的协变。</p>
<p>对于标准库中的非内部可变性容器（<code>Box&lt;T&gt;</code>, <code>Vec&lt;T&gt;</code>）都是协变的，其实和不可变借用的道理一样，即使内部套了一层 <code>&amp;mut T</code> ，第二层的 <code>T</code> 也会和可变借用的变性规则一样是不变的。</p>
<p>但对于内部可变性容器（<code>UnsafeCell&lt;T&gt;</code>, <code>Cell&lt;T&gt;</code>）都是不变的，这是因为这些容器可以修改不可变借用，就像可变借用一样，因此同可变借用的规则一样是不变的：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Cell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">set</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">val</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> 
</span><span class="w">		</span><span class="c1">// ...
</span><span class="c1"></span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="n">Cell</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="n">foo</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">foo</span><span class="p">.</span><span class="n">get</span><span class="p">());</span><span class="w">
</span></code></pre></div><p>尽管 <code>Cell</code> 的 <code>set</code> 方法中 <code>&amp;self</code> 是不可变借用，它也无法协变到同 <code>&amp;b</code> 的生命周期一致，以上代码无法编译通过：</p>
<pre><code class="language-none" data-lang="none">error[E0597]: `b` does not live long enough
  --&gt; src/lib.rs:8:17
   |
8  |         foo.set(&amp;b);
   |                 ^^ borrowed value does not live long enough
9  |     }
   |     - `b` dropped here while still borrowed
10 |     println!(&quot;{}&quot;, *foo.get());
   |                     --- borrow later used here
</code></pre><h2 id="生命周期的自动推导">生命周期的自动推导</h2>
<p>很多时候并不需要显式地写出每个变量的生命周期，Rust的借用检查器会以一定的规则自动推导出变量的生命周期：<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<blockquote>
<ol>
<li>每个传入的引用都会有一个单独的生命周期</li>
<li>如果只有一个传入的生命周期，那么它将被应用到所有输出的引用上</li>
<li>如果有多个传入的生命周期，但其中一个是&amp;self或者&amp;mut self，那么这个生命周期将会被应用到所有输出的引用上</li>
<li>除此之外的输出的生命周期都必须显示标注出来</li>
</ol>
</blockquote>
<p>可以看出，对于参数自动推导的生命周期适用范围更宽泛，而对于返回值的推导较为保守。但自动推导的生命周期并不一定符合语义，一个非常典型的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">print</span><span class="p">(</span><span class="n">b1</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">],</span><span class="w"> </span><span class="n">b2</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:#?} {:#?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">b1</span><span class="p">,</span><span class="w"> </span><span class="n">b2</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Buffer</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">],</span><span class="w">
</span><span class="w">    </span><span class="n">pos</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Buffer</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">b</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Buffer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Buffer</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">buf</span>: <span class="nc">b</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span>: <span class="mi">0</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">read_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">pos</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">pos</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">3</span><span class="p">..</span><span class="bp">self</span><span class="p">.</span><span class="n">pos</span><span class="p">]</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">];</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Buffer</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">b1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">.</span><span class="n">read_bytes</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">b2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">.</span><span class="n">read_bytes</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="n">print</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span><span class="w"> </span><span class="n">b2</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>以上代码不会编译通过：</p>
<pre><code class="language-none" data-lang="none">error[E0499]: cannot borrow `buf` as mutable more than once at a time
 --&gt; src/lib.rs:5:14
  |
4 |     let b1 = buf.read_bytes();
  |              --- first mutable borrow occurs here
5 |     let b2 = buf.read_bytes();
  |              ^^^ second mutable borrow occurs here
6 |     print(b1, b2);
  |           -- first borrow later used here
</code></pre><p>原因在于 <code>read_bytes</code> 方法根据自动推导规则3，返回值的生命周期将同 <code>&amp;mut self</code> 一致，并且是由 <code>&amp;mut T</code> 降级到 <code>&amp;T</code> ，在返回的引用没有析构前，它将一直持有 <code>&amp;mut self</code> ，导致第二次无法再借用。因此我们需要手动指定返回值的生命周期以符合语义：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// ...
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">read_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="bp">self</span><span class="p">.</span><span class="n">pos</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">pos</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">3</span><span class="p">..</span><span class="bp">self</span><span class="p">.</span><span class="n">pos</span><span class="p">]</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="c1">// ...
</span></code></pre></div><p>这样返回值将不会持有 <code>&amp;mut self</code>，事实上 <code>buf</code>， <code>b1</code>， <code>b2</code> 共同持有了 <code>data</code> 的不可变借用，而这正是我们期望的。</p>
<h2 id="幽灵数据-phantomdata">幽灵数据 <code>PhantomData</code></h2>
<p>裸指针并不会被借用检查器认为具有引用关系，因此如下代码是无法被检测出生命周期错误的：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">val</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">create</span><span class="p">(</span><span class="n">val</span>: <span class="kp">&amp;</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Foo</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">val</span>: <span class="nc">val</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">foo</span>: <span class="nc">Foo</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">a</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">foo</span><span class="p">.</span><span class="n">val</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>而实际上我们希望变量 <code>foo</code> 能在语义上持有 <code>T</code> 的引用，此时可以引入一个幽灵数据 <code>PhantomData</code> 。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">marker</span>::<span class="n">PhantomData</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foo</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">val</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">_maker</span>: <span class="nc">PhantomData</span><span class="o">&lt;&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">create</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">val</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Foo</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">val</span>: <span class="nc">val</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">_maker</span>: <span class="nc">PhantomData</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">foo</span>: <span class="nc">Foo</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">a</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">foo</span><span class="p">.</span><span class="n">val</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>其中 <code>_maker: PhantomData&lt;&amp;'a T&gt;</code> 代表了 <code>Foo</code> 结构语义上持有了 <code>&amp;'a T</code>，但 <code>PhantomData</code> 并不占用空间，仅仅用作借用检查，以上代码可以被检测出生命周期的错误：</p>
<pre><code class="language-none" data-lang="none">error[E0597]: `a` does not live long enough
  --&gt; src/lib.rs:21:22
   |
21 |         foo = create(&amp;a);
   |                      ^^ borrowed value does not live long enough
22 |     }
   |     - `a` dropped here while still borrowed
23 |     unsafe {
24 |         println!(&quot;{}&quot;, *foo.val);
   |                        -------- borrow later used here
</code></pre><h2 id="小结">小结</h2>
<p>在实际编码过程中，还是需要我们开发人员对变量的生命周期作出最符合语义的判断，必要时需要手动指定生命周期以及它们之间的依赖关系。在实现容器类型时，也不可盲目地指定协变，还是需要依据变性的规则作出正确的约束，就像 <code>UnsafeCell&lt;T&gt;</code> 和 <code>Cell&lt;T&gt;</code> 那样。</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>参考自<a href="https://github.com/whfuyn/rust-blog/blob/master/posts/Rust%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%B8%B8%E8%A7%81%E8%AF%AF%E8%A7%A3.md">Rust生命周期的常见误解</a> <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content>
		</item>
		
		<item>
			<title>Rust新的内联汇编语法</title>
			<link>https://xiaopengli89.github.io/posts/rust-asm-macro/</link>
			<pubDate>Wed, 22 Jul 2020 12:58:16 +0800</pubDate>
			
			<guid>https://xiaopengli89.github.io/posts/rust-asm-macro/</guid>
			<description>&lt;p&gt;昨天Rust新的内联汇编语法被合并进主分支 &lt;a href=&#34;https://github.com/rust-lang/rfcs/pull/2873&#34;&gt;Inline assembly #2873&lt;/a&gt; ，旧的内联汇编宏被重新命名为了 &lt;code&gt;llvm_asm!&lt;/code&gt; ,如果使用了旧的内联汇编宏的项目需要做下修改以保持兼容。&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>昨天Rust新的内联汇编语法被合并进主分支 <a href="https://github.com/rust-lang/rfcs/pull/2873">Inline assembly #2873</a> ，旧的内联汇编宏被重新命名为了 <code>llvm_asm!</code> ,如果使用了旧的内联汇编宏的项目需要做下修改以保持兼容。</p>
<p>旧的内联汇编语法仅仅是简单地对 <code>LLVM IR</code> 中的内联汇编做了下包装，新的语法更加友好，并且将 <code>Intel</code> 汇编语法作为默认语法取代之前的 <code>AT&amp;T</code> 汇编语法。</p>
<h2 id="基本用法">基本用法</h2>
<p>目前可以在最新的 <code>nightly</code> 构建版Rust中使用新的内联汇编语法，同时需要开启 <code>#![feature(asm)]</code> ，当然 <code>asm!</code> 宏只能在 <code>unsafe</code> 块中使用：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#![feature(asm)]</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;nop&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>上面执行了一个空操作（<code>NOP</code>），<code>asm!</code> 宏的第一个参数是要被插入的汇编代码模版，可以像Rust中其他模版一样绑定变量，不过有稍许不同：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">a</span>: <span class="kt">i64</span> <span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">b</span>: <span class="kt">i64</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;mov {0}, {1}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">dbg</span><span class="o">!</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w">
</span></code></pre></div><pre><code class="language-none" data-lang="none">[src/main.rs:9] b = 1
</code></pre><p>上面的 <code>out</code> 操作数表示输出，<code>b</code> 为目标变量, <code>reg</code> 寄存器类则是让Rust编译器自动分配一个寄存器，当寄存器的值被更新后会再读取其中的值到变量 <code>b</code> 中（也就是写到变量 <code>b</code> 所在的栈地址）。</p>
<p>可以查看生成的汇编代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="err">#</span> <span class="err">%</span><span class="nl">bb.0:</span>
	<span class="nf">push</span>	<span class="nb">rbx</span>							<span class="err">#</span> <span class="err">保存寄存器</span><span class="nb">rbx</span><span class="err">的值到栈上</span>
	<span class="nf">sub</span>	<span class="nb">rsp</span><span class="p">,</span> <span class="mi">320</span>						<span class="err">#</span> <span class="err">分配栈空间</span>
	<span class="nf">mov</span>	<span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mi">280</span><span class="p">],</span> <span class="mi">1</span>		<span class="err">#</span> <span class="err">初始化变量</span> <span class="nv">a</span> <span class="err">=</span> <span class="mi">1</span>
	<span class="nf">mov</span>	<span class="nb">eax</span><span class="p">,</span> <span class="mi">1</span>							<span class="err">#</span> <span class="err">把变量</span><span class="nv">a的值写入寄存器eax</span>
	<span class="err">#</span><span class="nf">APP</span>
	<span class="nf">mov</span>	<span class="nb">rcx</span><span class="p">,</span> <span class="nb">rax</span>						<span class="err">#</span> <span class="err">把寄存器</span><span class="nb">rax</span><span class="err">的值写入寄存器</span><span class="nb">rcx</span>
	<span class="err">#</span><span class="nf">NO_APP</span>
	<span class="nf">mov</span>	<span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mi">112</span><span class="p">],</span> <span class="nb">rcx</span>		<span class="err">#</span> <span class="err">把寄存器</span><span class="nb">rcx</span><span class="err">的值写入变量</span> <span class="nv">b</span>
</code></pre></div><p>也支持多条汇编模版指令：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">a</span>: <span class="kt">i64</span> <span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">b</span>: <span class="kt">i64</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;mov {0}, {1}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;add {0}, {2}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="n">out</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="k">const</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">dbg</span><span class="o">!</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w">
</span></code></pre></div><pre><code class="language-none" data-lang="none">[src/main.rs:15] b = 6
</code></pre><p><code>in</code> 和 <code>out</code> 操作数也可以同时使用，记作 <code>inout</code> ，它的作用就是读取变量的值到寄存器，操作完后再写回变量中：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">a</span>: <span class="kt">i64</span> <span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">b</span>: <span class="kt">i64</span> <span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;add {0}, {1}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;add {0}, {2}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="n">inout</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="k">const</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">dbg</span><span class="o">!</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w">
</span></code></pre></div><pre><code class="language-none" data-lang="none">[src/main.rs:15] b = 8
</code></pre><div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="err">#</span> <span class="err">%</span><span class="nl">bb.0:</span>
	<span class="nf">push</span>	<span class="nb">rbx</span>
	<span class="nf">sub</span>	<span class="nb">rsp</span><span class="p">,</span> <span class="mi">320</span>
	<span class="nf">mov</span>	<span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mi">280</span><span class="p">],</span> <span class="mi">1</span>		
	<span class="nf">mov</span>	<span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mi">112</span><span class="p">],</span> <span class="mi">2</span>		<span class="err">#</span> <span class="err">初始化变量</span> <span class="nv">b</span> <span class="err">=</span> <span class="mi">2</span>
	<span class="nf">mov</span>	<span class="nb">rax</span><span class="p">,</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mi">112</span><span class="p">]</span>		<span class="err">#</span> <span class="err">读取变量</span><span class="nv">b的值到寄存器rax</span>
	<span class="nf">mov</span>	<span class="nb">ecx</span><span class="p">,</span> <span class="mi">1</span>
	<span class="err">#</span><span class="nf">APP</span>
	<span class="nf">add</span>	<span class="nb">rax</span><span class="p">,</span> <span class="nb">rcx</span>
	<span class="nf">add</span>	<span class="nb">rax</span><span class="p">,</span> <span class="mi">5</span>
	<span class="err">#</span><span class="nf">NO_APP</span>
	<span class="nf">mov</span>	<span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mi">112</span><span class="p">],</span> <span class="nb">rax</span>
</code></pre></div><p><code>inout</code> 操作数也可以将输入和输出指定不同的变量：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">a</span>: <span class="kt">i64</span> <span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">b</span>: <span class="kt">i64</span> <span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">c</span>: <span class="kt">i64</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;add {0}, {1}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;add {0}, {2}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="n">inout</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="k">const</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">dbg</span><span class="o">!</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">dbg</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="p">);</span><span class="w">
</span></code></pre></div><pre><code class="language-none" data-lang="none">[src/main.rs:16] b = 2
[src/main.rs:17] c = 8
</code></pre><p><code>inout(reg) b =&gt; c</code> 表示输入变量 <code>b</code> 的值，输出到变量 <code>c</code> ，可以看到变量 <code>b</code> 的值还是2，而变量 <code>c</code> 的值为8。</p>
<h2 id="延迟输出-lateout">延迟输出 <code>lateout</code></h2>
<p>默认情况下，<code>rustc</code> 对寄存器的分配采取保守策略，即每次输出都会写回到栈上变量或分配独立的寄存器，因为用于输出的寄存器可能会被随时覆盖并得到错误的结果。但是这样会导致寄存器的过多占用，从性能优化考虑，能占用的寄存器越少越好，这样可以为更多的变量分配寄存器，而不用在寄存器和内存两端来回拷贝数据。</p>
<p><code>lateout</code> 操作数则表示延迟输出，不用立即写回到栈上变量，也可能会和其他变量复用同一个寄存器。所以 <code>lateout</code> 只能用在所有的输入都已消费的情况下，防止还未写回的寄存器值被覆盖，或影响其他使用了同一个寄存器的其他变量，比如错误用法：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">b</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">c</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;add {0}, {1}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;add {0}, {2}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="n">inlateout</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>由于变量 <code>a</code>, <code>b</code>, <code>c</code> 具有相同的值，rustc <strong>可能</strong> 会为它们分配同一个寄存器。执行完第一条指令后，变量 <code>c</code> 还没有被消费，但是寄存器已经被第一条指令覆盖了其中的值，此时变量 <code>c</code> 会直接使用寄存器内的值，不是预期的 <code>4</code> ，而是 <code>8</code>，最后也会得到错误的结果 <code>16</code>。</p>
<p><strong>NOTE:</strong> 不过当前的编译器还是为三个变量分配了不同的寄存器，所以以上的结果依然是正确的，但不保证以后也正确。</p>
<p>正确用法：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">b</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;add {0}, {1}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;add {0}, 2&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="n">inlateout</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w">
</span></code></pre></div><p><code>lateout</code> 操作数后没有其他输入了，因此这样使用是正确的。</p>
<h2 id="手动指定寄存器">手动指定寄存器</h2>
<p>某些指令只能操作某些/某个寄存器，比如 <code>out</code> 指令，它只能读取 <code>eax</code> 或其子寄存器。</p>
<p>比如读取变量 <code>cmd</code> 的值到寄存器 <code>eax</code>，然后写入 <code>0x64</code> 端口：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xd1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;out 0x64, eax&#34;</span><span class="p">,</span><span class="w"> </span><span class="k">in</span><span class="p">(</span><span class="s">&#34;eax&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">cmd</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>手动指定的寄存器不能使用模版绑定，同时也必须位于其他自动绑定的操作数末尾。</p>
<p>比如 <code>mul</code> 指令接收一个寄存器的值，然后同 <code>rax</code> 寄存器的值相乘，结果高位写入 <code>rdx</code>，低位写入 <code>rax</code> ：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">mul</span><span class="p">(</span><span class="n">a</span>: <span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">u128</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">lo</span>: <span class="kt">u64</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">hi</span>: <span class="kt">u64</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">            </span><span class="c1">// The x86 mul instruction takes rax as an implicit input and writes
</span><span class="c1"></span><span class="w">            </span><span class="c1">// the 128-bit result of the multiplication to rax:rdx.
</span><span class="c1"></span><span class="w">            </span><span class="s">&#34;mul {}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">inlateout</span><span class="p">(</span><span class="s">&#34;rax&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">lo</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">lateout</span><span class="p">(</span><span class="s">&#34;rdx&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">hi</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="p">((</span><span class="n">hi</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u128</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">lo</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u128</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="忽略寄存器的值">忽略寄存器的值</h2>
<p>某些情况下，修改了寄存器的值，但是我们不关心它的值，或者只临时存在于寄存器中，可以用 <code>_</code> 来忽略它。</p>
<p>比如计算 <code>x</code> 乘以 <code>6</code> ：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Multiply x by 6 using shifts and adds
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">x</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="s">&#34;mov {tmp}, {x}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="s">&#34;shl {tmp}, 1&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="s">&#34;shl {x}, 2&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="s">&#34;add {x}, {tmp}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inout</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>我们将 <code>x</code> 绑定的寄存器的值复制一份到一个临时寄存器中，然后将2个寄存器的值分别左移1位和2位，然后相加结果保存到 <code>x</code> 。这里我们不需要一个栈上变量来保存那个临时的寄存器值，因为它只需要临时存在于寄存器中。</p>
<h2 id="符号操作数">符号操作数</h2>
<p><code>sym</code> 操作数可以绑定一个符号，可以是一个函数或静态变量，可以实现函数调用或访问静态变量：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">arg</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;arg = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">call_foo</span><span class="p">(</span><span class="n">arg</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;call {}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">sym</span><span class="w"> </span><span class="n">foo</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="c1">// 1st argument in rdi, which is caller-saved
</span><span class="c1"></span><span class="w">            </span><span class="n">inout</span><span class="p">(</span><span class="s">&#34;rdi&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="c1">// All caller-saved registers must be marked as clobberred
</span><span class="c1"></span><span class="w">            </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;rax&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;rcx&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;rdx&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;rsi&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;r8&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;r9&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;r10&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;r11&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm0&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm1&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm2&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm3&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm4&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm5&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm6&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm7&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm8&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm9&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm10&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm11&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm12&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm13&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm14&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm15&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>extern &quot;C&quot;</code> 修饰是为了让函数 <code>foo</code> 符合 <code>C</code> 的调用约定，<code>sym foo</code> 会自动绑定 <code>foo</code> 生成的符号，不需要使用 <code>#[no_mangle]</code> 或 <code>pub</code>。</p>
<h2 id="寄存器模版标识">寄存器模版标识</h2>
<p><code>reg</code> 寄存器类会为变量分配完整的寄存器尺寸，比如在 <code>x86-64</code> 体系结构的 <code>rax</code>，<code>x86</code> 体系结构的 <code>eax</code>。<code>reg_abcd</code> 寄存器类可以分配16bit的 <code>ax</code>，<code>bx</code>, <code>cx</code>, <code>dx</code> 寄存器。</p>
<p>而寄存器模版标识可以在模板中再指定子寄存器：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span>: <span class="kt">u16</span> <span class="o">=</span><span class="w"> </span><span class="mh">0x02</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;mov {0:h}, {0:l}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">inout</span><span class="p">(</span><span class="n">reg_abcd</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mh">0x0202</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>生成的汇编代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="err">#</span> <span class="err">%</span><span class="nl">bb.0:</span>
	<span class="nf">sub</span>	<span class="nb">rsp</span><span class="p">,</span> <span class="mi">248</span>
	<span class="nf">mov</span>	<span class="kt">word</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mi">86</span><span class="p">],</span> <span class="mi">2</span>
	<span class="nf">mov</span>	<span class="nb">ax</span><span class="p">,</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mi">86</span><span class="p">]</span>
	<span class="err">#</span><span class="nf">APP</span>
	<span class="nf">mov</span>	<span class="nb">ah</span><span class="p">,</span> <span class="nb">al</span>
	<span class="err">#</span><span class="nf">NO_APP</span>
	<span class="nf">mov</span>	<span class="kt">word</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mi">86</span><span class="p">],</span> <span class="nb">ax</span>
</code></pre></div><p>可以看到 <code>{0:h}</code> 和 <code>{0:l}</code> 分别被替换成了 <code>ah</code> 和 <code>al</code> 2个8bit寄存器。</p>
<h2 id="附加选项">附加选项</h2>
<p>默认情况下，<code>asm!</code> 的代码块会被编译器当作正常的 <code>FFI</code> 函数调用约定，比如会读写内存，可能产生副作用等。不过附加选项可以告诉编译器你的代码在做些什么，方便编译器进行优化。</p>
<p><strong>NOTE:</strong> 附加选项只能作为 <code>asm!</code> 宏的最后一个参数。</p>
<p><code>pure</code> 选项告诉编译器代码块不会产生副作用，它的结果只依赖于输入，比如你不会去读写内存，这样编译器可以优化执行的次数，如果代码块没有输出或只有 <code>_</code> 将导致编译错误。</p>
<p><code>nomem</code> 选项告诉编译器代码块不会读写内存，这样编译器就可以缓存跨 <code>asm!</code> 代码块的寄存器中的值。</p>
<p><code>readonly</code> 选项告诉编译器代码块不会写内存，这样编译器就可以缓存跨 <code>asm!</code> 代码块的未修改过的寄存器中的值。</p>
<p><strong>NOTE:</strong> <code>nomem</code> 和 <code>readonly</code> 不能同时使用，并且 <code>pure</code> 必须同其一一起使用。</p>
<p><code>preserves_flags</code> 选项告诉编译器代码块不会修改标识寄存器，这样 <code>asm!</code> 代码块结束后不需要重新计算标识寄存器的值。</p>
<p><code>noreturn</code> 选项告诉编译器该 <code>asm!</code> 宏永不返回，如果代码中有输出将导致编译错误。</p>
<p><code>nostack</code> 选项告诉编译器代码块不会往栈上push数据或者操作栈的 <code>red zone</code> <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。</p>
<p><code>att_syntax</code> 选项告诉编译器代码块使用 <code>AT&amp;T</code> 汇编语法。</p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/2873-inline-asm.md">Rust RFC2873 Inline Assembly</a></li>
</ol>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p><code>red zone</code> 指的是栈顶指针下方一段内存区域，它不会被中断、异常或信号占用，一般被叶子函数优化使用，减少两次栈顶指针操作。- <a href="https://en.wikipedia.org/wiki/Red_zone_(computing)">维基百科</a> <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>]]></content>
		</item>
		
		<item>
			<title>OCI容器运行时实现（二）</title>
			<link>https://xiaopengli89.github.io/posts/oci-ns-network/</link>
			<pubDate>Mon, 20 Jul 2020 19:42:00 +0800</pubDate>
			
			<guid>https://xiaopengli89.github.io/posts/oci-ns-network/</guid>
			<description>&lt;p&gt;本篇文章在之前基础上实现容器的网络互通。&lt;/p&gt;
&lt;p&gt;实现思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在宿主机上创建网桥设备&lt;/li&gt;
&lt;li&gt;当子进程命名空间创建后，父进程获取子进程的命名空间&lt;/li&gt;
&lt;li&gt;利用管道实现父子进程同步&lt;/li&gt;
&lt;li&gt;创建虚拟设备对&lt;/li&gt;
&lt;li&gt;分别将虚拟设备对添加进子进程网络命名空间和连接到网桥&lt;/li&gt;
&lt;li&gt;分配虚拟设备ip并启动&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; 由于很多系统调用没有封装，这里将使用宿主机上的命令代替实现。&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>本篇文章在之前基础上实现容器的网络互通。</p>
<p>实现思路：</p>
<ol>
<li>在宿主机上创建网桥设备</li>
<li>当子进程命名空间创建后，父进程获取子进程的命名空间</li>
<li>利用管道实现父子进程同步</li>
<li>创建虚拟设备对</li>
<li>分别将虚拟设备对添加进子进程网络命名空间和连接到网桥</li>
<li>分配虚拟设备ip并启动</li>
</ol>
<p><strong>NOTE:</strong> 由于很多系统调用没有封装，这里将使用宿主机上的命令代替实现。</p>
<h3 id="ip参数解析">IP参数解析</h3>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">mod</span> <span class="nn">network</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"> </span><span class="c1">// 容器ip
</span></code></pre></div><h3 id="初始化网桥">初始化网桥</h3>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">type</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">result</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// 初始化网桥
</span><span class="c1"></span><span class="n">network</span>::<span class="n">init_bridge</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">const</span><span class="w"> </span><span class="n">BRIDGE_NAME</span>: <span class="kp">&amp;</span><span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="s">&#34;runc-rs&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// 启动设备
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">up_dev</span><span class="p">(</span><span class="n">dev</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Command</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;ip&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">args</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="s">&#34;link&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;set&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;dev&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;up&#34;</span><span class="p">])</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">output</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">output</span><span class="p">.</span><span class="n">status</span><span class="p">.</span><span class="n">success</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from_utf8_lossy</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">stderr</span><span class="p">.</span><span class="n">as_slice</span><span class="p">()).</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// 启动设备
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">up_dev_ns</span><span class="p">(</span><span class="n">dev</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">ns_id</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Command</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;ip&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">args</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;netns&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;exec&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">ns_id</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;ip&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;link&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;set&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;dev&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;up&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">])</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">output</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">output</span><span class="p">.</span><span class="n">status</span><span class="p">.</span><span class="n">success</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from_utf8_lossy</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">stderr</span><span class="p">.</span><span class="n">as_slice</span><span class="p">()).</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// 初始化网桥
</span><span class="c1"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">init_bridge</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Command</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;ip&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">args</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="s">&#34;-j&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;link&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;show&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">BRIDGE_NAME</span><span class="p">])</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">output</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">output</span><span class="p">.</span><span class="n">status</span><span class="p">.</span><span class="n">success</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">up_dev</span><span class="p">(</span><span class="n">BRIDGE_NAME</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(());</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="c1">// 创建网桥接口
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Command</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;ip&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">args</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="s">&#34;link&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;add&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">BRIDGE_NAME</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;type&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;bridge&#34;</span><span class="p">])</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">output</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">output</span><span class="p">.</span><span class="n">status</span><span class="p">.</span><span class="n">success</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from_utf8_lossy</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">stderr</span><span class="p">.</span><span class="n">as_slice</span><span class="p">()).</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="n">up_dev</span><span class="p">(</span><span class="n">BRIDGE_NAME</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="获取子进程命名空间">获取子进程命名空间</h3>
<p>当子进程命名空间创建后发送同步信号</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// 创建管道通信
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">pipes</span>: <span class="p">[</span><span class="n">libc</span>::<span class="n">c_int</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">libc</span>::<span class="n">pipe</span><span class="p">(</span><span class="n">pipes</span><span class="p">.</span><span class="n">as_mut_ptr</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">pipe_r</span><span class="p">,</span><span class="w"> </span><span class="n">pipe_w</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">pipes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">pipes</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// ...
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// unshare新命名空间
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">libc</span>::<span class="n">unshare</span><span class="p">(</span><span class="n">libc</span>::<span class="n">CLONE_NEWNS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">libc</span>::<span class="n">CLONE_NEWNET</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// 发送同步信号
</span><span class="c1"></span><span class="n">libc</span>::<span class="n">close</span><span class="p">(</span><span class="n">pipe_r</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">libc</span>::<span class="n">write</span><span class="p">(</span><span class="n">pipe_w</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="k">u8</span><span class="p">].</span><span class="n">as_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>父进程等待同步信号，并获取子进程的命名空间</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// 接收同步信号
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">libc</span>::<span class="n">read</span><span class="p">(</span><span class="n">pipe_r</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="k">u8</span><span class="p">].</span><span class="n">as_mut_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// 获取子进程网络命名空间
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">sub_net_ns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">network</span>::<span class="n">find_ns_net</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// 获取某个进程的网络命名空间
</span><span class="c1"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">find_ns_net</span><span class="p">(</span><span class="n">pid</span>: <span class="nc">libc</span>::<span class="n">pid_t</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Command</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;lsns&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">args</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;-t&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;net&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;-o&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;NS&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;-n&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;-p&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">pid</span><span class="p">.</span><span class="n">to_string</span><span class="p">().</span><span class="n">as_str</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="p">])</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">output</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">output</span><span class="p">.</span><span class="n">status</span><span class="p">.</span><span class="n">success</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from_utf8_lossy</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">stderr</span><span class="p">.</span><span class="n">as_slice</span><span class="p">()).</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ns_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from_utf8_lossy</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">stdout</span><span class="p">.</span><span class="n">as_slice</span><span class="p">())</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">trim</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">ns_id</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="创建虚拟设备对">创建虚拟设备对</h3>
<p>添加进 <code>netns</code> 是为了方便后续操作使用 <code>ip netns exec</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// 添加进netns
</span><span class="c1"></span><span class="n">network</span>::<span class="n">put_netns</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="n">sub_net_ns</span><span class="p">.</span><span class="n">as_str</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="c1">// 创建虚拟设备对
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">veth0</span><span class="p">,</span><span class="w"> </span><span class="n">veth1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">network</span>::<span class="n">create_veth</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// ...
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// 释放netns
</span><span class="c1"></span><span class="n">network</span>::<span class="n">release_netns</span><span class="p">(</span><span class="n">sub_net_ns</span><span class="p">.</span><span class="n">as_str</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// 添加进netns
</span><span class="c1"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">put_netns</span><span class="p">(</span><span class="n">pid</span>: <span class="nc">libc</span>::<span class="n">pid_t</span><span class="p">,</span><span class="w"> </span><span class="n">ns_id</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Command</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;ln&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">args</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;-s&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;/proc/{}/ns/net&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p">).</span><span class="n">as_str</span><span class="p">(),</span><span class="w">
</span><span class="w">            </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;/var/run/netns/{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">ns_id</span><span class="p">).</span><span class="n">as_str</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="p">])</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">output</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">output</span><span class="p">.</span><span class="n">status</span><span class="p">.</span><span class="n">success</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from_utf8_lossy</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">stderr</span><span class="p">.</span><span class="n">as_slice</span><span class="p">()).</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// 释放netns
</span><span class="c1"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">release_netns</span><span class="p">(</span><span class="n">ns_id</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Command</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;rm&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">args</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;/var/run/netns/{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">ns_id</span><span class="p">).</span><span class="n">as_str</span><span class="p">()])</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">output</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">output</span><span class="p">.</span><span class="n">status</span><span class="p">.</span><span class="n">success</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from_utf8_lossy</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">stderr</span><span class="p">.</span><span class="n">as_slice</span><span class="p">()).</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// 创建虚拟设备对
</span><span class="c1"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">create_veth</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// 生成随机虚拟设备名
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">veth0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span>::<span class="n">thread_rng</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">sample_iter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Alphanumeric</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">veth0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}-{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">BRIDGE_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">veth0</span><span class="p">.</span><span class="n">to_lowercase</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">veth1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span>::<span class="n">thread_rng</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">sample_iter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Alphanumeric</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">veth1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}-{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">BRIDGE_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">veth1</span><span class="p">.</span><span class="n">to_lowercase</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Command</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;ip&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">args</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;link&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;add&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">veth0</span><span class="p">.</span><span class="n">as_str</span><span class="p">(),</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;type&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;veth&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;peer&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;name&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">veth1</span><span class="p">.</span><span class="n">as_str</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="p">])</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">output</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">output</span><span class="p">.</span><span class="n">status</span><span class="p">.</span><span class="n">success</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from_utf8_lossy</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">stderr</span><span class="p">.</span><span class="n">as_slice</span><span class="p">()).</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">((</span><span class="n">veth0</span><span class="p">,</span><span class="w"> </span><span class="n">veth1</span><span class="p">))</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="虚拟设备对初始化">虚拟设备对初始化</h3>
<p>将虚拟设备一端添加进子进程网络命名空间并配置IP，另一端连接到网桥</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// 添加进子进程网络命名空间
</span><span class="c1"></span><span class="n">network</span>::<span class="n">link_veth_to_ns</span><span class="p">(</span><span class="n">veth1</span><span class="p">.</span><span class="n">as_str</span><span class="p">(),</span><span class="w"> </span><span class="n">sub_net_ns</span><span class="p">.</span><span class="n">as_str</span><span class="p">(),</span><span class="w"> </span><span class="n">ip</span><span class="p">.</span><span class="n">as_str</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="c1">// 连接网桥
</span><span class="c1"></span><span class="n">network</span>::<span class="n">link_veth_to_bridge</span><span class="p">(</span><span class="n">veth0</span><span class="p">.</span><span class="n">as_str</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// 将虚拟设备连接到网桥
</span><span class="c1"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">link_veth_to_bridge</span><span class="p">(</span><span class="n">veth</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Command</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;ip&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">args</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="s">&#34;link&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;set&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;dev&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">veth</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;master&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">BRIDGE_NAME</span><span class="p">])</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">output</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">output</span><span class="p">.</span><span class="n">status</span><span class="p">.</span><span class="n">success</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from_utf8_lossy</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">stderr</span><span class="p">.</span><span class="n">as_slice</span><span class="p">()).</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="n">up_dev</span><span class="p">(</span><span class="n">veth</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// 将虚拟设备放入命名空间
</span><span class="c1"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">link_veth_to_ns</span><span class="p">(</span><span class="n">veth</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">ns_id</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">ip</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Command</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;ip&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">args</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="s">&#34;link&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;set&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;dev&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">veth</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;netns&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">ns_id</span><span class="p">])</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">output</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">output</span><span class="p">.</span><span class="n">status</span><span class="p">.</span><span class="n">success</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from_utf8_lossy</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">stderr</span><span class="p">.</span><span class="n">as_slice</span><span class="p">()).</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="c1">// 重命名
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Command</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;ip&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">args</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;netns&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;exec&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">ns_id</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;ip&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;link&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;set&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;dev&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">veth</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;name&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;eth0&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">])</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">output</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">output</span><span class="p">.</span><span class="n">status</span><span class="p">.</span><span class="n">success</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from_utf8_lossy</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">stderr</span><span class="p">.</span><span class="n">as_slice</span><span class="p">()).</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="c1">// 配置ip
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Command</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;ip&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">args</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;netns&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;exec&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">ns_id</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;ip&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;addr&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;add&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">ip</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;dev&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;eth0&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">])</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">output</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">output</span><span class="p">.</span><span class="n">status</span><span class="p">.</span><span class="n">success</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from_utf8_lossy</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">stderr</span><span class="p">.</span><span class="n">as_slice</span><span class="p">()).</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="c1">// 启动设备
</span><span class="c1"></span><span class="w">    </span><span class="n">up_dev_ns</span><span class="p">(</span><span class="s">&#34;eth0&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">ns_id</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">up_dev_ns</span><span class="p">(</span><span class="s">&#34;lo&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">ns_id</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="测试2个容器的网络互通">测试2个容器的网络互通</h3>
<p><strong>NOTE:</strong> 如果宿主机上安装了 <code>docker</code>，<code>FORWARD</code> 链默认策略会被设置成 <code>DROP</code>，测试时需要将其修改为 <code>ACCEPT</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ iptables -P FORWARD ACCEPT
</code></pre></div><p>由于目前还未实现文件系统的联合挂载，因此需要2个独立的镜像文件系统拷贝：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> workspace
$ cp -r alpine alpine2
</code></pre></div><p>编译后运行2个容器</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ cargo build
$ ./target/debug/<span class="k">$(</span>program<span class="k">)</span> <span class="k">$(</span>workspace<span class="k">)</span>/alpine 10.0.1.2/24 /bin/sh
</code></pre></div><p>新开一个 <code>shell</code> 会话</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ ./target/debug/<span class="k">$(</span>program<span class="k">)</span> <span class="k">$(</span>workspace<span class="k">)</span>/alpine2 10.0.1.3/24 /bin/sh
</code></pre></div><p>查看2个容器的网络接口</p>
<pre><code class="language-none" data-lang="none">/ # ip addr
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
45: eth0@if46: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP qlen 1000
    link/ether 86:33:f9:cf:74:6a brd ff:ff:ff:ff:ff:ff
    inet 10.0.1.2/24 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::8433:f9ff:fecf:746a/64 scope link
       valid_lft forever preferred_lft forever
/ #
</code></pre><pre><code class="language-none" data-lang="none">/ # ip addr
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
47: eth0@if48: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP qlen 1000
    link/ether fe:75:c9:12:df:12 brd ff:ff:ff:ff:ff:ff
    inet 10.0.1.3/24 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::fc75:c9ff:fe12:df12/64 scope link
       valid_lft forever preferred_lft forever
/ #
</code></pre><p>测试2个容器网络能否互通</p>
<pre><code class="language-none" data-lang="none">/ # ping -c 3 10.0.1.3
PING 10.0.1.3 (10.0.1.3): 56 data bytes
64 bytes from 10.0.1.3: seq=0 ttl=64 time=0.269 ms
64 bytes from 10.0.1.3: seq=1 ttl=64 time=0.072 ms
64 bytes from 10.0.1.3: seq=2 ttl=64 time=0.073 ms

--- 10.0.1.3 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 0.072/0.138/0.269 ms
/ #
</code></pre><pre><code class="language-none" data-lang="none">/ # ping -c 3 10.0.1.2
PING 10.0.1.2 (10.0.1.2): 56 data bytes
64 bytes from 10.0.1.2: seq=0 ttl=64 time=0.089 ms
64 bytes from 10.0.1.2: seq=1 ttl=64 time=0.107 ms
64 bytes from 10.0.1.2: seq=2 ttl=64 time=0.107 ms

--- 10.0.1.2 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 0.089/0.101/0.107 ms
/ #
</code></pre><p>完整代码见：<a href="https://github.com/xiaopengli89/runc-rs">runc-rs</a></p>]]></content>
		</item>
		
		<item>
			<title>OCI容器运行时实现（一）</title>
			<link>https://xiaopengli89.github.io/posts/oci-ns-pid-mount-net/</link>
			<pubDate>Sat, 18 Jul 2020 22:15:35 +0800</pubDate>
			
			<guid>https://xiaopengli89.github.io/posts/oci-ns-pid-mount-net/</guid>
			<description>&lt;p&gt;一个OCI容器运行时有3个组成部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://man7.org/linux/man-pages/man7/namespaces.7.html&#34;&gt;NAMESPACES&lt;/a&gt; - 实现资源的隔离&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://man7.org/linux/man-pages/man7/cgroups.7.html&#34;&gt;CGROUPS&lt;/a&gt; - 实现资源的限制&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://man7.org/linux/man-pages/man2/pivot_root.2.html&#34;&gt;PIVOT_ROOT&lt;/a&gt; - 实现独立的根文件系统&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文将实现一个简易的 &lt;code&gt;进程&lt;/code&gt;、&lt;code&gt;根文件系统&lt;/code&gt;、&lt;code&gt;网络&lt;/code&gt; 隔离的容器运行时。&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>一个OCI容器运行时有3个组成部分：</p>
<ol>
<li><a href="https://man7.org/linux/man-pages/man7/namespaces.7.html">NAMESPACES</a> - 实现资源的隔离</li>
<li><a href="https://man7.org/linux/man-pages/man7/cgroups.7.html">CGROUPS</a> - 实现资源的限制</li>
<li><a href="https://man7.org/linux/man-pages/man2/pivot_root.2.html">PIVOT_ROOT</a> - 实现独立的根文件系统</li>
</ol>
<p>本文将实现一个简易的 <code>进程</code>、<code>根文件系统</code>、<code>网络</code> 隔离的容器运行时。</p>
<p>实现思路：</p>
<ol>
<li>利用 <code>fork</code> 系统调用创建子进程</li>
<li>修改子进程的命名空间</li>
<li>利用 <code>pivot_root</code> 系统调用替换子进程的文件系统</li>
<li>在子进程命名空间挂载 <code>/proc</code> 、<code>/sys</code> 、<code>/dev</code> 文件系统</li>
<li>在子进程命名空间中卸载旧文件系统</li>
<li>利用 <code>execve</code> 系统调用在子进程命名空间中执行对应程序</li>
</ol>
<h3 id="准备镜像文件系统">准备镜像文件系统</h3>
<p>新建工作目录，需要注意的是，镜像文件系统的父目录挂载类型需要 <code>private</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ mkdir workspace
$ mount --bind --make-private workspace workspace
$ <span class="nb">cd</span> workspace
$ mkdir alpine
</code></pre></div><p>测试使用 <a href="http://dl-cdn.alpinelinux.org/alpine/v3.12/releases/x86_64/alpine-minirootfs-3.12.0-x86_64.tar.gz">alpine-minirootfs-3.12.0-x86_64.tar.gz</a> 镜像，下载后解压：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ tar -C alpine -xf alpine-minirootfs-3.12.0-x86_64.tar.gz
</code></pre></div><h3 id="依赖">依赖</h3>
<p>添加 <a href="https://crates.io/crates/libc">libc</a> 依赖</p>
<div class="highlight"><pre class="chroma"><code class="language-toml" data-lang="toml"><span class="p">[</span><span class="nx">dependencies</span><span class="p">]</span>
<span class="nx">libc</span> <span class="p">=</span> <span class="s2">&#34;0.2.72&#34;</span>
</code></pre></div><h3 id="参数解析">参数解析</h3>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ffi</span>::<span class="n">CString</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ptr</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">env</span>::<span class="n">args</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">image_fs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"> </span><span class="c1">// 镜像文件系统，提前解压
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">command</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"> </span><span class="c1">// 要运行的容器命令
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// 运行容器命令的参数列表
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">command_args</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">CString</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">arg</span><span class="o">|</span><span class="w"> </span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="n">arg</span><span class="p">).</span><span class="n">unwrap</span><span class="p">()).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="n">command_args</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="n">command</span><span class="p">.</span><span class="n">as_str</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">command_args</span>: <span class="nb">Vec</span><span class="o">&lt;*</span><span class="k">const</span><span class="w"> </span><span class="n">libc</span>::<span class="n">c_char</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="w">	</span><span class="n">command_args</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">arg</span><span class="o">|</span><span class="w"> </span><span class="n">arg</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="n">command_args</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">ptr</span>::<span class="n">null</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// 转换成绝对目录
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">image_fs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">image_fs</span><span class="p">).</span><span class="n">to_path_buf</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">image_fs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">image_fs</span><span class="p">.</span><span class="n">is_relative</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">std</span>::<span class="n">env</span>::<span class="n">current_dir</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">join</span><span class="p">(</span><span class="n">image_fs</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">image_fs</span><span class="w">
</span><span class="w"></span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// 重要：image_fs的父目录挂载类型必须为private
</span><span class="c1">// 如果父目录不是挂载目录，执行sudo mount --bind --make-private $(parent) $(parent)
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">new_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="n">image_fs</span><span class="p">.</span><span class="n">to_str</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">old_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="n">image_fs</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s">&#34;.old_root&#34;</span><span class="p">).</span><span class="n">to_str</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></code></pre></div><h3 id="声明-pivot_root-系统调用">声明 <code>pivot_root</code> 系统调用</h3>
<p>由于 <a href="https://crates.io/crates/libc">libc</a> 没有封装 <code>pivot_root</code> 系统调用，可以手动声明FFI：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">mod</span> <span class="nn">ffi</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">pivot_root</span><span class="p">(</span><span class="w">
</span><span class="w">            </span><span class="n">new_root</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">libc</span>::<span class="n">c_char</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">put_old</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">libc</span>::<span class="n">c_char</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">libc</span>::<span class="n">c_int</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="创建子进程">创建子进程</h3>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">libc</span>::<span class="n">unshare</span><span class="p">(</span><span class="n">libc</span>::<span class="n">CLONE_NEWPID</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">libc</span>::<span class="n">fork</span><span class="p">();</span><span class="w">
</span><span class="w">	</span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">pid</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="n">pid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="c1">// child process
</span><span class="c1"></span><span class="w">		</span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">libc</span>::<span class="n">mount</span><span class="p">(</span><span class="w">
</span><span class="w">			</span><span class="n">new_root</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w">
</span><span class="w">			</span><span class="n">new_root</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w">
</span><span class="w">			</span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w">
</span><span class="w">			</span><span class="n">libc</span>::<span class="n">MS_BIND</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">libc</span>::<span class="n">MS_REC</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">libc</span>::<span class="n">MS_PRIVATE</span><span class="p">,</span><span class="w">
</span><span class="w">			</span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="p">);</span><span class="w">
</span><span class="w">		</span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">		</span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">libc</span>::<span class="n">mkdir</span><span class="p">(</span><span class="n">old_root</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w"> </span><span class="mi">0755</span><span class="p">);</span><span class="w">
</span><span class="w">		</span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">		</span><span class="c1">// ...
</span><span class="c1"></span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="c1">// parent process
</span><span class="c1"></span><span class="w">		</span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">libc</span>::<span class="n">wait4</span><span class="p">(</span><span class="w">
</span><span class="w">			</span><span class="n">pid</span><span class="p">,</span><span class="w">
</span><span class="w">			</span><span class="n">ptr</span>::<span class="n">null</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w">			</span><span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">			</span><span class="n">ptr</span>::<span class="n">null</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">		</span><span class="n">libc</span>::<span class="n">rmdir</span><span class="p">(</span><span class="n">old_root</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">());</span><span class="w">
</span><span class="w">		</span><span class="n">libc</span>::<span class="n">umount</span><span class="p">(</span><span class="n">new_root</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">());</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span></code></pre></div><p><code>new_root</code> 目录同样需要挂载成 <code>private</code>，以及在 <code>new_root</code> 目录下创建 <code>.old_root</code> 目录用于放旧的文件系统。</p>
<h3 id="切换命名空间">切换命名空间</h3>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// unshare新命名空间
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">libc</span>::<span class="n">unshare</span><span class="p">(</span><span class="n">libc</span>::<span class="n">CLONE_NEWNS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">libc</span>::<span class="n">CLONE_NEWNET</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span></code></pre></div><h3 id="切换文件系统">切换文件系统</h3>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// 切换根文件系统
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ffi</span>::<span class="n">pivot_root</span><span class="p">(</span><span class="n">new_root</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w"> </span><span class="n">old_root</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">root_dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="n">libc</span>::<span class="n">chdir</span><span class="p">(</span><span class="n">root_dir</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// 挂载/proc
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">libc</span>::<span class="n">mount</span><span class="p">(</span><span class="w">
</span><span class="w">	</span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w">
</span><span class="w">	</span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;/proc&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w">
</span><span class="w">	</span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;proc&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w">
</span><span class="w">	</span><span class="n">libc</span>::<span class="n">MS_NOEXEC</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">libc</span>::<span class="n">MS_NOSUID</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">libc</span>::<span class="n">MS_NODEV</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// 挂载/sys
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">libc</span>::<span class="n">mount</span><span class="p">(</span><span class="w">
</span><span class="w">	</span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w">
</span><span class="w">	</span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;/sys&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w">
</span><span class="w">	</span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;sysfs&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w">
</span><span class="w">	</span><span class="n">libc</span>::<span class="n">MS_NOEXEC</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">libc</span>::<span class="n">MS_NOSUID</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">libc</span>::<span class="n">MS_NODEV</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// 挂载/dev
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">libc</span>::<span class="n">mount</span><span class="p">(</span><span class="w">
</span><span class="w">	</span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w">
</span><span class="w">	</span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;/dev&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w">
</span><span class="w">	</span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;devtmpfs&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w">
</span><span class="w">	</span><span class="n">libc</span>::<span class="n">MS_STRICTATIME</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">libc</span>::<span class="n">MS_NOSUID</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;mode=755&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span></code></pre></div><h3 id="卸载旧文件系统">卸载旧文件系统</h3>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// 防止umount事件扩散到宿主环境
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">old_root_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;/.old_root&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">libc</span>::<span class="n">mount</span><span class="p">(</span><span class="w">
</span><span class="w">	</span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w">
</span><span class="w">	</span><span class="n">old_root_2</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w">
</span><span class="w">	</span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w">
</span><span class="w">	</span><span class="n">libc</span>::<span class="n">MS_SLAVE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">libc</span>::<span class="n">MS_REC</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// umount /.old_root
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">libc</span>::<span class="n">umount2</span><span class="p">(</span><span class="n">old_root_2</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w"> </span><span class="n">libc</span>::<span class="n">MNT_DETACH</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="n">libc</span>::<span class="n">rmdir</span><span class="p">(</span><span class="n">old_root_2</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">());</span><span class="w">
</span></code></pre></div><h3 id="执行容器内程序">执行容器内程序</h3>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">prog</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="n">command</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">libc</span>::<span class="n">execve</span><span class="p">(</span><span class="w">
</span><span class="w">	</span><span class="n">prog</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w">
</span><span class="w">	</span><span class="n">command_args</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w">
</span><span class="w">	</span><span class="n">ptr</span>::<span class="n">null</span>::<span class="o">&lt;</span><span class="n">libc</span>::<span class="n">c_char</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">unreachable</span><span class="o">!</span><span class="p">();</span><span class="w">
</span></code></pre></div><h3 id="编译运行">编译运行</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ cargo build
$ ./target/debug/<span class="k">$(</span>program<span class="k">)</span> <span class="k">$(</span>workspace<span class="k">)</span>/alpine /bin/sh
</code></pre></div><p>查看根文件系统：</p>
<pre><code class="language-none" data-lang="none">/ # ls -la
total 68
drwxr-xr-x   19 root     root          4096 Jul 18 15:48 .
drwxr-xr-x   19 root     root          4096 Jul 18 15:48 ..
drwxr-xr-x    2 root     root          4096 May 29 14:20 bin
drwxr-xr-x   20 root     root          3160 Jul 18 13:10 dev
drwxr-xr-x   15 root     root          4096 May 29 14:20 etc
drwxr-xr-x    2 root     root          4096 May 29 14:20 home
drwxr-xr-x    7 root     root          4096 May 29 14:20 lib
drwxr-xr-x    5 root     root          4096 May 29 14:20 media
drwxr-xr-x    2 root     root          4096 May 29 14:20 mnt
drwxr-xr-x    2 root     root          4096 May 29 14:20 opt
dr-xr-xr-x  165 root     root             0 Jul 18 15:48 proc
drwx------    2 root     root          4096 May 29 14:20 root
drwxr-xr-x    2 root     root          4096 May 29 14:20 run
drwxr-xr-x    2 root     root          4096 May 29 14:20 sbin
drwxr-xr-x    2 root     root          4096 May 29 14:20 srv
drwxr-xr-x    2 root     root          4096 May 29 14:20 sys
drwxrwxrwt    2 root     root          4096 May 29 14:20 tmp
drwxr-xr-x    7 root     root          4096 May 29 14:20 usr
drwxr-xr-x   12 root     root          4096 May 29 14:20 var
/ #
</code></pre><p>查看进程：</p>
<pre><code class="language-none" data-lang="none">/ # ps aux
PID   USER     TIME  COMMAND
    1 root      0:00 /bin/sh
    8 root      0:00 ps aux
/ #
</code></pre><p>查看网络接口：</p>
<pre><code class="language-none" data-lang="none">/ # ip link
1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
/ #
</code></pre><p>容易忽视的要点是镜像文件系统目录及其父目录的挂载属性必须为 <code>private</code>，尤其是在 <code>systemd</code> 环境下！</p>
<p>完整代码见：<a href="https://github.com/xiaopengli89/runc-rs">runc-rs</a></p>]]></content>
		</item>
		
		<item>
			<title>实现一个无依赖的Rust异步运行时</title>
			<link>https://xiaopengli89.github.io/posts/plain-rt/</link>
			<pubDate>Fri, 10 Jul 2020 19:23:16 +0800</pubDate>
			
			<guid>https://xiaopengli89.github.io/posts/plain-rt/</guid>
			<description>&lt;p&gt;这篇文章将非常直观、易懂地解释Rust异步运行时的实现。代码不超过300行，只依赖标准库，支持 &lt;code&gt;spawn&lt;/code&gt; 多个 &lt;code&gt;Task&lt;/code&gt; 并发执行。&lt;/p&gt;
&lt;p&gt;首先，Rust标准库对异步的抽象主要集中于几个类型，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Future&lt;/code&gt; - 对于一个异步操作的抽象，代表一个未来事件，如果事件未就绪，应暂停当前 &lt;code&gt;Task&lt;/code&gt;（可以去执行其他 &lt;code&gt;Task&lt;/code&gt;），事件就绪后，恢复执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Waker&lt;/code&gt; - 唤醒器，当事件就绪后，通知运行时重新调度和这个 &lt;code&gt;Waker&lt;/code&gt; 绑定的 &lt;code&gt;Task&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pin&lt;/code&gt; - 固定对象，是为了解决生成器状态机的自引用问题&lt;/li&gt;
&lt;/ul&gt;</description>
			<content type="html"><![CDATA[<p>这篇文章将非常直观、易懂地解释Rust异步运行时的实现。代码不超过300行，只依赖标准库，支持 <code>spawn</code> 多个 <code>Task</code> 并发执行。</p>
<p>首先，Rust标准库对异步的抽象主要集中于几个类型，分别是：</p>
<ul>
<li><code>Future</code> - 对于一个异步操作的抽象，代表一个未来事件，如果事件未就绪，应暂停当前 <code>Task</code>（可以去执行其他 <code>Task</code>），事件就绪后，恢复执行</li>
<li><code>Waker</code> - 唤醒器，当事件就绪后，通知运行时重新调度和这个 <code>Waker</code> 绑定的 <code>Task</code></li>
<li><code>Pin</code> - 固定对象，是为了解决生成器状态机的自引用问题</li>
</ul>
<h3 id="为什么rust的异步要这样设计">为什么Rust的异步要这样设计？</h3>
<p>要讨论这个问题，需要先就其他生态领域内的异步模型设计做一些比较。</p>
<p>最为人所熟知我想应该就是 <code>Javascript</code> 了，最初 <code>Javascript</code> 是被设计用于在浏览器内执行脚本代码，并且出于使用简单，采用了单线程模型（好处可以参考 <code>Redis</code>）。可是用户的代码执行流并不一定是线性的，比如点击按钮，需要基于事件作出响应。为此设计出了事件循环，而响应函数则利用回调的方式注册到事件循环上，当事件被触发时，回调函数被触发执行（需要指出的是，回调函数的执行也是在全局的单一线程中，这也导致如果在代码中有阻塞操作，回调函数的执行也会被推迟）。</p>
<p>然后就是被 <code>Go</code> 发扬光大的轻量级线程了。异步的出现是伴随着线程的复用而出现的，像 <code>Javascript</code> 的单线程回调模型也是在复用全局的主线程。而 <code>Go</code> 则通过在用户空间实现新的线程，这些用户空间的新线程再复用底层的操作系统线程，遇到阻塞调用时，重新调度用户空间的线程，由于调度这些线程不需要核内外的切换，创建、维持、销毁的开销也远小于操作系统线程，可以大量地创建，因此常被称为轻量级线程。</p>
<p>在讨论 <code>Rust</code> 的异步模型前，首先需要声明的是，类似的异步模型已经存在于其他生态领域，比如 <code>ES2017</code> 、<code>Python</code> 和 <code>.NET</code>，因此可以说 <code>Rust</code> 从它们身上借鉴了许多，甚至在新版本的 <a href="https://github.com/tokio-rs/tokio">tokio</a> 、 <a href="https://github.com/async-rs/async-std">async-std</a> 和 <a href="https://github.com/stjepang/smol">smol</a> 3个主流 <code>Rust</code> 异步运行时身上还能看到 <code>Go</code> 的影子。</p>
<p><code>Rust</code> 的异步模型同时借鉴了轻量级线程和回调。</p>
<p>从轻量级线程看，<code>Rust</code> 标准库内的 <code>Future</code> 可以变相地看成一种“线程”，我们习惯称其为 <code>Task</code> 。一个 <code>Task</code> 可以处于运行状态和暂停状态，当 <code>Task</code> 遇到阻塞调用时，需要从运行状态切换到暂停状态，而当阻塞恢复时，需要再从暂停状态切换回运行状态，而完成这种切换操作的角色，我们称之为 <code>Executor</code> 执行器。</p>
<p>这种切换类似于线程的调度，不过区别在于 <code>Task</code> 没有自己独立的执行栈以及需要主动让出线程使用权（非抢占）。对于前者，需要编译器支持将暂停时的 <code>Task</code> 状态保存起来，便于后续的恢复执行，也就是实现状态机。而线程拥有独立的执行栈，不需要编译器的支持即可完成这种操作。对于后者，<code>Task</code> 无法被抢占，如果一个恶意 <code>Task</code> 完全不让出线程使用权，则会导致其他 <code>Task</code> 的饥饿问题。从这2个方面看，<code>Goroutine</code> 是非常接近原生线程的，但是独立的执行栈，如何分配这个栈的大小，如果溢出了，如何动态增长，而动态增长会带来额外的性能开销，这些问题都需要去解决。而 <code>Task</code> 没有独立的执行栈，不需要解决这些问题，同时不会有内存的浪费（栈的大小分配不可能完全和需求一致）；抢占虽然对于解决负载均衡有帮助，但同时也会多出一些额外的切换次数开销，因此总体的吞吐反而小于非抢占式。</p>
<p>从回调看的话，<code>Task</code> 阻塞恢复时，需要一种机制来通知对应的 <code>Task</code> 可以被重新调度，完成这种功能的角色就是 <code>Waker</code> 唤醒器，而 <code>Waker</code> 也是通过注册回调来实现的。</p>
<p>对于 <code>Pin</code> 类型，则是在状态机的实现过程中，会存在自引用问题：当 <code>Task</code> 恢复执行后，可能会引用上一阶段产生的变量，而这些变量都是保存在自动生成的匿名结构中，这样就出现了一个 <code>Field</code> 可能去引用自身结构的另一个 <code>Field</code>。而这样的对象是无法安全地移动的，而目前的实现就是让它不再移动，也就是无法安全的获取其可变借用，<code>Pin</code> 类型便是对这种类型的封装。</p>
<p>综上，<code>Rust</code> 的异步模型可以说是在目前各生态领域里的一种选择，它不是完美的，却也足够优秀。当然目前也不存在完美的异步模型，对于一些闭源实现，看不到代码，不做判断。</p>
<h3 id="实现-waker">实现 <code>Waker</code></h3>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Waker</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">waker</span>: <span class="nc">RawWaker</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">RawWaker</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="sd">/// A data pointer, which can be used to store arbitrary data as required
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// by the executor. This could be e.g. a type-erased pointer to an `Arc`
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// that is associated with the task.
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// The value of this field gets passed to all functions that are part of
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// the vtable as the first parameter.
</span><span class="sd"></span><span class="w">    </span><span class="n">data</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="sd">/// Virtual function pointer table that customizes the behavior of this waker.
</span><span class="sd"></span><span class="w">    </span><span class="n">vtable</span>: <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="n">RawWakerVTable</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">RawWakerVTable</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="sd">/// This function will be called when the [`RawWaker`] gets cloned, e.g. when
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// the [`Waker`] in which the [`RawWaker`] is stored gets cloned.
</span><span class="sd"></span><span class="w">    </span><span class="sd">///
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// The implementation of this function must retain all resources that are
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// required for this additional instance of a [`RawWaker`] and associated
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// task. Calling `wake` on the resulting [`RawWaker`] should result in a wakeup
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// of the same task that would have been awoken by the original [`RawWaker`].
</span><span class="sd"></span><span class="w">    </span><span class="sd">///
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// [`Waker`]: struct.Waker.html
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// [`RawWaker`]: struct.RawWaker.html
</span><span class="sd"></span><span class="w">    </span><span class="n">clone</span>: <span class="nc">unsafe</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">())</span><span class="w"> </span>-&gt; <span class="nc">RawWaker</span><span class="p">,</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// This function will be called when `wake` is called on the [`Waker`].
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// It must wake up the task associated with this [`RawWaker`].
</span><span class="sd"></span><span class="w">    </span><span class="sd">///
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// The implementation of this function must make sure to release any
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// resources that are associated with this instance of a [`RawWaker`] and
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// associated task.
</span><span class="sd"></span><span class="w">    </span><span class="sd">///
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// [`Waker`]: struct.Waker.html
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// [`RawWaker`]: struct.RawWaker.html
</span><span class="sd"></span><span class="w">    </span><span class="n">wake</span>: <span class="nc">unsafe</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">()),</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// This function will be called when `wake_by_ref` is called on the [`Waker`].
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// It must wake up the task associated with this [`RawWaker`].
</span><span class="sd"></span><span class="w">    </span><span class="sd">///
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// This function is similar to `wake`, but must not consume the provided data
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// pointer.
</span><span class="sd"></span><span class="w">    </span><span class="sd">///
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// [`Waker`]: struct.Waker.html
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// [`RawWaker`]: struct.RawWaker.html
</span><span class="sd"></span><span class="w">    </span><span class="n">wake_by_ref</span>: <span class="nc">unsafe</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">()),</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// This function gets called when a [`RawWaker`] gets dropped.
</span><span class="sd"></span><span class="w">    </span><span class="sd">///
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// The implementation of this function must make sure to release any
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// resources that are associated with this instance of a [`RawWaker`] and
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// associated task.
</span><span class="sd"></span><span class="w">    </span><span class="sd">///
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// [`RawWaker`]: struct.RawWaker.html
</span><span class="sd"></span><span class="w">    </span><span class="n">drop</span>: <span class="nc">unsafe</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">()),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>标准库中对 <code>Waker</code> 的定义中只有一个 <code>RawWaker</code>，并且 <code>RawWaker</code> 结构内有 <code>data</code> 和 <code>vtable</code> 2个 <code>Field</code>。看到这里已经发现了 <code>RawWaker</code> 其实就是个由数据和虚表组成的胖指针，和 <code>Trait Object</code> 如出一辙，之所以不直接将 <code>Waker</code> 定义成 <code>Trait Object</code> 的原因，是为了 <code>Rust</code> 的异步模型可以灵活地适应于各类系统，包括没有内存分配器的嵌入式系统上。</p>
<p>既然 <code>Waker</code> 的作用是当事件就绪时通知 <code>Executor</code> 可以重新调度某个任务，不妨可以将 <code>Waker</code> 构造方法设计成接受一个闭包，而虚表的各类方法先取出闭包，然后执行闭包就行了：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">WakerFn</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">F</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">F</span>: <span class="nb">Fn</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="o">&gt;</span><span class="w"> </span><span class="n">WakerFn</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VTABLE</span>: <span class="nc">RawWakerVTable</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="w">        </span><span class="n">RawWakerVTable</span>::<span class="n">new</span><span class="p">(</span><span class="n">Self</span>::<span class="n">clone</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">wake</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">wake_by_ref</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">drop</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="n">data</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">())</span><span class="w"> </span>-&gt; <span class="nc">RawWaker</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">arc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">ManuallyDrop</span>::<span class="n">new</span><span class="p">(</span><span class="n">Arc</span>::<span class="n">from_raw</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">F</span><span class="p">));</span><span class="w">
</span><span class="w">        </span><span class="c1">// 增加引用计数，但是不执行析构方法，因为下面需要转换成裸指针，防止悬垂指针
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arc</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">RawWaker</span>::<span class="n">new</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">VTABLE</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">wake</span><span class="p">(</span><span class="n">data</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">arc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">from_raw</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">F</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">arc</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">wake_by_ref</span><span class="p">(</span><span class="n">data</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;*</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">F</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">f</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="n">data</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">drop</span><span class="p">(</span><span class="n">Arc</span>::<span class="n">from_raw</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">F</span><span class="p">))</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">get_waker</span><span class="p">(</span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Waker</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">into_raw</span><span class="p">(</span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">f</span><span class="p">))</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">vtable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">VTABLE</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Waker</span>::<span class="n">from_raw</span><span class="p">(</span><span class="n">RawWaker</span>::<span class="n">new</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">vtable</span><span class="p">))</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="实现-executor">实现 <code>Executor</code></h3>
<p><code>Executor</code> 的作用就是执行 <code>Task</code>，可以实现一个简单的任务队列，不停地从队列中取出任务，然后执行：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">RawTask</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">future</span>: <span class="nc">Mutex</span><span class="o">&lt;</span><span class="n">Pin</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">type</span> <span class="nc">Task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span><span class="o">&lt;</span><span class="n">RawTask</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Executor</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">rx_futures</span>: <span class="nc">Receiver</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">tx_futures</span>: <span class="nc">Sender</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Executor</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">rx_futures</span>: <span class="nc">Receiver</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">tx_futures</span>: <span class="nc">Sender</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">rx_futures</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">tx_futures</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">task</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">rx_futures</span><span class="p">.</span><span class="n">recv</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">tx_futures_w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">tx_futures</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">task_w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">task</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">waker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WakerFn</span>::<span class="n">get_waker</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// 重新调度任务
</span><span class="c1"></span><span class="w">                </span><span class="n">tx_futures_w</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">task_w</span><span class="p">.</span><span class="n">clone</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="p">});</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">cx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Context</span>::<span class="n">from_waker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waker</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">task</span><span class="p">.</span><span class="n">future</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_mut</span><span class="p">().</span><span class="n">poll</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">cx</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这里可以看到 <code>Task</code> 内的 <code>Future</code> 的 <code>Output</code> 关联类型被定义成了 <code>()</code> ，这是因为 <code>Executor</code> 只会接收顶级的 <code>Future</code> ，非顶级的 <code>Future</code> 组合子会由编译器生成的生成器自动处理，至于如何接收顶级 <code>Future</code> 的结果可以由下面的 <code>Runtime</code> 实现。</p>
<h3 id="实现-runtime">实现 <code>Runtime</code></h3>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Runtime</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">tx_futures</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Sender</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="c1">// 由于 Sender 没有实现 Sync，所以实现一个简单的 Spin
</span><span class="c1"></span><span class="w">    </span><span class="n">lock</span>: <span class="nc">AtomicBool</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Runtime</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Runtime</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">fn</span> <span class="nf">uninit</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">tx_futures</span>: <span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">lock</span>: <span class="nc">AtomicBool</span>::<span class="n">new</span><span class="p">(</span><span class="kc">false</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">init</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">tx_futures</span>: <span class="nc">Sender</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">tx_futures</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">tx_futures</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">spawn</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nc">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">R</span>: <span class="nb">Send</span> <span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">waiter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">Waiter</span>::<span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">());</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">waiter_f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WaiterFuture</span>::<span class="n">new</span><span class="p">(</span><span class="n">waiter</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span><span class="w">
</span><span class="w">        </span><span class="c1">// 包装task
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">async</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">await</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="n">waiter</span><span class="p">.</span><span class="n">complete</span><span class="p">(</span><span class="n">r</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">raw_task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RawTask</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">future</span>: <span class="nc">Mutex</span>::<span class="n">new</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">pin</span><span class="p">(</span><span class="n">f2</span><span class="p">)),</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">task</span>: <span class="nc">Task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">raw_task</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="c1">// 获取锁
</span><span class="c1"></span><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">lock</span><span class="p">.</span><span class="n">compare_and_swap</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">SeqCst</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">        </span><span class="c1">// 调度任务
</span><span class="c1"></span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">tx_futures</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">as_ref</span><span class="p">()</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;Runtime未初始化&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">task</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="c1">// 释放锁
</span><span class="c1"></span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">lock</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">SeqCst</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">waiter_f</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">block_on</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">F</span>::<span class="n">Output</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nc">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">R</span>: <span class="nb">Send</span> <span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mpsc</span>::<span class="n">channel</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="c1">// 包装task
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">async</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">await</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="n">tx</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">r</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">raw_task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RawTask</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">future</span>: <span class="nc">Mutex</span>::<span class="n">new</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">pin</span><span class="p">(</span><span class="n">f2</span><span class="p">)),</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">task</span>: <span class="nc">Task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">raw_task</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="c1">// 获取锁
</span><span class="c1"></span><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">lock</span><span class="p">.</span><span class="n">compare_and_swap</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">SeqCst</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">        </span><span class="c1">// 调度任务
</span><span class="c1"></span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">tx_futures</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">as_ref</span><span class="p">()</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;Runtime未初始化&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">task</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="c1">// 释放锁
</span><span class="c1"></span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">lock</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">SeqCst</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">rx</span><span class="p">.</span><span class="n">recv</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>block_on</code> 方法接收一个 <code>Future</code>，我们需要将其包装成一个 <code>Task</code>，然后发送到 <code>Executor</code>，而它的结果可以用一个 <code>channel</code> 来接收。而 <code>spawn</code> 方法则需要返回一个新的 <code>Future</code> ，并且 <code>spawn</code> 会派生一个顶级 <code>Future</code> ，也就是会并发执行，而 <code>channel</code> 的 <code>recv</code> 方法会阻塞线程，为此设计了 <code>WaiterFuture</code> 用于异步接收结果（当然也可以不去接收）：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Waiter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">val</span>: <span class="nc">Mutex</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">waker</span>: <span class="nc">Mutex</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Waker</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Waiter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">val</span>: <span class="nc">Mutex</span>::<span class="n">new</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">waker</span>: <span class="nc">Mutex</span>::<span class="n">new</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">val</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">val</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">waker</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">waker</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">take</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">waker</span><span class="p">.</span><span class="n">wake</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// TODO:
</span><span class="c1"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">WaiterFuture</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">waiter</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="n">Waiter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">WaiterFuture</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">waiter</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="n">Waiter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">waiter</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Future</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">WaiterFuture</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">get_unchecked_mut</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w</span><span class="p">.</span><span class="n">waiter</span><span class="p">.</span><span class="n">val</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">val</span><span class="p">.</span><span class="n">is_some</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">Poll</span>::<span class="n">Ready</span><span class="p">(</span><span class="n">val</span><span class="p">.</span><span class="n">take</span><span class="p">().</span><span class="n">unwrap</span><span class="p">())</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// 注册waker
</span><span class="c1"></span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">w_waker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w</span><span class="p">.</span><span class="n">waiter</span><span class="p">.</span><span class="n">waker</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">w_waker</span><span class="p">.</span><span class="n">is_none</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">waker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cx</span><span class="p">.</span><span class="n">waker</span><span class="p">().</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">                    </span><span class="o">*</span><span class="n">w_waker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">waker</span><span class="p">);</span><span class="w">
</span><span class="w">                </span><span class="p">}</span><span class="w">
</span><span class="w">                </span><span class="n">Poll</span>::<span class="n">Pending</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>当 <code>Waiter</code> 内的数据没有就绪时，注册当前 <code>Task</code> 的 <code>Waker</code>；当派生的顶级 <code>Future</code> 完成时，调用 <code>complete</code> 方法，写入数据，执行唤醒器（重新调度当前的 <code>Task</code>）。</p>
<h3 id="运行时的初始化">运行时的初始化</h3>
<p>由于新任务的派生可能在多个线程中，为此可以简单地初始化一个全局运行时，并将运行时标记为 <code>Sync</code>（因为我们对 <code>Sender</code> 已经做了自旋锁保护）：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tx_futures</span><span class="p">,</span><span class="w"> </span><span class="n">rx_futures</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mpsc</span>::<span class="n">channel</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="c1">// 初始化Executor
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">executor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Executor</span>::<span class="n">new</span><span class="p">(</span><span class="n">rx_futures</span><span class="p">,</span><span class="w"> </span><span class="n">tx_futures</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">});</span><span class="w">
</span><span class="w">    </span><span class="c1">// 初始化Runtime
</span><span class="c1"></span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">rt_ptr</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">Runtime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">RT</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">_</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="o">*</span><span class="n">rt_ptr</span><span class="p">).</span><span class="n">init</span><span class="p">(</span><span class="n">tx_futures</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RT</span><span class="p">.</span><span class="n">block_on</span><span class="p">(</span><span class="n">async</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">});</span><span class="w">
</span><span class="w">    </span><span class="n">dbg</span><span class="o">!</span><span class="p">(</span><span class="n">r</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">static</span><span class="w"> </span><span class="n">RT</span>: <span class="nc">Runtime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Runtime</span>::<span class="n">uninit</span><span class="p">();</span><span class="w">
</span></code></pre></div><p>运行代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ cargo run
</code></pre></div><pre><code class="language-none" data-lang="none">[src/main.rs:28] r = 2
</code></pre><p>为了验证 <code>Waker</code> 是否工作正常，可以实现一个虚假的IO操作：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">FakeIo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">val</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">start</span>: <span class="kt">bool</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">dur</span>: <span class="nc">Duration</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">FakeIo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">dur</span>: <span class="nc">Duration</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">val</span>: <span class="nc">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">Mutex</span>::<span class="n">new</span><span class="p">(</span><span class="nb">None</span><span class="p">)),</span><span class="w">
</span><span class="w">            </span><span class="n">start</span>: <span class="nc">false</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">dur</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Future</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">FakeIo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">val</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">is_some</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">Poll</span>::<span class="n">Ready</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">unwrap</span><span class="p">());</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">drop</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="bp">self</span><span class="p">.</span><span class="n">start</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cx</span><span class="p">.</span><span class="n">waker</span><span class="p">().</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">val</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">dur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">dur</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">get_unchecked_mut</span><span class="p">().</span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">dur</span><span class="p">);</span><span class="w">
</span><span class="w">                </span><span class="o">*</span><span class="n">v</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span><span class="w">
</span><span class="w">                </span><span class="n">w</span><span class="p">.</span><span class="n">wake</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="p">});</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">Poll</span>::<span class="n">Pending</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>FakeIo</code> 会创建一个子线程，一定时间后执行 <code>Waker</code>，可以用来模拟IO操作。</p>
<p>执行一个 <code>FakeIo</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RT</span><span class="p">.</span><span class="n">block_on</span><span class="p">(</span><span class="n">FakeIo</span>::<span class="n">new</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="mi">2</span><span class="p">)));</span><span class="w">
</span><span class="w"></span><span class="n">dbg</span><span class="o">!</span><span class="p">(</span><span class="n">r</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>2秒后结果：</p>
<pre><code class="language-none" data-lang="none">[src/main.rs:28] r = 100
</code></pre><p>我们也可以在一个任务中派生一个新任务并异步接收它的结果（也可以不接收，但它仍然会并发执行）：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RT</span><span class="p">.</span><span class="n">block_on</span><span class="p">(</span><span class="n">async</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RT</span><span class="p">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">FakeIo</span>::<span class="n">new</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="mi">2</span><span class="p">))).</span><span class="n">await</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="w"></span><span class="p">});</span><span class="w">
</span><span class="w"></span><span class="n">dbg</span><span class="o">!</span><span class="p">(</span><span class="n">r</span><span class="p">);</span><span class="w">
</span></code></pre></div><pre><code class="language-none" data-lang="none">[src/main.rs:28] r = 101
</code></pre><h3 id="结尾">结尾</h3>
<p>好了，一个非常精简、无依赖的异步运行时就已经实现，虽然没有线程池、真异步IO，可能存在重复唤醒等问题，但是却非常清晰地阐述了 <code>Rust</code> 的异步实现原理：<code>Runtime</code> 向 <code>Executor</code> 发送任务，<code>Executor</code> 执行任务，<code>Waker</code> 唤醒暂停的任务，如此往复，以及 <code>Pin</code> 类型防止存在自引用的结构安全地获取到可变借用。</p>
<p>完整的代码见：<a href="https://github.com/xiaopengli89/plain-rt">plain-rt</a></p>]]></content>
		</item>
		
		<item>
			<title>Rust高阶生命周期绑定</title>
			<link>https://xiaopengli89.github.io/posts/rust-hrtbs/</link>
			<pubDate>Fri, 03 Jul 2020 23:40:45 +0800</pubDate>
			
			<guid>https://xiaopengli89.github.io/posts/rust-hrtbs/</guid>
			<description>&lt;p&gt;Rust中，&lt;code&gt;lifetime&lt;/code&gt; 其实也是一种类型参数，可以看成范型的一种特殊形式。编译时需要将所有类型（包括 &lt;code&gt;lifetime&lt;/code&gt; ）确定下来，比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;: &lt;span class=&#34;kp&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;i32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;&amp;#39;a&lt;/span&gt;: &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;::&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的 &lt;code&gt;&#39;a&lt;/code&gt; 生命周期其实就是变量 &lt;code&gt;x&lt;/code&gt; 所在的block。&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>Rust中，<code>lifetime</code> 其实也是一种类型参数，可以看成范型的一种特殊形式。编译时需要将所有类型（包括 <code>lifetime</code> ）确定下来，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">foo</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="na">&#39;a</span>: <span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="n">foo</span>::<span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>上面的 <code>'a</code> 生命周期其实就是变量 <code>x</code> 所在的block。</p>
<p>这个例子很简单，但如果我们换个闭包类型看看：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">foo</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w">		</span><span class="n">f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>第一次调用 <code>f(&amp;x)</code> 时生命周期 <code>'a</code> 等于变量 <code>x</code> 的生命周期；而在第二次调用 <code>f(&amp;y)</code> 时，生命周期 <code>'a</code> 又等于了变量 <code>y</code> 的生命周期；而变量 <code>x</code> 和变量 <code>y</code> 的生命周期显然是不同的。因此无法用一个静态的生命周期来描述 <code>'a</code> ，我们希望的是，闭包 <code>f</code> 在具体调用时绑定具体的生命周期，比如调用 <code>f(&amp;x)</code> 时绑定的是 <code>x</code> 的生命周期，而调用 <code>f(&amp;y)</code> 时绑定的是 <code>y</code> 的生命周期。</p>
<p>Rust中可以用 <code>高阶生命周期绑定（HRTBs）</code> 来实现&quot;动态&quot;生命周期绑定，其语法如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">for</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Trait</span><span class="w">
</span></code></pre></div><p>比如上面的例子就可以写成：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">f</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="k">for</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w">		</span><span class="n">f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这样生命周期 <code>'a</code> 就不再是静态的了，他会随着闭包 <code>f</code> 的调用绑定到不同的生命周期：<code>f(&amp;x)</code> 调用时绑定到 <code>x</code> 的生命周期，<code>f(&amp;y)</code> 调用时绑定到 <code>y</code> 的生命周期。</p>
<p>不过大多数时候我们很少见到 <code>HRTBs</code> ，因为闭包的生命周期省略的话，编译器会帮我们自动生成 <code>高阶生命周期绑定</code> 。</p>
<p>而 <code>HRTBs</code> 的全称是 <code>Higher-Rank Trait Bounds</code>，翻译成 <code>高阶特质绑定</code> 可能更为合适，并且它只能在绑定 <code>trait</code> 时声明，不过目前只支持对生命周期参数的绑定，所以我翻译它叫 <code>高阶生命周期绑定</code> 。</p>]]></content>
		</item>
		
		<item>
			<title>Rust动态内存分配</title>
			<link>https://xiaopengli89.github.io/posts/rust-box-heap/</link>
			<pubDate>Wed, 01 Jul 2020 16:57:56 +0800</pubDate>
			
			<guid>https://xiaopengli89.github.io/posts/rust-box-heap/</guid>
			<description>&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/std/boxed/index.html&#34;&gt;Box&lt;/a&gt; 是一个在Rust中经常被用到的智能指针，它的作用是实现堆内存分配，并且管理该块内存的生命周期。尤其在实现递归数据结构时，通过 &lt;a href=&#34;https://doc.rust-lang.org/std/boxed/index.html&#34;&gt;Box&lt;/a&gt; 才能让一个类型大小不会无限膨胀。同时 &lt;a href=&#34;https://doc.rust-lang.org/std/boxed/index.html&#34;&gt;Box&lt;/a&gt; 的内存布局同 &lt;code&gt;C&lt;/code&gt; 二进制兼容，也就是说在使用 &lt;code&gt;FFI&lt;/code&gt; 时，可以直接在参数或返回值中使用 &lt;a href=&#34;https://doc.rust-lang.org/std/boxed/index.html&#34;&gt;Box&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这篇文章将介绍利用Rust的动态内存分配实现一个简单的自定义 &lt;code&gt;Box&lt;/code&gt; 。&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p><a href="https://doc.rust-lang.org/std/boxed/index.html">Box</a> 是一个在Rust中经常被用到的智能指针，它的作用是实现堆内存分配，并且管理该块内存的生命周期。尤其在实现递归数据结构时，通过 <a href="https://doc.rust-lang.org/std/boxed/index.html">Box</a> 才能让一个类型大小不会无限膨胀。同时 <a href="https://doc.rust-lang.org/std/boxed/index.html">Box</a> 的内存布局同 <code>C</code> 二进制兼容，也就是说在使用 <code>FFI</code> 时，可以直接在参数或返回值中使用 <a href="https://doc.rust-lang.org/std/boxed/index.html">Box</a>。</p>
<p>这篇文章将介绍利用Rust的动态内存分配实现一个简单的自定义 <code>Box</code> 。</p>
<h3 id="内存分配器">内存分配器</h3>
<p>对于每一个程序，标准库中都会带有一个全局的内存分配器，并且内存分配器需要实现 <code>GlobalAlloc</code> 这个 <code>trait</code> ，在使用 <code>alloc</code> 和 <code>dealloc</code> 时会使用该内存分配器动态分配和释放内存。默认情况下，这个内存分配器是 <code>std::alloc::System</code> ，由具体的操作系统提供，比如 <code>Unix</code> 平台的 <code>malloc</code>，<code>Windows</code> 平台的 <code>HeapAlloc</code> 。</p>
<p>我们也可以利用 <code>#[global_allocator]</code> 这个 <code>attribute</code> 替换默认的内存分配器。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">alloc</span>::<span class="p">{</span><span class="n">GlobalAlloc</span><span class="p">,</span><span class="w"> </span><span class="n">System</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">MyAllocator</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="n">GlobalAlloc</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyAllocator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">layout</span>: <span class="nc">Layout</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="n">layout</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">dealloc</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">layout</span>: <span class="nc">Layout</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="n">dealloc</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">layout</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[global_allocator]</span><span class="w">
</span><span class="w"></span><span class="k">static</span><span class="w"> </span><span class="n">GLOBAL</span>: <span class="nc">MyAllocator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyAllocator</span><span class="p">;</span><span class="w">
</span></code></pre></div><h3 id="实现-mybox-智能指针">实现 <code>MyBox</code> 智能指针</h3>
<p>由 <code>alloc</code> 分配好内存，会返回指向该块内存的指针，因此首先 <code>MyBox</code> 内需要持有一个裸指针，来代表对该块内存的所有权。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">inner</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>然后实现其构造方法，方法是先 <code>alloc</code> 内存，然后往内存地址内写入数据，比如仿标准库的 <code>Box</code> ：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">layout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Layout</span>::<span class="n">new</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc</span><span class="p">(</span><span class="n">layout</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="n">ptr</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">inner</span>: <span class="nc">ptr</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyBox</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这种方法首先需要在栈上创建一个变量 <code>T</code> ，然后再拷贝到堆上。也可以实现类似 <code>Java</code> 风格的构造方法，但是在构造方法内，必须初始化所有字段的值，否则后面使用时会 <code>UB</code>，因此我们将这种构造方式标记为 <code>unsafe</code> ：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">init</span><span class="p">(</span><span class="n">f</span>: <span class="nc">impl</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">layout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Layout</span>::<span class="n">new</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc</span><span class="p">(</span><span class="n">layout</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="n">f</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">inner</span>: <span class="nc">ptr</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="n">MyBox</span>::<span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span>::<span class="n">init</span><span class="p">(</span><span class="o">|</span><span class="n">obj</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="n">obj</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">		</span><span class="p">})</span><span class="w">
</span><span class="w">	</span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>内存分配了就需要释放，我们可以在析构方法内完成内存的释放，实现 <code>Drop</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">layout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Layout</span>::<span class="n">new</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">dealloc</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">inner</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">layout</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>为了方便地访问 <code>MyBox</code> 内的数据，利用Rust自动解引用的特性，我们可以实现 <code>Deref</code> 和 <code>DerefMut</code> 这2个 <code>trait</code> ：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">core</span>::<span class="n">ops</span>::<span class="p">{</span><span class="n">Deref</span><span class="p">,</span><span class="w"> </span><span class="n">DerefMut</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span>::<span class="n">Target</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;*</span><span class="bp">self</span><span class="p">.</span><span class="n">inner</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">DerefMut</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Target</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">inner</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>然后便可以使用 <code>*</code> 解引用操作符实现对内部数据的访问：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyBox</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>最后可以实现 <code>fmt::Debug</code> 和 <code>fmt::Display</code> 2个 <code>trait</code> 来打印内部的数据：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">fmt</span>::<span class="n">Debug</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Debug</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">fmt</span>::<span class="n">Debug</span>::<span class="n">fmt</span><span class="p">(</span><span class="o">&amp;**</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">fmt</span>::<span class="n">Display</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">fmt</span>::<span class="n">Display</span>::<span class="n">fmt</span><span class="p">(</span><span class="o">&amp;**</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyBox</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="验证内存的回收">验证内存的回收</h3>
<p>我们可以在自定义内存分配器时，通过记录已分配的内存大小来追踪内存的分配和回收情况：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">sync</span>::<span class="n">atomic</span>::<span class="p">{</span><span class="n">AtomicUsize</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">SeqCst</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">MyAllocator</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">static</span><span class="w"> </span><span class="n">ALLOCATED</span>: <span class="nc">AtomicUsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AtomicUsize</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="n">GlobalAlloc</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyAllocator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">layout</span>: <span class="nc">Layout</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">ret</span><span class="p">.</span><span class="n">is_null</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">ALLOCATED</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="n">layout</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">SeqCst</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">ret</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">dealloc</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">layout</span>: <span class="nc">Layout</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="n">dealloc</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">layout</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">ALLOCATED</span><span class="p">.</span><span class="n">fetch_sub</span><span class="p">(</span><span class="n">layout</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">SeqCst</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[global_allocator]</span><span class="w">
</span><span class="w"></span><span class="k">static</span><span class="w"> </span><span class="n">GLOBAL</span>: <span class="nc">MyAllocator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyAllocator</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>测试下循环创建 1_000_000 个 <code>MyBox</code> 实例：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="mi">1_000_000</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyBox</span>::<span class="n">new</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w">	</span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;allocated bytes: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">ALLOCATED</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">SeqCst</span><span class="p">));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>运行程序：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ cargo run
</code></pre></div><pre><code class="language-none" data-lang="none">allocated bytes: 285
</code></pre><p>如果我们注释掉析构方法的内存释放操作：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">//let layout = Layout::new::&lt;T&gt;();
</span><span class="c1"></span><span class="w">        </span><span class="c1">//unsafe {
</span><span class="c1"></span><span class="w">        </span><span class="c1">//    dealloc(self.inner as *mut u8, layout);
</span><span class="c1"></span><span class="w">        </span><span class="c1">//}
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>再次运行程序的结果：</p>
<pre><code class="language-none" data-lang="none">allocated bytes: 4000285
</code></pre><p>说明我们的实现确实实现了内存的动态分配和回收。</p>]]></content>
		</item>
		
		<item>
			<title>不使用Rust标准库编写一个可运行的程序</title>
			<link>https://xiaopengli89.github.io/posts/rust-no-std/</link>
			<pubDate>Wed, 01 Jul 2020 00:02:35 +0800</pubDate>
			
			<guid>https://xiaopengli89.github.io/posts/rust-no-std/</guid>
			<description>&lt;p&gt;Rust是一门系统编程语言，比如使得编写操作系统内核变得可能。而在编写内核时，是不能有任何和操作系统相关的依赖的，因为操作系统内核是运行于裸机之上的，这就像鸡和鸡蛋的关系。而标准库的实现是基于操作系统的，诸如线程、文件、网络等等。因此在编写内核代码时不能使用标准库。这篇文章将介绍如何不使用Rust标准库编写一个可运行的程序。&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>Rust是一门系统编程语言，比如使得编写操作系统内核变得可能。而在编写内核时，是不能有任何和操作系统相关的依赖的，因为操作系统内核是运行于裸机之上的，这就像鸡和鸡蛋的关系。而标准库的实现是基于操作系统的，诸如线程、文件、网络等等。因此在编写内核代码时不能使用标准库。这篇文章将介绍如何不使用Rust标准库编写一个可运行的程序。</p>
<h3 id="禁用标准库">禁用标准库</h3>
<p>默认情况下，编译器会自动为我们的项目引用标准库，因此首先第一步是要禁用标准库，可以使用 <code>#![no_std]</code> 这个 <code>crate-level attribute</code> 来禁用标准库：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#![no_std]</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Hello, World!&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果我们现在尝试运行它的话，会得到下面的错误：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ cargo build
</code></pre></div><pre><code class="language-none" data-lang="none">error: cannot find macro `println` in this scope
 --&gt; src/main.rs:4:5
  |
4 |     println!(&quot;Hello world!&quot;);
  |     ^^^^^^^

error: `#[panic_handler]` function required, but not found

error: language item required, but not found: `eh_personality`

error: aborting due to 3 previous errors

error: could not compile `panic-hander`.

To learn more, run the command again with --verbose.
</code></pre><p>这里一共有3个错误，第1个：</p>
<pre><code class="language-none" data-lang="none">error: cannot find macro `println` in this scope
</code></pre><p>这个错误是因为 <code>println!</code> 这个宏是定义在标准库 <code>std::println</code> 里的，而我们禁用了标准库，自然无法再使用它。</p>
<p>第2个：</p>
<pre><code class="language-none" data-lang="none">error: `#[panic_handler]` function required, but not found
</code></pre><p>默认情况下的Rust程序是带有一个非常小的Runtime的，其中包括设置了panic异常处理：打印导致异常的backtrace。如果不使用标准库的话，就需要我们自己设置一个panic异常处理函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#![no_std]</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">core</span>::<span class="n">panic</span>::<span class="n">PanicInfo</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[panic_handler]</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">panic_handler</span><span class="p">(</span><span class="n">info</span>: <span class="kp">&amp;</span><span class="nc">PanicInfo</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这个异常处理函数的返回值是个 <a href="https://doc.rust-lang.org/std/primitive.never.html">never</a> 类型，这个函数不能被其他函数调用。可以先写个 <code>loop {}</code> 作为函数实现，参数 <code>PanicInfo</code> 则包含了发生异常的上下文信息。</p>
<p>第3个：</p>
<pre><code class="language-none" data-lang="none">error: language item required, but not found: `eh_personality`
</code></pre><p>提示缺少一个 <code>eh_personality</code> 的语言项。默认情况下当函数发生panic时，线程会停止，Rust展开线程栈，并析构栈上的变量。这是因为Rust支持捕获异常，而为了防止当函数异常退出时，没有析构栈上变量而导致内存或其他系统资源的泄漏。同样的，在不使用标准库时，需要我们自己实现一个 <code>eh_personality</code> 。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#![no_std]</span><span class="w">
</span><span class="w"></span><span class="cp">#![feature(lang_items)]</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">core</span>::<span class="n">panic</span>::<span class="n">PanicInfo</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[panic_handler]</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">panic_handler</span><span class="p">(</span><span class="n">info</span>: <span class="kp">&amp;</span><span class="nc">PanicInfo</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[lang = </span><span class="s">&#34;eh_personality&#34;</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">rust_eh_personality</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>再次编译时：</p>
<pre><code class="language-none" data-lang="none">error: requires `start` lang_item
</code></pre><p>提示缺少一个 <code>start</code> 语言项。在正常情况下 <code>main</code> 函数是作为Rust程序的入口，其实不然，在 <code>main</code> 函数执行前，需要先完成执行环境的初始化，如栈的创建，参数保存到对应的寄存器中，这些操作是在C库的入口函数中完成的，然后C库再调用Rust的Runtime入口函数，该函数被 <code>start</code> 语言项标记，Runtime在完成一些初始化配置后，再调用用户定义的 <code>main</code> 函数。因此我们需要重新实现最开始的入口函数，这个函数依赖于具体的操作系统。当然，在这个之前先需要禁用默认的 <code>main</code> 函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#![no_main]</span><span class="w">
</span></code></pre></div><p>在Linux上入口函数是 <code>_start</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[no_mangle]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">_start</span><span class="p">(</span><span class="n">_argc</span>: <span class="kt">isize</span><span class="p">,</span><span class="w"> </span><span class="n">_argv</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="mi">0</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在Mac上是 <code>main</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[no_mangle]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="n">_argc</span>: <span class="kt">isize</span><span class="p">,</span><span class="w"> </span><span class="n">_argv</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="mi">0</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>no_mangle</code> 是为了防止编译器修改符号。</p>
<p>我在Mac上编译时：</p>
<pre><code class="language-none" data-lang="none">ld: dynamic main executables must link with libSystem.dylib for architecture x86_64
</code></pre><p>这是因为Mac平台不允许静态链接到二进制库，需要添加编译器参数：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ cargo rustc -- -C link-arg<span class="o">=</span>-lSystem
</code></pre></div><p>如果是在Linux上编译的话：</p>
<pre><code class="language-none" data-lang="none">/src/main.rs:8: multiple definition of `_start'; /usr/lib/gcc/x86_64-pc-linux-gnu/10.1.0/../../../../lib/Scrt1.o:(.text+0x0): first defined here
          /usr/bin/ld: /usr/lib/gcc/x86_64-pc-linux-gnu/10.1.0/../../../../lib/Scrt1.o: in function `_start':
          (.text+0x16): undefined reference to `__libc_csu_fini'
          /usr/bin/ld: (.text+0x1d): undefined reference to `__libc_csu_init'
          /usr/bin/ld: (.text+0x24): undefined reference to `main'
          /usr/bin/ld: (.text+0x2a): undefined reference to `__libc_start_main'
          collect2: error: ld returned 1 exit status
</code></pre><p>因为编译器还是链接了C库的符号，并且和我们的入口函数发生了冲突，需要添加编译器参数：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ cargo rustc -- -C link-args<span class="o">=</span>-nostartfiles -lc
</code></pre></div><p>顺利编译通过！</p>
<h3 id="hello-world-呢">Hello, World 呢？</h3>
<p>由于我们的程序什么都没有做，因此运行不会产生任何效果（当然也不会报错）。</p>
<p>如果我们想打印 <code>Hello, World</code> 的话，可以借用 <code>libc</code> 这个库：</p>
<div class="highlight"><pre class="chroma"><code class="language-toml" data-lang="toml"><span class="nx">libc</span> <span class="p">=</span> <span class="s2">&#34;0.2.71&#34;</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[no_mangle]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="n">_argc</span>: <span class="kt">isize</span><span class="p">,</span><span class="w"> </span><span class="n">_argv</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="n">libc</span>::<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Hello, World!\n\0&#34;</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">_</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="mi">0</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>编译后运行：</p>
<pre><code class="language-none" data-lang="none">Hello, World!
</code></pre><p>我们来处理下panic，然后尝试触发下panic：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[no_mangle]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="n">_nargs</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">_args</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">libc</span>::<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Hello, World!\n\0&#34;</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">_</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;panic&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[panic_handler]</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">panic_handler</span><span class="p">(</span><span class="n">info</span>: <span class="kp">&amp;</span><span class="nc">PanicInfo</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">location</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">libc</span>::<span class="n">printf</span><span class="p">(</span><span class="w">
</span><span class="w">                </span><span class="s">&#34;panic at %s:%d\n\0&#34;</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="n">l</span><span class="p">.</span><span class="n">file</span><span class="p">().</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w">
</span><span class="w">                </span><span class="n">l</span><span class="p">.</span><span class="n">line</span><span class="p">(),</span><span class="w">
</span><span class="w">            </span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">libc</span>::<span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>运行的结果：</p>
<pre><code class="language-none" data-lang="none">Hello, World!
panic at src/main.rs:12
</code></pre><p>第2行是我们打印的异常处理。</p>
<h3 id="结尾">结尾</h3>
<p>好了，到这里就已经实现了一个不带标准库的Rust程序。虽然比平时写的Rust程序多了些东西，但其实是标准库为我们做了很多，现在只是我们自己去完成这些罢了。Rust是名副其实的系统级编程语言，虽然学习曲线有些陡峭，但是随着深入理解，这些都是Rust的目标所在，Rust是近几十年里出现的真正为解决系统编程问题而设计的出色语言。</p>]]></content>
		</item>
		
		<item>
			<title>Rust过程宏（一）</title>
			<link>https://xiaopengli89.github.io/posts/rust-procedural-macro-1/</link>
			<pubDate>Sat, 27 Jun 2020 17:22:04 +0800</pubDate>
			
			<guid>https://xiaopengli89.github.io/posts/rust-procedural-macro-1/</guid>
			<description>&lt;h3 id=&#34;rust宏&#34;&gt;Rust宏&lt;/h3&gt;
&lt;p&gt;宏属于元编程，用于生成代码，减少重复代码的编写，同时不同于运行时反射，宏会在编译时被展开，没有运行时开销。在Rust中，宏大体分为2类：声明宏和过程宏。&lt;/p&gt;
&lt;p&gt;声明宏较为简单，类似模式匹配，利用递归和替换把重复的代码片段隐藏起来，典型的实现是标准库中 &lt;code&gt;vec!&lt;/code&gt;，&lt;code&gt;println!&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;过程宏则稍微复杂，但是功能强大的多，可以精确地控制语法树的生成。同时过程宏使用Rust代码编写，灵活性和表达能力丰富。过程宏经常被用于3种情景下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自动实现 &lt;code&gt;trait&lt;/code&gt;，使用 &lt;code&gt;derive&lt;/code&gt; 派生宏&lt;/li&gt;
&lt;li&gt;装饰 &lt;code&gt;field&lt;/code&gt; 或 函数，使用 &lt;code&gt;attribute&lt;/code&gt; 属性宏&lt;/li&gt;
&lt;li&gt;实现 &lt;code&gt;DSL&lt;/code&gt;，使用 &lt;code&gt;function&lt;/code&gt; 函数宏&lt;/li&gt;
&lt;/ol&gt;</description>
			<content type="html"><![CDATA[<h3 id="rust宏">Rust宏</h3>
<p>宏属于元编程，用于生成代码，减少重复代码的编写，同时不同于运行时反射，宏会在编译时被展开，没有运行时开销。在Rust中，宏大体分为2类：声明宏和过程宏。</p>
<p>声明宏较为简单，类似模式匹配，利用递归和替换把重复的代码片段隐藏起来，典型的实现是标准库中 <code>vec!</code>，<code>println!</code>。</p>
<p>过程宏则稍微复杂，但是功能强大的多，可以精确地控制语法树的生成。同时过程宏使用Rust代码编写，灵活性和表达能力丰富。过程宏经常被用于3种情景下：</p>
<ol>
<li>自动实现 <code>trait</code>，使用 <code>derive</code> 派生宏</li>
<li>装饰 <code>field</code> 或 函数，使用 <code>attribute</code> 属性宏</li>
<li>实现 <code>DSL</code>，使用 <code>function</code> 函数宏</li>
</ol>
<h3 id="过程宏的编写">过程宏的编写</h3>
<p>过程宏的构建有特殊的规则，过程宏的定义必须置于独立的 <code>crate</code> 中，并且需要指明 <code>lib</code> 开启 <code>proc-macro</code> 。</p>
<p>首先创建一个 <code>mymacro</code> 的 <code>lib</code> 项目：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ cargo new mymacro --lib
</code></pre></div><p>然后再在 <code>mymacro</code> 内创建个 <code>mymacro_derive</code> 的 <code>lib</code> 项目：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> mymacro
$ cargo new mymacro_derive --lib
</code></pre></div><p>在 <code>mymacro/Cargo.toml</code> 内添加 <code>mymacro_derive</code> 的依赖：</p>
<div class="highlight"><pre class="chroma"><code class="language-toml" data-lang="toml"><span class="p">[</span><span class="nx">dependencies</span><span class="p">]</span>
<span class="nx">mymacro_derive</span> <span class="p">=</span> <span class="err">{</span> <span class="nx">path</span> <span class="p">=</span> <span class="s2">&#34;mymacro_derive&#34;</span> <span class="err">}</span>
</code></pre></div><p>在 <code>mymacro/mymacro_derive/Cargo.toml</code> 内开启 <code>proc-macro</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-toml" data-lang="toml"><span class="p">[</span><span class="nx">lib</span><span class="p">]</span>
<span class="nx">proc</span><span class="err">-</span><span class="nx">macro</span> <span class="p">=</span> <span class="kc">true</span>
</code></pre></div><p>在 <code>mymacro/mymacro_derive/src/lib.rs</code> 中需要引入 <code>proc_macro</code> ：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">proc_macro</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>接下来就可以实现我们的过程宏了。先从 <code>derive</code> 派生宏 开始吧。</p>
<h3 id="derive-派生宏"><code>derive</code> 派生宏</h3>
<p><code>derive</code> 派生宏可以自动实现我们的自定义 <code>trait</code>，为此我们先在 <code>mymacro/src/lib.rs</code> 定义我们的 <code>trait</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">MyMacro</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">show_fields</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>然后在 <code>mymacro/mymacro_derive/src/lib.rs</code> 下面实现我们的代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">proc_macro</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">proc_macro</span>::<span class="n">TokenStream</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[proc_macro_derive(MyMacro)]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">mymacro_derive</span><span class="p">(</span><span class="n">input</span>: <span class="nc">TokenStream</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TokenStream</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">todo</span><span class="o">!</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>#[proc_macro_derive(MyMacro)]</code> 指示我们为 <code>MyMacro</code> 实现 <code>derive</code> 派生宏；函数 <code>mymacro_derive</code> 的参数和返回值都是 <code>proc_macro::TokenStream</code> 标记流。</p>
<p>不过直接操作 <code>proc_macro::TokenStream</code> 十分不便，为此有2个 <code>crate</code> 可以帮助我们：<code>syn</code> 和 <code>quote</code>。<code>syn</code> 可以帮我们把标记流转换成语法树，<code>quote</code> 可以再把 <code>syn</code> 的数据结构转换回标记流。我们添加下 <code>syn</code> 和 <code>quote</code> 的依赖：</p>
<div class="highlight"><pre class="chroma"><code class="language-toml" data-lang="toml"><span class="p">[</span><span class="nx">dependencies</span><span class="p">]</span>
<span class="nx">syn</span> <span class="p">=</span> <span class="err">{</span> <span class="nx">version</span> <span class="p">=</span> <span class="s2">&#34;1.0&#34;</span><span class="p">,</span> <span class="nx">features</span> <span class="p">=</span> <span class="p">[</span> <span class="s2">&#34;extra-traits&#34;</span> <span class="p">]</span> <span class="err">}</span>
<span class="nx">quote</span> <span class="p">=</span> <span class="s2">&#34;1.0&#34;</span>
</code></pre></div><p>把标记流转换为语法树：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">syn</span>::<span class="n">DeriveInput</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[proc_macro_derive(MyMacro)]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">mymacro_derive</span><span class="p">(</span><span class="n">input</span>: <span class="nc">TokenStream</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TokenStream</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ast</span>: <span class="nc">DeriveInput</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">syn</span>::<span class="n">parse</span><span class="p">(</span><span class="n">input</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">dbg</span><span class="o">!</span><span class="p">(</span><span class="n">ast</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">todo</span><span class="o">!</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这里我们把转换后的语法树打印了出来（需要在 <code>sync</code> 依赖中启用 <code>extra-traits</code> 这个 <code>feature</code>）。</p>
<p>在 <code>mymacro/src/lib.rs</code> 中写个测试：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="n">mymacro_derive</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// --snip--
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(MyMacro)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Dog</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">age</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[cfg(test)]</span><span class="w">
</span><span class="w"></span><span class="k">mod</span> <span class="nn">test</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="cp">#[test]</span><span class="w">
</span><span class="w">	</span><span class="k">fn</span> <span class="nf">dog_show</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Dog</span>::<span class="n">show_fields</span><span class="p">();</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>执行测试：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ cargo <span class="nb">test</span> dog_show
</code></pre></div><p>会得到下面的输出：</p>
<pre><code class="language-none" data-lang="none">[mymacro_derive/src/lib.rs:9] ast = DeriveInput {
    attrs: [],
    vis: Inherited,
    ident: Ident {
        ident: &quot;Dog&quot;,
        span: #0 bytes(131..134),
    },
    generics: Generics {
        lt_token: None,
        params: [],
        gt_token: None,
        where_clause: None,
    },
    data: Struct(
...
error: proc-macro derive panicked
 --&gt; src/lib.rs:9:14
  |
9 |     #[derive(MyMacro)]
  |              ^^^^^^^
  |
  = help: message: not yet implemented
...
</code></pre><p>因为我们还没有具体实现，所以编译器提示编译失败。不过我们可以在其中看到 <code>ast</code> 中的很多有用的内容。</p>
<p>我们利用 <code>ast</code> 中的信息实现 <code>MyMacro</code> 中的 <code>show_fields</code> 关联方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">proc_macro</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">proc_macro</span>::<span class="n">TokenStream</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">quote</span>::<span class="n">quote</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">syn</span>::<span class="p">{</span><span class="n">Data</span><span class="p">,</span><span class="w"> </span><span class="n">DeriveInput</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[proc_macro_derive(MyMacro)]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">mymacro_derive</span><span class="p">(</span><span class="n">input</span>: <span class="nc">TokenStream</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TokenStream</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ast</span>: <span class="nc">DeriveInput</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">syn</span>::<span class="n">parse</span><span class="p">(</span><span class="n">input</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 提取结构名称
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ast</span><span class="p">.</span><span class="n">ident</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 只支持为结构类型派生
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">fields</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">Data</span>::<span class="n">Struct</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ast</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">s</span><span class="p">.</span><span class="n">fields</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;derive MyMacro must on struct&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 提取所有属性名称及其类型
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">fields</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fields</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">into_iter</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">f</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">f_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">ident</span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">f_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">ty</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">Type</span>::<span class="n">Path</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f_type</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">p</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;field type must be Path&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">f_type</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w">
</span><span class="w">                </span><span class="p">.</span><span class="n">path</span><span class="w">
</span><span class="w">                </span><span class="p">.</span><span class="n">segments</span><span class="w">
</span><span class="w">                </span><span class="p">.</span><span class="n">into_iter</span><span class="p">()</span><span class="w">
</span><span class="w">                </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">ident</span><span class="p">.</span><span class="n">to_string</span><span class="p">())</span><span class="w">
</span><span class="w">                </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">f_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f_type</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s">&#34;::&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">f_name</span><span class="p">,</span><span class="w"> </span><span class="n">f_type</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">})</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 格式化成文本
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">fields_txt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="n">r</span><span class="err">#&#34;</span><span class="p">{{</span><span class="w">
</span><span class="w">    </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}}</span><span class="err">&#34;#</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">fields</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s">&#34;\n    &#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 为输入的结构实现 MyMacro
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">gen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">quote</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">impl</span><span class="w"> </span><span class="n">MyMacro</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="err">#</span><span class="n">name</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">fn</span> <span class="nf">show_fields</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="err">#</span><span class="n">fields_txt</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 输出 TokenStream
</span><span class="c1"></span><span class="w">    </span><span class="n">TokenStream</span>::<span class="n">from</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>quote!</code> 这个宏帮助我们以Rust的语法方式生成需要输出的结构，并且提供了 <code>#</code> 模板语法，将名字替换成对应的值，最后将生成的结构输出成标记流。</p>
<p>再运行下测试：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ cargo <span class="nb">test</span> dog_show -- --nocapture
</code></pre></div><p>输出如下：</p>
<pre><code class="language-none" data-lang="none">...
running 1 test
{
    name: String
    age: u8
}
test test::dog_show ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>成功输出了 <code>Dog</code> 结构的所有属性名称及类型。我们可以运行以下命令打印出展开后的代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ cargo rustc -- -Z unstable-options --pretty<span class="o">=</span>expanded
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#![feature(prelude_import)]</span><span class="w">
</span><span class="w"></span><span class="cp">#[prelude_import]</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">prelude</span>::<span class="n">v1</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="cp">#[macro_use]</span><span class="w">
</span><span class="w"></span><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">std</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="n">mymacro_derive</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">MyMacro</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">show_fields</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Dog</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">age</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">MyMacro</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Dog</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">show_fields</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="p">{</span><span class="w">
</span><span class="w">            </span>::<span class="n">std</span>::<span class="n">io</span>::<span class="n">_print</span><span class="p">(</span>::<span class="n">core</span>::<span class="n">fmt</span>::<span class="n">Arguments</span>::<span class="n">new_v1</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="s">&#34;&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;\n&#34;</span><span class="p">],</span><span class="w">
</span><span class="w">                                                             </span><span class="o">&amp;</span><span class="k">match</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="s">&#34;{\n    name: String\n    age: u8\n}&#34;</span><span class="p">,)</span><span class="w">
</span><span class="w">                                                                  </span><span class="p">{</span><span class="w">
</span><span class="w">                                                                  </span><span class="p">(</span><span class="n">arg0</span><span class="p">,)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
</span><span class="w">                                                                  </span><span class="p">[</span>::<span class="n">core</span>::<span class="n">fmt</span>::<span class="n">ArgumentV1</span>::<span class="n">new</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span><span class="w">
</span><span class="w">                                                                                                </span>::<span class="n">core</span>::<span class="n">fmt</span>::<span class="n">Display</span>::<span class="n">fmt</span><span class="p">)],</span><span class="w">
</span><span class="w">                                                              </span><span class="p">}));</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>可以看到展开后的代码，编译器已经为我们实现了 <code>MyMacro</code>，<code>show_fields</code> 方法打印出了 <code>Dog</code> 结构的所有属性。</p>
<p>利用 <code>derive</code> 派生宏可以方便地为我们自动实现 <code>trait</code> ，访问结构的元信息，并且不会有任何运行时开销！</p>
<p>待续 &hellip;</p>]]></content>
		</item>
		
		<item>
			<title>Rust闭包</title>
			<link>https://xiaopengli89.github.io/posts/rust-closure/</link>
			<pubDate>Tue, 23 Jun 2020 22:59:21 +0800</pubDate>
			
			<guid>https://xiaopengli89.github.io/posts/rust-closure/</guid>
			<description>&lt;h3 id=&#34;闭包closure的实现原理&#34;&gt;闭包(Closure)的实现原理&lt;/h3&gt;
&lt;p&gt;闭包在调用形式上和函数非常相似：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;传递参数&lt;/li&gt;
&lt;li&gt;执行一段代码&lt;/li&gt;
&lt;li&gt;返回结果&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是闭包可以捕获当前上下文环境中的变量，而函数不可以（访问全局静态变量除外，但是这和闭包的实现完全不一样）。&lt;/p&gt;
&lt;p&gt;闭包的创建和调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;env_var&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fn1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;env_var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;result1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fn1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;assert_eq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;result1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;result2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fn1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;assert_eq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;result2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
			<content type="html"><![CDATA[<h3 id="闭包closure的实现原理">闭包(Closure)的实现原理</h3>
<p>闭包在调用形式上和函数非常相似：</p>
<ol>
<li>传递参数</li>
<li>执行一段代码</li>
<li>返回结果</li>
</ol>
<p>但是闭包可以捕获当前上下文环境中的变量，而函数不可以（访问全局静态变量除外，但是这和闭包的实现完全不一样）。</p>
<p>闭包的创建和调用：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">env_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">fn1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">env_var</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">result1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fn1</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">result1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">result2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fn1</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">result2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>编译器在编译过程中会创建对应的匿名结构，并根据需要实现三个 <code>trait</code>：<a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html">FnOnce</a>、<a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html">FnMut</a>、<a href="https://doc.rust-lang.org/std/ops/trait.Fn.html">Fn</a> ，而闭包的创建就是该匿名结构的实例化，闭包调用则是3个 <code>trait</code> 的方法调用。</p>
<p>以下是3个 <code>trait</code> 的定义：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">FnOnce</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="sd">/// The returned type after the call operator is used.
</span><span class="sd"></span><span class="w">    </span><span class="cp">#[stable(feature = </span><span class="s">&#34;fn_once_output&#34;</span><span class="cp">, since = </span><span class="s">&#34;1.12.0&#34;</span><span class="cp">)]</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// Performs the call operation.
</span><span class="sd"></span><span class="w">    </span><span class="cp">#[unstable(feature = </span><span class="s">&#34;fn_traits&#34;</span><span class="cp">, issue = </span><span class="s">&#34;29625&#34;</span><span class="cp">)]</span><span class="w">
</span><span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;rust-call&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">call_once</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">args</span>: <span class="nc">Args</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">FnMut</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span>: <span class="nb">FnOnce</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="sd">/// Performs the call operation.
</span><span class="sd"></span><span class="w">    </span><span class="cp">#[unstable(feature = </span><span class="s">&#34;fn_traits&#34;</span><span class="cp">, issue = </span><span class="s">&#34;29625&#34;</span><span class="cp">)]</span><span class="w">
</span><span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;rust-call&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">call_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">args</span>: <span class="nc">Args</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Fn</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span>: <span class="nb">FnMut</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="sd">/// Performs the call operation.
</span><span class="sd"></span><span class="w">    </span><span class="cp">#[unstable(feature = </span><span class="s">&#34;fn_traits&#34;</span><span class="cp">, issue = </span><span class="s">&#34;29625&#34;</span><span class="cp">)]</span><span class="w">
</span><span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;rust-call&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">args</span>: <span class="nc">Args</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>其中 <code>Args</code> 为闭包参数类型，使用元组 ( <code>Tuple</code>) 来表示参数列表，<code>Output</code> 是返回值类型。</p>
<p>并且可以发现 <code>FnMut</code> 派生自 <code>FnOnce</code>，而 <code>Fn</code> 又派生自 <code>FnMut</code>，这里需要这样理解：</p>
<p><em><strong>如果一个函数接收一个 <code>FnOnce</code> 参数，总可以传递一个 <code>FnMut</code></strong></em><br>
<em><strong>如果一个函数接收一个 <code>FnMut</code>，总可以传递一个 <code>Fn</code></strong></em></p>
<p>我们可以手动构造一个 <code>FnOnce</code> 闭包结构实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#![feature(unboxed_closures)]</span><span class="w">
</span><span class="w"></span><span class="cp">#![feature(fn_traits)]</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="p">{</span><span class="nb">Fn</span><span class="p">,</span><span class="w"> </span><span class="nb">FnMut</span><span class="p">,</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">MyFn</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">env_var</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">FnOnce</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyFn</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">;</span><span class="w">
</span><span class="w">	
</span><span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;rust-call&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">call_once</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">args</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">env_var</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">env_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;env_var&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">my_fn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyFn</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">env_var</span><span class="p">,</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">	
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">o1</span>: <span class="nb">String</span> <span class="o">=</span><span class="w"> </span><span class="n">my_fn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// 这里调用 call_once 方法, my_fn 变量 move 进方法
</span><span class="c1"></span><span class="w">	</span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">o1</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;env_var&#34;</span><span class="p">));</span><span class="w">
</span><span class="w">	
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">o2</span>: <span class="nb">String</span> <span class="o">=</span><span class="w"> </span><span class="n">my_fn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="c1">// 编译不过，因为 my_fn 变量已经被 move 掉了
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>接着为 <code>MyFn</code> 实现 <code>FnMut</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// ...
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">MyFn</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">env_var</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">FnOnce</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyFn</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;rust-call&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">call_once</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">args</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">call_mut</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">FnMut</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyFn</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;rust-call&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">call_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">args</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">env_var</span><span class="p">.</span><span class="n">to_owned</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">env_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;env_var&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">my_fn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyFn</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">env_var</span>: <span class="kp">&amp;</span><span class="nc">env_var</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">	
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">o1</span>: <span class="nb">String</span> <span class="o">=</span><span class="w"> </span><span class="n">my_fn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// 这里调用 call_mut 方法, my_fn 变量 mut borrow 进方法
</span><span class="c1"></span><span class="w">	</span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">o1</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;env_var&#34;</span><span class="p">));</span><span class="w">
</span><span class="w">	
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">o2</span>: <span class="nb">String</span> <span class="o">=</span><span class="w"> </span><span class="n">my_fn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="c1">// 还是调用 call_mut 方法，my_fn 变量依然有效
</span><span class="c1"></span><span class="w">	</span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">o2</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;env_var&#34;</span><span class="p">));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这里可以看到，如果某个参数如果需要调用 <code>call_once</code> 方法的话，<code>call_once</code> 内部只要再次调用 <code>call_mut</code> 即可，因为一个 <code>Ownership</code> 总可以转成一个 <code>Mut Borrow</code>，同理 <code>Mut Borrow</code> 总可以转成 <code>Borrow</code> 。</p>
<p>测试一个函数接受 <code>FnOnce</code>，传递一个 <code>FnMut</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// ...
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">expect_fn_once</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">F</span>: <span class="nb">FnOnce</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">),</span><span class="w"> </span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span>: <span class="nb">String</span> <span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="c1">// 这里调用的是 call_once
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">env_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;env_var&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">my_fn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyFn</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">env_var</span>: <span class="kp">&amp;</span><span class="nc">env_var</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">	
</span><span class="w">	</span><span class="n">expect_fn_once</span><span class="p">(</span><span class="n">my_fn</span><span class="p">);</span><span class="w"> </span><span class="c1">// 因为 my_fn 实现了 FnOnce，所以可以作为参数传递
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>另外，<code>FnOnce</code> 、<code>FnMut</code> 、<code>Fn</code> 有3个语法糖表示：</p>
<p><code>FnOnce(T1, T2) -&gt; T3</code> 可以用来表示 <code>FnOnce&lt;(T1, T2), Output = T3&gt;</code></p>
<p>因此上面的 <code>expect_fn_once</code> 方法可以简写为：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">expect_fn_once</span><span class="p">(</span><span class="n">f</span>: <span class="nc">impl</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span>: <span class="nb">String</span> <span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>FnMut</code> 、<code>Fn</code> 同理。</p>
<h3 id="编译器闭包的生成规则">编译器闭包的生成规则</h3>
<ol>
<li>如果闭包只需要上下文环境的 <code>Borrow</code> ，优先生成 <code>Fn</code> ，方法默认调用 <code>call</code> ，因为上下文环境可以被同时 <code>Borrow</code> 多次，例如：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">fn1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">fn2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w">
</span></code></pre></div><ol start="2">
<li>如果闭包需要上下文环境的 <code>Mut Borrow</code>，则生成 <code>FnMut</code>，方法默认调用 <code>call_mut</code>，因为不会丢失 <code>Ownership</code>，闭包可以被多次调用，上下文环境 <code>Mut Borrow</code> 进闭包结构，当闭包被 <code>drop</code> 掉后，外部才能再次使用被捕获的变量，例如：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">fn1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">fn2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="c1">// 这里无法编译通过，因为 f1 已经 mut borrow 了 a
</span><span class="c1"></span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="n">fn1</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w">
</span></code></pre></div><ol start="3">
<li>如果闭包需要上下文的 <code>Ownership</code>，则生成 <code>FnOcne</code>，方法调用 <code>call_once</code>，因为调用闭包会导致失去 <code>Ownership</code> ，所以闭包只能调用一次，上下文环境被 <code>move</code> 进闭包，外部不再能使用被捕获的变量，例如：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;a&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">fn1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">b</span>: <span class="nb">String</span> <span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="n">b</span><span class="w">
</span><span class="w"></span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">fn2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">b</span>: <span class="nb">String</span> <span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="c1">// 这里无法编译通过，因为 a 变量已经被 move 进了 fn1
</span><span class="c1"></span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="c1">// 这里也无法编译通过
</span></code></pre></div><p>有时我们需要强制捕获变量的 <code>Ownership</code> ，可以在闭包上修饰 <code>move</code> 关键字，这在多线程/异步环境下很常见。</p>]]></content>
		</item>
		
		<item>
			<title>关于Go Mysql Driver引入QueryContext带来的数据竞争</title>
			<link>https://xiaopengli89.github.io/posts/go-mysql-driver-race/</link>
			<pubDate>Sun, 24 May 2020 14:50:06 +0800</pubDate>
			
			<guid>https://xiaopengli89.github.io/posts/go-mysql-driver-race/</guid>
			<description>&lt;p&gt;在&lt;a href=&#34;https://xiaopengli89.github.io/posts/go-mysql-driver-eof/&#34;&gt;关于Go Mysql Driver的unexpected EOF错误&lt;/a&gt;里提到了连接池，当连接&lt;strong&gt;使用完毕&lt;/strong&gt;后会放回连接池以便其他的操作可以复用这条连接。这里的&lt;strong&gt;使用完毕&lt;/strong&gt;有非常明确的定义：发送缓冲区中不再有未发送的指令，接收缓冲区不再有未接收的数据，下次能读取的数据必须是下一次发送的指令的响应。&lt;/p&gt;
&lt;p&gt;通常情况下的SQL操作如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;rows&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Query&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;SELECT a, b FROM some_table&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rows&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rows&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rows&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Scan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
			<content type="html"><![CDATA[<p>在<a href="/posts/go-mysql-driver-eof/">关于Go Mysql Driver的unexpected EOF错误</a>里提到了连接池，当连接<strong>使用完毕</strong>后会放回连接池以便其他的操作可以复用这条连接。这里的<strong>使用完毕</strong>有非常明确的定义：发送缓冲区中不再有未发送的指令，接收缓冲区不再有未接收的数据，下次能读取的数据必须是下一次发送的指令的响应。</p>
<p>通常情况下的SQL操作如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;SELECT a, b FROM some_table&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="k">defer</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

<span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">string</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">b</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><ol>
<li><code>db.Query</code> 返回一个 <code>Rows</code> 游标对象</li>
<li>注册一个 <code>rows.Close</code> 延迟函数用于关闭 <code>Rows</code> 对象</li>
<li>通过 <code>rows.Next</code> 迭代器读取每一行数据</li>
<li>通过 <code>rows.Scan</code> 将当前行的数据存入声明的变量中</li>
</ol>
<p>整个代码片段会有2种结果</p>
<ol>
<li>读取了所有数据</li>
<li>未读取或读取了部分数据，然后发生错误</li>
</ol>
<p>第一种情况由于读取了所有数据，满足<strong>使用完毕</strong>的条件，可以放回连接池；第二种情况，由于发生了错误，连接失效，后续会重新打开新连接，新连接自然是满足<strong>使用完毕</strong>条件的。</p>
<p>如果在 <code>rows.Next</code> 迭代器中，中途退出（未发生错误的情况下），那接收缓冲区中还有未读取的数据，因此对应的SQL驱动需要在 <code>rows.Close</code> 方法中冲刷掉还未读取的数据，直至缓冲区中读取至EOF为止。如果 <code>rows.Close</code> 不被调用，不但接收缓冲区中有残留的数据，同时连接也不会被放回连接池，切记不可遗忘 <code>rows.Close</code> 调用。</p>
<p>在 <a href="https://golang.org/pkg/database/sql/">database/sql</a> 引入 <code>QueryContext</code> 后，执行SQL操作时，会单独创建一个新的Goroutine用于超时取消：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rs</span> <span class="o">*</span><span class="nx">Rows</span><span class="p">)</span> <span class="nf">initContextClose</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">txctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">txctx</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">txctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">bypassRowsAwaitDone</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">cancel</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
	<span class="k">go</span> <span class="nx">rs</span><span class="p">.</span><span class="nf">awaitDone</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">txctx</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// awaitDone blocks until either ctx or txctx is canceled. The ctx is provided
</span><span class="c1">// from the query context and is canceled when the query Rows is closed.
</span><span class="c1">// If the query was issued in a transaction, the transaction&#39;s context
</span><span class="c1">// is also provided in txctx to ensure Rows is closed if the Tx is closed.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">rs</span> <span class="o">*</span><span class="nx">Rows</span><span class="p">)</span> <span class="nf">awaitDone</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">txctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">txctxDone</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
	<span class="k">if</span> <span class="nx">txctx</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">txctxDone</span> <span class="p">=</span> <span class="nx">txctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">txctxDone</span><span class="p">:</span>
	<span class="p">}</span>
	<span class="nx">rs</span><span class="p">.</span><span class="nb">close</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div><p>这样在 <code>Context</code> 超时取消后，这个单独的Goroutine会马上执行 <code>rows.Close</code> ，冲刷缓冲区后把连接放回连接池，防止因业务Goroutine长期阻塞导致连接无法放回连接池。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rs</span> <span class="o">*</span><span class="nx">Rows</span><span class="p">)</span> <span class="nb">close</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">rs</span><span class="p">.</span><span class="nx">closemu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">closemu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">closed</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">rs</span><span class="p">.</span><span class="nx">closed</span> <span class="p">=</span> <span class="kc">true</span>

	<span class="k">if</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">lasterr</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">rs</span><span class="p">.</span><span class="nx">lasterr</span> <span class="p">=</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nf">withLock</span><span class="p">(</span><span class="nx">rs</span><span class="p">.</span><span class="nx">dc</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="p">=</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">rowsi</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="p">})</span>
	<span class="k">if</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="nf">rowsCloseHook</span><span class="p">();</span> <span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">fn</span><span class="p">(</span><span class="nx">rs</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">cancel</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">rs</span><span class="p">.</span><span class="nf">cancel</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">closeStmt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">rs</span><span class="p">.</span><span class="nx">closeStmt</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">rs</span><span class="p">.</span><span class="nf">releaseConn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></div><p>但是当这个Goroutine正在冲刷缓冲区的同时，业务Goroutine正在执行 <code>rows.Scan</code> 方法，这个方法会读取缓冲区中的数据，这里就发生了2个Goroutine的数据竞争。但是和 <code>rows.Next</code> 方法却不会导致数据竞争，是因为 <code>rows.Next</code> 和 <code>rows.Close</code> 使用了互斥锁保护临界区。<code>rows.Scan</code> 并没有保护 <code>convertAssignRows</code> 方法，同时 <a href="https://pkg.go.dev/github.com/go-sql-driver/mysql?tab=doc">github.com/go-sql-driver/mysql</a> 为了性能，共享了缓冲区和 <code>lastcols</code> 的内存。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rs</span> <span class="o">*</span><span class="nx">Rows</span><span class="p">)</span> <span class="nb">close</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">rs</span><span class="p">.</span><span class="nx">closemu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">closemu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">closed</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">rs</span><span class="p">.</span><span class="nx">closed</span> <span class="p">=</span> <span class="kc">true</span>

	<span class="k">if</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">lasterr</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">rs</span><span class="p">.</span><span class="nx">lasterr</span> <span class="p">=</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nf">withLock</span><span class="p">(</span><span class="nx">rs</span><span class="p">.</span><span class="nx">dc</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="p">=</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">rowsi</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="p">})</span>
	<span class="k">if</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="nf">rowsCloseHook</span><span class="p">();</span> <span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">fn</span><span class="p">(</span><span class="nx">rs</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">cancel</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">rs</span><span class="p">.</span><span class="nf">cancel</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">closeStmt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">rs</span><span class="p">.</span><span class="nx">closeStmt</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">rs</span><span class="p">.</span><span class="nf">releaseConn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rs</span> <span class="o">*</span><span class="nx">Rows</span><span class="p">)</span> <span class="nf">Next</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">doClose</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span>
	<span class="nf">withLock</span><span class="p">(</span><span class="nx">rs</span><span class="p">.</span><span class="nx">closemu</span><span class="p">.</span><span class="nf">RLocker</span><span class="p">(),</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">doClose</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">rs</span><span class="p">.</span><span class="nf">nextLocked</span><span class="p">()</span>
	<span class="p">})</span>
	<span class="k">if</span> <span class="nx">doClose</span> <span class="p">{</span>
		<span class="nx">rs</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ok</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rs</span> <span class="o">*</span><span class="nx">Rows</span><span class="p">)</span> <span class="nf">Scan</span><span class="p">(</span><span class="nx">dest</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">rs</span><span class="p">.</span><span class="nx">closemu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">lasterr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">lasterr</span> <span class="o">!=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
		<span class="nx">rs</span><span class="p">.</span><span class="nx">closemu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
		<span class="k">return</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">lasterr</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">closed</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="o">:=</span> <span class="nx">rs</span><span class="p">.</span><span class="nf">lasterrOrErrLocked</span><span class="p">(</span><span class="nx">errRowsClosed</span><span class="p">)</span>
		<span class="nx">rs</span><span class="p">.</span><span class="nx">closemu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">rs</span><span class="p">.</span><span class="nx">closemu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">lastcols</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;sql: Scan called without calling Next&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dest</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rs</span><span class="p">.</span><span class="nx">lastcols</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;sql: expected %d destination arguments in Scan, not %d&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rs</span><span class="p">.</span><span class="nx">lastcols</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dest</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">sv</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">lastcols</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="o">:=</span> <span class="nf">convertAssignRows</span><span class="p">(</span><span class="nx">dest</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">sv</span><span class="p">,</span> <span class="nx">rs</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">`sql: Scan error on column index %d, name %q: %v`</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">rowsi</span><span class="p">.</span><span class="nf">Columns</span><span class="p">()[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>为此在 <a href="https://golang.org/doc/go1.10#database/sql/driver">Go 1.10 Release Notes</a> 中专门提到，驱动勿在 <code>rows.Close</code> 方法中修改缓冲区：</p>
<blockquote>
<p>Drivers that currently hold on to the destination buffer provided by driver.Rows.Next should ensure they no longer write to a buffer assigned to the destination array outside of that call. Drivers must be careful that underlying buffers are not modified when closing driver.Rows.</p>
</blockquote>
<p>为了避免在这种情况下发生数据竞争，<a href="https://github.com/go-sql-driver/mysql/pull/943">PR#943</a> 使用了双缓冲来冲刷缓冲区。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A buffer which is used for both reading and writing.
</span><span class="c1">// This is possible since communication on each connection is synchronous.
</span><span class="c1">// In other words, we can&#39;t write and read simultaneously on the same connection.
</span><span class="c1">// The buffer is similar to bufio.Reader / Writer but zero-copy-ish
</span><span class="c1">// Also highly optimized for this particular use case.
</span><span class="c1">// This buffer is backed by two byte slices in a double-buffering scheme
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">buffer</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">buf</span>     <span class="p">[]</span><span class="kt">byte</span> <span class="c1">// buf is a byte buffer who&#39;s length and capacity are equal.
</span><span class="c1"></span>	<span class="nx">nc</span>      <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span>
	<span class="nx">idx</span>     <span class="kt">int</span>
	<span class="nx">length</span>  <span class="kt">int</span>
	<span class="nx">timeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
	<span class="nx">dbuf</span>    <span class="p">[</span><span class="mi">2</span><span class="p">][]</span><span class="kt">byte</span> <span class="c1">// dbuf is an array with the two byte slices that back this buffer
</span><span class="c1"></span>	<span class="nx">flipcnt</span> <span class="kt">uint</span>      <span class="c1">// flipccnt is the current buffer counter for double-buffering
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// flip replaces the active buffer with the background buffer
</span><span class="c1">// this is a delayed flip that simply increases the buffer counter;
</span><span class="c1">// the actual flip will be performed the next time we call `buffer.fill`
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">buffer</span><span class="p">)</span> <span class="nf">flip</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">flipcnt</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="c1">// fill reads into the buffer until at least _need_ bytes are in it
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">buffer</span><span class="p">)</span> <span class="nf">fill</span><span class="p">(</span><span class="nx">need</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="c1">// fill data into its double-buffering target: if we&#39;ve called
</span><span class="c1"></span>	<span class="c1">// flip on this buffer, we&#39;ll be copying to the background buffer,
</span><span class="c1"></span>	<span class="c1">// and then filling it with network data; otherwise we&#39;ll just move
</span><span class="c1"></span>	<span class="c1">// the contents of the current buffer to the front before filling it
</span><span class="c1"></span>	<span class="nx">dest</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">dbuf</span><span class="p">[</span><span class="nx">b</span><span class="p">.</span><span class="nx">flipcnt</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">]</span>

	<span class="c1">// grow buffer if necessary to fit the whole packet.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">need</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dest</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// Round up to the next multiple of the default size
</span><span class="c1"></span>		<span class="nx">dest</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="p">((</span><span class="nx">need</span><span class="o">/</span><span class="nx">defaultBufSize</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nx">defaultBufSize</span><span class="p">)</span>

		<span class="c1">// if the allocated buffer is not too large, move it to backing storage
</span><span class="c1"></span>		<span class="c1">// to prevent extra allocations on applications that perform large reads
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dest</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nx">maxCachedBufSize</span> <span class="p">{</span>
			<span class="nx">b</span><span class="p">.</span><span class="nx">dbuf</span><span class="p">[</span><span class="nx">b</span><span class="p">.</span><span class="nx">flipcnt</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dest</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// if we&#39;re filling the fg buffer, move the existing data to the start of it.
</span><span class="c1"></span>	<span class="c1">// if we&#39;re filling the bg buffer, copy over the data
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">copy</span><span class="p">(</span><span class="nx">dest</span><span class="p">[:</span><span class="nx">n</span><span class="p">],</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">b</span><span class="p">.</span><span class="nx">idx</span><span class="p">:])</span>
	<span class="p">}</span>

	<span class="nx">b</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">dest</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">idx</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rows</span> <span class="o">*</span><span class="nx">mysqlRows</span><span class="p">)</span> <span class="nf">Close</span><span class="p">()</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="c1">// flip the buffer for this connection if we need to drain it.
</span><span class="c1"></span>	<span class="c1">// note that for a successful query (i.e. one where rows.next()
</span><span class="c1"></span>	<span class="c1">// has been called until it returns false), `rows.mc` will be nil
</span><span class="c1"></span>	<span class="c1">// by the time the user calls `(*Rows).Close`, so we won&#39;t reach this
</span><span class="c1"></span>	<span class="c1">// see: https://github.com/golang/go/commit/651ddbdb5056ded455f47f9c494c67b389622a47
</span><span class="c1"></span>    <span class="nx">mc</span><span class="p">.</span><span class="nx">buf</span><span class="p">.</span><span class="nf">flip</span><span class="p">()</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>当调用 <code>rows.Close</code> 时，交换 <code>fg buffer</code> 和 <code>bg buffer</code> 2个缓冲区，这样在冲刷缓冲区时用到的就是 <code>bg buffer</code> ，而 <code>rows.Scan</code> 读取的是旧的 <code>fg buffer</code>，从而避免了数据竞争。</p>]]></content>
		</item>
		
		<item>
			<title>关于Go Mysql Driver的unexpected EOF错误</title>
			<link>https://xiaopengli89.github.io/posts/go-mysql-driver-eof/</link>
			<pubDate>Sat, 23 May 2020 11:55:30 +0800</pubDate>
			
			<guid>https://xiaopengli89.github.io/posts/go-mysql-driver-eof/</guid>
			<description>&lt;p&gt;在使用 &lt;a href=&#34;https://pkg.go.dev/github.com/go-sql-driver/mysql?tab=doc&#34;&gt;github.com/go-sql-driver/mysql&lt;/a&gt; 作为客户端连接Mysql时，日志中偶然会出现下面的错误：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-none&#34; data-lang=&#34;none&#34;&gt;[mysql] 2019/08/26 16:07:00 packets.go:36: unexpected EOF
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/go-sql-driver/mysql?tab=doc&#34;&gt;github.com/go-sql-driver/mysql&lt;/a&gt; 为了复用TCP连接以提高性能，内部实现了连接池。当需要一次SQL操作时，会先从连接池中拿出一条可用的空闲连接去执行操作。如果没有空闲的连接，或者连接已经失效，就打开一条新的TCP连接、SSL认证（如果使用SSL连接的话）、协议握手、认证等，完成初始化连接，再使用这条连接执行操作，使用完后再放回连接池。连接失效的标记可以在上一次使用连接后根据对应的错误来完成，或者本次操作指令发送失败也标记为连接失效，driver会重新执行上面的步骤来进行重试，应用层不会感知。&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>在使用 <a href="https://pkg.go.dev/github.com/go-sql-driver/mysql?tab=doc">github.com/go-sql-driver/mysql</a> 作为客户端连接Mysql时，日志中偶然会出现下面的错误：</p>
<pre><code class="language-none" data-lang="none">[mysql] 2019/08/26 16:07:00 packets.go:36: unexpected EOF
</code></pre><p><a href="https://pkg.go.dev/github.com/go-sql-driver/mysql?tab=doc">github.com/go-sql-driver/mysql</a> 为了复用TCP连接以提高性能，内部实现了连接池。当需要一次SQL操作时，会先从连接池中拿出一条可用的空闲连接去执行操作。如果没有空闲的连接，或者连接已经失效，就打开一条新的TCP连接、SSL认证（如果使用SSL连接的话）、协议握手、认证等，完成初始化连接，再使用这条连接执行操作，使用完后再放回连接池。连接失效的标记可以在上一次使用连接后根据对应的错误来完成，或者本次操作指令发送失败也标记为连接失效，driver会重新执行上面的步骤来进行重试，应用层不会感知。</p>
<p>到这里，好像一切都没有什么问题，可是上面的错误是怎么回事？如果是连接失效的话，应该会进行重试，对应用透明。</p>
<p>其实上面的错误来源于服务器主动关闭超时连接造成的TCP半关闭状态，错误的形成原因可以用下面的图简单解释：</p>
<figure>
    <img src="/img/go-mysql-driver-eof.svg"/> <figcaption>
            <h4>TCP半连接状态</h4>
        </figcaption>
</figure>

<p>当需要重新打开一条Mysql连接时，先是完成基本的TCP连接握手，然后完成Mysql的协议握手、认证，之后就可以在这条连接上发送指令了。一次操作完成后，连接被放回连接池中，如果之后一段时间这条连接都没有被使用过，Mysql服务器会根据相应的配置，主动关闭这条连接。此时服务器内核会向客户端内核发送一个[FIN, ACK]的TCP段，客户端内核回应一个ACK段，此时这条TCP连接会进入半关闭状态：服务器不会再向客户端发送数据，但是客户端可以向服务器发送数据。</p>
<p>此时一个新的SQL操作从连接池中拿出了这条连接，发送指令，但是在读取的时候，客户端内核已经知道服务器不会再返回数据，因此直接给应用程序返回了EOF错误。然后重点是，此时的连接状态并不是真正意义上的无效连接状态，由于客户端已经把指令发送了出去，尤其如果是一条UPDATE指令的话，是无法执行安全的重试操作的。服务器对这条指令的处理，客户端是完全无法知晓的。</p>
<p>通常一种简单的解决办法是，设置客户端的空闲超时时间，并且短于服务器的空闲超时时间，然而 <a href="https://golang.org/pkg/database/sql/">database/sql</a> 并没有提供类似&quot;maximum idle duration&quot;的API，不过可以退一步使用 <a href="https://golang.org/pkg/database/sql/#DB.SetConnMaxLifetime">func (*DB) SetConnMaxLifetime</a> 这个API。然而带来的坏处就是，限制了连接的重用时间，即使连接一直处于活跃状态。</p>
<p>另一种办法是，每次从连接池中拿出连接，在发送第一条指令前发送一个 <code>PING</code> 包来检查连接是否健康，由于 <code>PING</code> 包不会产生副作用，因此后续的操作都是安全的。这种办法的坏处也显而易见，由于从连接池中取出连接是个非常频繁的操作，而每次都会增加至少一次RTT延迟。</p>
<p>好在 <a href="https://github.com/go-sql-driver/mysql/pull/934">PR#934</a> 通过非常巧妙的方式解决了这一问题。作者的解决思路如下：</p>
<p>首先需要提到一个Go 1.10后 <code>sql/driver</code> 增加的一个接口：<a href="https://golang.org/pkg/database/sql/driver/#SessionResetter">driver.SessionResetter</a> ，其中 <code>ResetSession</code> 方法会在每次连接放入连接池时执行，这里作者先简单地添加了一个 <code>reset</code> 标记。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">mysqlConn</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="nx">reset</span>            <span class="kt">bool</span> <span class="c1">// set when the Go SQL package calls ResetSession
</span><span class="c1"></span>    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// ResetSession implements driver.SessionResetter.
</span><span class="c1">// (From Go 1.10)
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">mc</span> <span class="o">*</span><span class="nx">mysqlConn</span><span class="p">)</span> <span class="nf">ResetSession</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">mc</span><span class="p">.</span><span class="nx">closed</span><span class="p">.</span><span class="nf">IsSet</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span>
    <span class="p">}</span>
    <span class="nx">mc</span><span class="p">.</span><span class="nx">reset</span> <span class="p">=</span> <span class="kc">true</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>之后连接被拿出来，在执行发送第一条指令前，会先根据之前添加的 <code>reset</code> 标记检查连接是否可用（liveness check），由于前面的标记是连接在放入连接池时加上的，因此可以做到只在第一次取出后检查（检查后把 <code>reset</code> 取消就行），后续在使用过程中无需再检查，除非再次被放回了连接池。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Write packet buffer &#39;data&#39;
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">mc</span> <span class="o">*</span><span class="nx">mysqlConn</span><span class="p">)</span> <span class="nf">writePacket</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="c1">// Perform a stale connection check. We only perform this check for
</span><span class="c1"></span> 	<span class="c1">// the first query on a connection that has been checked out of the
</span><span class="c1"></span> 	<span class="c1">// connection pool: a fresh connection from the pool is more likely
</span><span class="c1"></span> 	<span class="c1">// to be stale, and it has not performed any previous writes that
</span><span class="c1"></span> 	<span class="c1">// could cause data corruption, so it&#39;s safe to return ErrBadConn
</span><span class="c1"></span> 	<span class="c1">// if the check fails.
</span><span class="c1"></span> 	<span class="k">if</span> <span class="nx">mc</span><span class="p">.</span><span class="nx">reset</span> <span class="p">{</span>
 		<span class="nx">mc</span><span class="p">.</span><span class="nx">reset</span> <span class="p">=</span> <span class="kc">false</span>
 		<span class="nx">conn</span> <span class="o">:=</span> <span class="nx">mc</span><span class="p">.</span><span class="nx">netConn</span>
 		<span class="k">if</span> <span class="nx">mc</span><span class="p">.</span><span class="nx">rawConn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
 			<span class="nx">conn</span> <span class="p">=</span> <span class="nx">mc</span><span class="p">.</span><span class="nx">rawConn</span>
 		<span class="p">}</span>
 		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">connCheck</span><span class="p">(</span><span class="nx">conn</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
 			<span class="nx">errLog</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">&#34;closing bad idle connection: &#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
 			<span class="nx">mc</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
 			<span class="k">return</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span>
 		<span class="p">}</span>
     <span class="p">}</span>
     <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>而检查连接是否可用的方法用到了Go 1.9后 <code>net.Conn</code> 增加的 <code>syscall.Conn</code> 接口，这个接口可以获取原始连接的文件描述符。先调用 <code>syscall.Read</code> ，传入1个字节的缓冲区，由于还没有发送任何指令，并且由Go runtime创建的Socket都设置了非阻塞（O_NONBLOCK）模式，所以方法会立即返回。如果没有返回错误（或者 <code>EAGAIN</code> / <code>EWOULDBLOCK</code> 这2种错误）且读取的数据长度为0，则说明连接依然有效，反之连接已经失效。之所以不直接使用Go的原生接口 <code>net.Conn.Read</code> ，是因为Go的调度器会立即使当前Goroutine睡眠，导致多次Goroutine上下文切换，影响性能。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">connCheck</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
 	<span class="kd">var</span> <span class="p">(</span>
 		<span class="nx">n</span>    <span class="kt">int</span>
 		<span class="nx">err</span>  <span class="kt">error</span>
 		<span class="nx">buff</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="kt">byte</span>
 	<span class="p">)</span>

  	<span class="nx">sconn</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.(</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span>
 	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
 		<span class="k">return</span> <span class="kc">nil</span>
 	<span class="p">}</span>
 	<span class="nx">rc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sconn</span><span class="p">.</span><span class="nf">SyscallConn</span><span class="p">()</span>
 	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
 		<span class="k">return</span> <span class="nx">err</span>
 	<span class="p">}</span>
 	<span class="nx">rerr</span> <span class="o">:=</span> <span class="nx">rc</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">fd</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
 		<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">fd</span><span class="p">),</span> <span class="nx">buff</span><span class="p">[:])</span>
 		<span class="k">return</span> <span class="kc">true</span>
 	<span class="p">})</span>
 	<span class="k">switch</span> <span class="p">{</span>
 	<span class="k">case</span> <span class="nx">rerr</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">:</span>
 		<span class="k">return</span> <span class="nx">rerr</span>
 	<span class="k">case</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">:</span>
 		<span class="k">return</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span>
 	<span class="k">case</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">:</span>
 		<span class="k">return</span> <span class="nx">errUnexpectedRead</span>
 	<span class="k">case</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EAGAIN</span> <span class="o">||</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EWOULDBLOCK</span><span class="p">:</span>
 		<span class="k">return</span> <span class="kc">nil</span>
 	<span class="k">default</span><span class="p">:</span>
 		<span class="k">return</span> <span class="nx">err</span>
 	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>- 完</p>]]></content>
		</item>
		
		<item>
			<title>关于Socket应用的性能优化</title>
			<link>https://xiaopengli89.github.io/posts/socket-optimize/</link>
			<pubDate>Thu, 21 May 2020 21:58:01 +0800</pubDate>
			
			<guid>https://xiaopengli89.github.io/posts/socket-optimize/</guid>
			<description>&lt;p&gt;TCP/IP协议栈是计算机网络的基础通信架构，其中IP协议完成了跨链路的路由、寻址，TCP协议完成了面向连接的可靠字节流抽象，提供数据的分段、重传、重组，流量控制和拥塞控制，使得建立在TCP/IP协议之上的应用协议不用再关心各种硬件、网络环境，TCP/IP协议是今天的互联网的基石。&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>TCP/IP协议栈是计算机网络的基础通信架构，其中IP协议完成了跨链路的路由、寻址，TCP协议完成了面向连接的可靠字节流抽象，提供数据的分段、重传、重组，流量控制和拥塞控制，使得建立在TCP/IP协议之上的应用协议不用再关心各种硬件、网络环境，TCP/IP协议是今天的互联网的基石。</p>
<h1 id="网络套接字socket">网络套接字Socket</h1>
<p>Socket是操作系统用于网络编程的应用程序接口（API），可支持多种协议，现代常见的Socket套接字接口（Unix Socket、Windows Socket等）都源自Berkeley套接字<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。接口实现用于TCP/IP协议，因此它是维持Internet的基本技术之一。同时也被用于Unix域套接字（Unix domain sockets），可实现在单机上为进程间通讯（IPC）的接口。</p>
<p>不同的Socket应用程序除了满足最基本的通信需求外，也会有一些根据业务相关的特殊需求，本篇记录关于几个Linux下网络Socket应用的优化技巧：</p>
<h2 id="低延迟需求">低延迟需求</h2>
<p>由于TCP协议是面向字节流的协议，但是用于承载TCP的底层协议无法直接支持字节流，以太网协议需要一帧一帧地发送，一次发送的最大字节数受限于MTU；IP协议虽然支持数据的分包发送，但是大多数情况下我们需要避免IP协议分包，因为这会影响中间跳点的处理性能，所以TCP协议引入了分段（Segment）机制，在TCP层对数据进行拆分，保证IP数据包都是完整的。而通常情况下，我们希望每次发送的数据尽可能的多，也就是正好填满IP数据包，以此减少网络传输的次数（包括发送与接收方确认的次数），同时减少了总的包头数据量，以此提高整体的网络吞吐量。</p>
<p>Nagle算法实现了对数据的合并，该算法会把多个小的数据合并成一个完整的报文段，以此最大化报文段，减少在线路上传输报文的次数，但是同时也会带来延迟，因为写入缓冲区的数据并不会马上发送出去。在低延迟需求的应用中，可以禁用Nagle算法：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">net</span>::<span class="n">SocketAddr</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">socket2</span>::<span class="p">{</span><span class="n">Socket</span><span class="p">,</span><span class="w"> </span><span class="n">Domain</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">anyhow</span>::<span class="nb">Result</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">no_delay</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="c1">// create a TCP listener bound to two addresses
</span><span class="c1"></span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">socket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Socket</span>::<span class="n">new</span><span class="p">(</span><span class="n">Domain</span>::<span class="n">ipv4</span><span class="p">(),</span><span class="w"> </span><span class="n">Type</span>::<span class="n">stream</span><span class="p">(),</span><span class="w"> </span><span class="nb">None</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="n">socket</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="s">&#34;127.0.0.1:12345&#34;</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="n">SocketAddr</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">.</span><span class="n">into</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">  </span><span class="c1">// sets the value of the TCP_NODELAY option on this socket
</span><span class="c1"></span><span class="w">  </span><span class="n">socket</span><span class="p">.</span><span class="n">set_nodelay</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">  </span><span class="n">socket</span><span class="p">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">listener</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket</span><span class="p">.</span><span class="n">into_tcp_listener</span><span class="p">();</span><span class="w">
</span><span class="w">  </span><span class="c1">// ...
</span><span class="c1"></span><span class="w">  </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="减少系统调用">减少系统调用</h2>
<p>由于网络接口的调用属于系统调用，会跨越应用程序空间和内核空间的边界，导致应用程序空间和内核空间的上下文切换，因此在希望减少内核调用负载的场景中，可以在应用程序中尽可能使用能支持的最大缓冲区，这样可以最大化一次系统调用能发送或读取的数据量。</p>
<h2 id="增加内核缓冲区上限">增加内核缓冲区上限</h2>
<p>在<a href="/posts/dma/">DMA(直接内存访问)和零拷贝</a>中记录过大多数文件系统默认的IO操作都是缓存IO(Buffered I/O)，Socket接口同样如此，如果网络环境足够好，发送、接收双方的处理能力足够好的话，缓冲区的大小会成为网络通信的瓶颈（因为发送、接收窗口的上限就是内核Socket缓冲区大小）。现代的操作系统都可以动态地调整Socket缓冲区大小（如果你在接口调用里强制指定了缓冲区大小，那么内核就不会动态调整了，因此建议不要在接口调用的时候指定，因为网络环境会随时变化），但是会受一些内核参数的约束。在Linux中，发送、接收缓冲区的上限受以下内核参数的影响：</p>
<pre><code class="language-none" data-lang="none">net.core.wmem_max
net.core.rmem_max
</code></pre><p>一般这个上限的理想值是带宽时延积（Bandwidth Delay Product），取决于链路带宽和往返时延（RTT）。如果网络环境较好，你不想浪费你机器的内存，同时你的应用程序效率足够高的话，不妨增加内核缓冲区上限吧！</p>
<h2 id="利用以太网巨帧">利用以太网巨帧</h2>
<p>在之前提到，以太网协议需要一帧一帧的发送报文，原因在于信号在链路上传输过程中无法避免信号的丢失或错误，一旦有一个bit信号发生错误，那之后的信号就没有任何意义了。采用以太网帧的方式，可以将这种影响降低，一个以太网帧的错误，不影响其他以太网帧，如果要重传也只需要重传出错的以太网帧。越小的以太网帧，出错的几率越小，但是网络的吞吐量也越小；越大的以太网帧反过来，出错的几率越大，但是网络的吞吐量越大（包含了出错的无效帧）。因此链路上的每一个节点都有一个最大传输单元（MTU），用于限制传输的以太网帧大小，通常该值为1500。</p>
<p>但是MTU的大小多少最合适，要看所处的网络环境，带宽大小、网络拥堵情况、物理网络硬件性能等。如果是本地内部网络，拥有较好的网络环境，也就是链路信号出错的概率非常低，可以将MTU的值适当地调大，甚至是非常大（即以太网巨帧），可以有效地增加网络吞吐量。</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Berkeley套接字 - <a href="https://zh.wikipedia.org/wiki/Berkeley%E5%A5%97%E6%8E%A5%E5%AD%97">维基百科词条</a> <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>]]></content>
		</item>
		
		<item>
			<title>2Q(双链)缓存淘汰策略</title>
			<link>https://xiaopengli89.github.io/posts/two-queue/</link>
			<pubDate>Tue, 19 May 2020 00:00:00 +0000</pubDate>
			
			<guid>https://xiaopengli89.github.io/posts/two-queue/</guid>
			<description>&lt;p&gt;LRU(最近使用)算法经常用于缓存应用中，最简单的实现是通过一个链表实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;插入数据时向头节点插入&lt;/li&gt;
&lt;li&gt;更新数据时，移动节点到头节点&lt;/li&gt;
&lt;li&gt;淘汰数据时删除尾节点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是这个简单的实现并不能很好地应付很多场景，缓存的理想情况是预测未来数据的使用情况，尽可能的从缓存中读取数据，减少实际IO操作。&lt;/p&gt;
&lt;p&gt;今天的记录是关于1个LRU的变种算法：2Q(双链)，该算法在Linux页高速缓存回收中被应用。&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>LRU(最近使用)算法经常用于缓存应用中，最简单的实现是通过一个链表实现：</p>
<ol>
<li>插入数据时向头节点插入</li>
<li>更新数据时，移动节点到头节点</li>
<li>淘汰数据时删除尾节点</li>
</ol>
<p>但是这个简单的实现并不能很好地应付很多场景，缓存的理想情况是预测未来数据的使用情况，尽可能的从缓存中读取数据，减少实际IO操作。</p>
<p>今天的记录是关于1个LRU的变种算法：2Q(双链)，该算法在Linux页高速缓存回收中被应用。</p>
<h1 id="2q双链">2Q(双链)</h1>
<p>原始LRU算法描述的是数据使用的最近时间点，越靠近头节点的数据使用的时间点越近，但是没有描述数据使用的频率，像对于数据库的遍历操作，新数据会立即将缓存中的所有数据淘汰，但是遍历完后，缓存中的数据在之后使用的概率非常低，即缓存污染。</p>
<p>2Q淘汰算法是便是对以上情况的一种优化，淘汰策略是使用2个队列实现，1个FIFO队列记录只访问了一次的数据，1个普通LRU队列记录访问了2次以上的数据。</p>
<ol>
<li>当第1次访问时，将数据添加到FIFO队列，如果FIFO队列超过限制，淘汰FIFO里最旧的数据</li>
<li>当第2次访问时，将数据从FIFO队列移动到LRU队列的头节点，如果LRU队列超过限制，将LRU里最旧的数据移动到FIFO队列的头节点</li>
<li>当第3次以上访问时，按照LRU规则更新LRU队列</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ptr</span>::<span class="n">NonNull</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Debug</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Debug</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="k">pub</span><span class="w"> </span><span class="n">val</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="k">pub</span><span class="w"> </span><span class="n">prev</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NonNull</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="k">pub</span><span class="w"> </span><span class="n">next</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NonNull</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">List</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Debug</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="k">pub</span><span class="w"> </span><span class="n">head</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NonNull</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="k">pub</span><span class="w"> </span><span class="n">tail</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NonNull</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="k">pub</span><span class="w"> </span><span class="n">len</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Debug</span><span class="o">&gt;</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="n">head</span>: <span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">			</span><span class="n">tail</span>: <span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">			</span><span class="n">len</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">	</span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">push_front</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">val</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="kd">let</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="n">val</span><span class="p">,</span><span class="w">
</span><span class="w">			</span><span class="n">prev</span>: <span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">			</span><span class="n">next</span>: <span class="nc">self</span><span class="p">.</span><span class="n">head</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="p">});</span><span class="w">
</span><span class="w">		</span><span class="kd">let</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NonNull</span>::<span class="n">new</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">into_raw</span><span class="p">(</span><span class="n">node</span><span class="p">));</span><span class="w">
</span><span class="w">		
</span><span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">old_head</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">				</span><span class="n">old_head</span><span class="p">.</span><span class="n">as_mut</span><span class="p">().</span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="p">;</span><span class="w">
</span><span class="w">			</span><span class="p">}</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="p">;</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w">
</span><span class="w">		</span><span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="p">;</span><span class="w">
</span><span class="w">		</span><span class="bp">self</span><span class="p">.</span><span class="n">len</span><span class="w"> </span><span class="o">+=</span><span class="w">  </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">	</span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">push_front_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">node</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="kd">let</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">node</span><span class="p">);</span><span class="w">
</span><span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">old_head</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">				</span><span class="n">old_head</span><span class="p">.</span><span class="n">as_mut</span><span class="p">().</span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="p">;</span><span class="w">
</span><span class="w">			</span><span class="p">}</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="p">;</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w">
</span><span class="w">		</span><span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="p">;</span><span class="w">
</span><span class="w">		</span><span class="bp">self</span><span class="p">.</span><span class="n">len</span><span class="w"> </span><span class="o">+=</span><span class="w">  </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">	</span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">pop_back</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NonNull</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">old_tail</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">				</span><span class="kd">let</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old_tail</span><span class="p">.</span><span class="n">as_mut</span><span class="p">().</span><span class="n">prev</span><span class="p">;</span><span class="w">
</span><span class="w">				</span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">tail</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">					</span><span class="n">tail</span><span class="p">.</span><span class="n">as_mut</span><span class="p">().</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span><span class="w">	
</span><span class="w">				</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">					</span><span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span><span class="w">
</span><span class="w">				</span><span class="p">}</span><span class="w">
</span><span class="w">				</span><span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span><span class="w">
</span><span class="w">				</span><span class="bp">self</span><span class="p">.</span><span class="n">len</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">				</span><span class="k">return</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">old_tail</span><span class="p">);</span><span class="w">
</span><span class="w">			</span><span class="p">}</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w">
</span><span class="w">		</span><span class="nb">None</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">	</span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">print</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">as_ref</span><span class="p">();</span><span class="w">
</span><span class="w">		</span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cur</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">				</span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">as_ref</span><span class="p">();</span><span class="w">
</span><span class="w">				</span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">val</span><span class="p">);</span><span class="w">
</span><span class="w">				</span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">as_ref</span><span class="p">();</span><span class="w">
</span><span class="w">			</span><span class="p">}</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">TwoQueue</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">fifo</span>: <span class="nc">List</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">fifo_limit</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">lru</span>: <span class="nc">List</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">lru_limit</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">TwoQueue</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">fifo_limit</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">lru_limit</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="n">fifo</span>: <span class="nc">List</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">			</span><span class="n">fifo_limit</span><span class="p">,</span><span class="w">
</span><span class="w">			</span><span class="n">lru</span>: <span class="nc">List</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">			</span><span class="n">lru_limit</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w">	
</span><span class="w">	</span><span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">key</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">find_in_lru</span><span class="p">(</span><span class="n">key</span><span class="p">);</span><span class="w">
</span><span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">is_some</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w">
</span><span class="w">		</span><span class="bp">self</span><span class="p">.</span><span class="n">find_in_fifo</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">	</span><span class="k">fn</span> <span class="nf">find_in_fifo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">key</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">fifo</span><span class="p">.</span><span class="n">head</span><span class="p">;</span><span class="w">
</span><span class="w">		</span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">c0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cur</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">				</span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="n">c0</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">();</span><span class="w">			
</span><span class="w">				</span><span class="k">if</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">val</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">					</span><span class="c1">// 取下
</span><span class="c1"></span><span class="w">					</span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">prev</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">						</span><span class="n">p</span><span class="p">.</span><span class="n">as_mut</span><span class="p">().</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">next</span><span class="p">;</span><span class="w">
</span><span class="w">					</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">						</span><span class="bp">self</span><span class="p">.</span><span class="n">fifo</span><span class="p">.</span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">next</span><span class="p">;</span><span class="w">
</span><span class="w">					</span><span class="p">}</span><span class="w">
</span><span class="w">					</span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">next</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">						</span><span class="n">n</span><span class="p">.</span><span class="n">as_mut</span><span class="p">().</span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span><span class="w">
</span><span class="w">					</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">						</span><span class="bp">self</span><span class="p">.</span><span class="n">fifo</span><span class="p">.</span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span><span class="w">
</span><span class="w">					</span><span class="p">}</span><span class="w">
</span><span class="w">					</span><span class="bp">self</span><span class="p">.</span><span class="n">fifo</span><span class="p">.</span><span class="n">len</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">					</span><span class="c1">// 移动到lru队列
</span><span class="c1"></span><span class="w">					</span><span class="bp">self</span><span class="p">.</span><span class="n">lru</span><span class="p">.</span><span class="n">push_front_node</span><span class="p">(</span><span class="n">c0</span><span class="p">);</span><span class="w">
</span><span class="w">					</span><span class="c1">// 检查lru是否满
</span><span class="c1"></span><span class="w">					</span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">lru</span><span class="p">.</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">lru_limit</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">						</span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">node_from_lru</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">lru</span><span class="p">.</span><span class="n">pop_back</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">							</span><span class="bp">self</span><span class="p">.</span><span class="n">fifo</span><span class="p">.</span><span class="n">push_front_node</span><span class="p">(</span><span class="n">node_from_lru</span><span class="p">);</span><span class="w">
</span><span class="w">						</span><span class="p">}</span><span class="w">
</span><span class="w">					</span><span class="p">}</span><span class="w">
</span><span class="w">					</span><span class="c1">// 返回
</span><span class="c1"></span><span class="w">					</span><span class="k">return</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">val</span><span class="p">.</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">				</span><span class="p">}</span><span class="w">
</span><span class="w">				</span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">next</span><span class="p">;</span><span class="w">
</span><span class="w">			</span><span class="p">}</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w">
</span><span class="w">		</span><span class="nb">None</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">	</span><span class="k">fn</span> <span class="nf">find_in_lru</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">key</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">lru</span><span class="p">.</span><span class="n">head</span><span class="p">;</span><span class="w">
</span><span class="w">		</span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">c0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cur</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">				</span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="n">c0</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">();</span><span class="w">
</span><span class="w">				</span><span class="k">if</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">val</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">					</span><span class="c1">// 取下
</span><span class="c1"></span><span class="w">					</span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">prev</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">						</span><span class="n">p</span><span class="p">.</span><span class="n">as_mut</span><span class="p">().</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">next</span><span class="p">;</span><span class="w">
</span><span class="w">					</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">						</span><span class="bp">self</span><span class="p">.</span><span class="n">lru</span><span class="p">.</span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">next</span><span class="p">;</span><span class="w">
</span><span class="w">					</span><span class="p">}</span><span class="w">
</span><span class="w">					</span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">next</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">						</span><span class="n">n</span><span class="p">.</span><span class="n">as_mut</span><span class="p">().</span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span><span class="w">
</span><span class="w">					</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">						</span><span class="bp">self</span><span class="p">.</span><span class="n">lru</span><span class="p">.</span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span><span class="w">
</span><span class="w">					</span><span class="p">}</span><span class="w">
</span><span class="w">					</span><span class="c1">// 移动至头节点
</span><span class="c1"></span><span class="w">					</span><span class="n">c</span><span class="p">.</span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span><span class="w">
</span><span class="w">					</span><span class="n">c</span><span class="p">.</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">lru</span><span class="p">.</span><span class="n">head</span><span class="p">;</span><span class="w">
</span><span class="w">					</span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">lru</span><span class="p">.</span><span class="n">head</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">						</span><span class="n">h</span><span class="p">.</span><span class="n">as_mut</span><span class="p">().</span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">c0</span><span class="p">);</span><span class="w">
</span><span class="w">					</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">						</span><span class="bp">self</span><span class="p">.</span><span class="n">lru</span><span class="p">.</span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">c0</span><span class="p">);</span><span class="w">
</span><span class="w">					</span><span class="p">}</span><span class="w">
</span><span class="w">					</span><span class="bp">self</span><span class="p">.</span><span class="n">lru</span><span class="p">.</span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">c0</span><span class="p">);</span><span class="w">
</span><span class="w">					</span><span class="c1">// 返回
</span><span class="c1"></span><span class="w">					</span><span class="k">return</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">val</span><span class="p">.</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">				</span><span class="p">}</span><span class="w">
</span><span class="w">				</span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">next</span><span class="p">;</span><span class="w">
</span><span class="w">			</span><span class="p">}</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w">
</span><span class="w">		</span><span class="nb">None</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">	</span><span class="k">fn</span> <span class="nf">put</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">key</span>: <span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">val</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="bp">self</span><span class="p">.</span><span class="n">fifo</span><span class="p">.</span><span class="n">push_front</span><span class="p">((</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">));</span><span class="w">
</span><span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">fifo</span><span class="p">.</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">fifo_limit</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">			</span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">fifo</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span><span class="w">
</span><span class="w">		</span><span class="p">}</span><span class="w">
</span><span class="w">	</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">two_queue</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">tq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TwoQueue</span>::<span class="n">new</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="n">tq</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="s">&#34;a&#34;</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="n">tq</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="s">&#34;b&#34;</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="n">tq</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="s">&#34;c&#34;</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="n">tq</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="s">&#34;d&#34;</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="n">tq</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#34;b&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;fifo&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="n">tq</span><span class="p">.</span><span class="n">fifo</span><span class="p">.</span><span class="n">print</span><span class="p">();</span><span class="w">
</span><span class="w">	</span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;lru&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">	</span><span class="n">tq</span><span class="p">.</span><span class="n">lru</span><span class="p">.</span><span class="n">print</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>- 完</p>]]></content>
		</item>
		
		<item>
			<title>Linux进程调度与定时器</title>
			<link>https://xiaopengli89.github.io/posts/sched-and-timer/</link>
			<pubDate>Sun, 17 May 2020 20:14:50 +0800</pubDate>
			
			<guid>https://xiaopengli89.github.io/posts/sched-and-timer/</guid>
			<description>&lt;p&gt;由于Linux是属于抢占式(preemptoin)多任务(multitasking)分时操作系统，因此进程的调度同定时器必然存在联系，本篇日志是记录Linux进程调度与定时器的关系。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux与Microsoft Windows等操作系统不同，并没有单独的线程机制，一组线程仅仅是共享了虚拟内存地址空间、打开的文件等资源的进程。&lt;/p&gt;
&lt;/blockquote&gt;</description>
			<content type="html"><![CDATA[<p>由于Linux是属于抢占式(preemptoin)多任务(multitasking)分时操作系统，因此进程的调度同定时器必然存在联系，本篇日志是记录Linux进程调度与定时器的关系。</p>
<blockquote>
<p>Linux与Microsoft Windows等操作系统不同，并没有单独的线程机制，一组线程仅仅是共享了虚拟内存地址空间、打开的文件等资源的进程。</p>
</blockquote>
<h1 id="linux进程调度">Linux进程调度</h1>
<p>操作系统的一个重要职责是将有限的资源通过特定的机制分配给多个用户使用，这里的资源包括CPU、内存、IO等，用户既可以指操作计算机的人，而人是给计算机下达任务的，因此更宽泛地指任务，也就是进程。</p>
<p>由于实际场景中，进程的数量是大于CPU处理器数量，多任务就是指同时并发地让进程交替使用CPU资源，让进程产生自己独占CPU的错觉，虚拟内存也是同理。</p>
<p>抢占(preemptoin)就是指不需要经过进程主动出让，内核调度器可以强制让进程让出CPU资源，然后去执行其他进程。</p>
<blockquote>
<p>与抢占式多任务相对应的，叫做协作式(cooperative)多任务，Go的goroutine便是一个应用范例。</p>
</blockquote>
<p>由于本篇日志的主题是进程调度与定时器的关系，所以抢占(preemptoin)便是这里的切入点。</p>
<p>由于进程正在执行代码，内核如果要去执行抢占操作，比如执行 schedule()，那必然需要去执行内核代码，而这里触发执行内核代码的其中之一，便是定时器中断。</p>
<p>不论是最早的Unix调度算法，2.5内核版本的O(1)调度算法，以及2.6之后出现的CFS完全公平调度算法，其中计算进程已经消耗的时间片(timeslice)都依赖于计算机的时间概念，而计算机的时间概念也是通过定时器实现的。</p>
<h1 id="定时器">定时器</h1>
<p>系统定时器是一种可编程硬件芯片，它能以固定的频率产生中断，这就是定时器中断。如果该中断信号没有被屏蔽，CPU便会去执行对应的中断处理程序，就可以去执行一些需要定时执行的代码，包括：</p>
<ol>
<li>更新系统运行的时间</li>
<li>更新实际时间</li>
<li>在SMP(对称多处理器)系统上，均衡各个处理器上的运行队列</li>
<li>检查当前进程是否用尽了时间片，如果用尽了则重新调度</li>
<li>运行已经超时的动态定时器</li>
<li>更新资源消耗、处理器时间的统计信息</li>
</ol>
<p>系统在启动时，便会根据系统定时器的节拍率设置硬件。在x86体系结构中，系统定时器的默认节拍率是100HZ，也就是说每秒会触发100次定时器中断。该值可以自定义，越高产生中断的频率就越高，时钟中断的解析度也越高，像poll()和select()等系统调用的精度也越高，同理进程消耗的时间片计算和调度时机也更精确。</p>
<p>但是高节拍率也会带来副作用，意味着执行定时器中断处理程序的次数更多，这不但减少了执行其他任务的时间，同时还会打乱处理器的高速缓存（高速缓存依赖于空间和时间局部性）和增加耗电。</p>]]></content>
		</item>
		
		<item>
			<title>DMA(直接内存访问)和零拷贝</title>
			<link>https://xiaopengli89.github.io/posts/dma/</link>
			<pubDate>Sat, 16 May 2020 18:02:00 +0800</pubDate>
			
			<guid>https://xiaopengli89.github.io/posts/dma/</guid>
			<description>&lt;blockquote&gt;
&lt;p&gt;许多设备都可以临时控制总线。这些设备可以执行涉及主内存和其他设备的数据传送。由于设备执行这些操作的过程中无需借助于 CPU，因此该类型的数据传送称为直接内存访问 (direct memory access, DMA)。&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大多数文件系统默认的IO操作都是缓存IO(Buffered I/O)，对于读(Read)操作，即IO设备先把数据发送到内核缓存区(Page Cache)，内核再将数据拷贝到应用程序地址空间的数据缓存区，而对于写(Write)操作，即反过来，从应用程序地址空间的数据缓存区拷贝到内核缓存区，内核再将数据发送到IO设备。&lt;/p&gt;</description>
			<content type="html"><![CDATA[<blockquote>
<p>许多设备都可以临时控制总线。这些设备可以执行涉及主内存和其他设备的数据传送。由于设备执行这些操作的过程中无需借助于 CPU，因此该类型的数据传送称为直接内存访问 (direct memory access, DMA)。<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
</blockquote>
<p>大多数文件系统默认的IO操作都是缓存IO(Buffered I/O)，对于读(Read)操作，即IO设备先把数据发送到内核缓存区(Page Cache)，内核再将数据拷贝到应用程序地址空间的数据缓存区，而对于写(Write)操作，即反过来，从应用程序地址空间的数据缓存区拷贝到内核缓存区，内核再将数据发送到IO设备。</p>
<p>缓存IO的优势：</p>
<ol>
<li>可以利用内核缓存，如果数据已经在页缓存内，则不需要再读取IO设备，直接返回页缓存中的数据</li>
<li>对于写操作，应用程序只需要将数据拷贝到内核缓冲区即可返回，接下来应用程序缓冲区可以再次使用，而不需要等内核将数据写到IO设备(依赖于应用程序采用的写操作机制)。在一些场景下，比如应用程序每次只写1Byte，缓存IO可以将多次的写操作合并成一次IO写操作，有效地减少了IO操作次数，从而提供系统性能</li>
</ol>
<p>缓存IO的劣势：</p>
<ol>
<li>数据从IO设备到应用程序地址空间需要经过内核缓冲区的中转，也就是拷贝操作，这些拷贝操作会消耗CPU，增加了系统负载。在某些场景下，比如网络文件服务，数据到达应用程序缓冲区后，又会原样的再次拷贝到内核缓冲区以发送到IO设备，这里的中转次数又增加了一倍</li>
<li>用于中转的缓冲区，不论是应用程序地址空间，还是内核空间，都会占用内存，加大了空间消耗</li>
</ol>
<h1 id="零拷贝">零拷贝</h1>
<p>在一些场景下，我们需要减少数据拷贝的次数，以提高系统性能，零拷贝技术便是用来解决这个问题。在Linux操作系统中，有以下几种方式来实现零拷贝：</p>
<h4 id="内存映射mmap">内存映射（mmap)</h4>
<p>mmap机制是先将数据从IO设备读取到内核缓冲区，然后通过应用程序地址空间和内核共享该内核缓冲区，这样就不需要拷贝了。</p>
<p>但是这里也会带来一次虚拟存储操作，而虚拟存储操作需要修改页表以及冲刷TLB(translate lookaside buffer，翻译后缓冲器)来维持存储的一致性，这里的开销也不小，但是如果传输的数据较大，那还是值得的。</p>
<h4 id="sendfile">sendfile</h4>
<p>mmap会有虚拟转储开销，同时如果是发送网络数据的话，还需要把数据从内核缓冲区发送到socket缓冲区，最后发送到协议引擎中去，这里还是会有拷贝操作(内核拷贝)。sendfile机制可以再进一步的减少拷贝次数，同时避免虚拟转储操作。</p>
<p>sendfile利用DMA引擎将数据拷贝到内核缓冲区中，然后将带有文件位置和长度信息的缓冲区描述符添加到socket缓冲区中(这里不需要拷贝完整的数据)，DMA引擎将直接从内核缓冲区拷贝到协议引擎中去，这里避免了内核缓冲区到socket缓冲区的拷贝，同时没有映射内存。</p>
<h1 id="dma直接内存访问">DMA（直接内存访问）</h1>
<p>前面提到了零拷贝技术中应用了DMA，可以跳过应用程序地址空间的中转，但是如果应用需要读取或修改数据呢？这时DMA也可以跳过内核缓冲区，实现数据从IO设备到用户地址空间的直接数据交换。</p>
<p>像数据库管理系统，希望自己管理页缓存，因为数据库知道自己存储的是什么数据，该如何换页等等。比如在提交事务时，需要redo log写入磁盘，才算事务提交完成，而buffer pool中的脏页并不需要立即写入磁盘，可以在换页时或者定时写入；在换页的时候，决定哪些页需要从buffer pool中换出，需要根据数据库自己的机制判断，依赖操作系统的换页机制将大大降低数据库系统的性能。</p>
<p>当然并不是所有地址空间都支持DMA，受限与硬件，在Linux中，只有ZONE_DMA区的内存可支持DMA操作，详情可参考Linux内存管理。</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>第 9 章 直接内存访问 (Direct Memory Access, DMA) - <a href="https://docs.oracle.com/cd/E19253-01/819-7057/dma-29901/index.html">docs.oracle.com</a> <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>]]></content>
		</item>
		
	</channel>
</rss>
