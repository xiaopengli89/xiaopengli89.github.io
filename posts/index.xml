<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Torigoth</title>
		<link>/posts/</link>
		<description>Recent content in Posts on Torigoth</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Fri, 10 Jul 2020 19:23:16 +0800</lastBuildDate>
		<atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>å®ç°ä¸€ä¸ªæ— ä¾èµ–çš„Rustå¼‚æ­¥è¿è¡Œæ—¶</title>
			<link>/posts/plain-rt/</link>
			<pubDate>Fri, 10 Jul 2020 19:23:16 +0800</pubDate>
			
			<guid>/posts/plain-rt/</guid>
			<description>&lt;p&gt;è¿™ç¯‡æ–‡ç« å°†éå¸¸ç›´è§‚ã€æ˜“æ‡‚åœ°è§£é‡ŠRustå¼‚æ­¥è¿è¡Œæ—¶çš„å®ç°ã€‚ä»£ç ä¸è¶…è¿‡300è¡Œï¼Œåªä¾èµ–æ ‡å‡†åº“ï¼Œæ”¯æŒ &lt;code&gt;spawn&lt;/code&gt; å¤šä¸ª &lt;code&gt;Task&lt;/code&gt; å¹¶å‘æ‰§è¡Œã€‚&lt;/p&gt;
&lt;p&gt;é¦–å…ˆï¼ŒRustæ ‡å‡†åº“å¯¹å¼‚æ­¥çš„æŠ½è±¡ä¸»è¦é›†ä¸­äºå‡ ä¸ªç±»å‹ï¼Œåˆ†åˆ«æ˜¯ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Future&lt;/code&gt; - å¯¹äºä¸€ä¸ªå¼‚æ­¥æ“ä½œçš„æŠ½è±¡ï¼Œä»£è¡¨ä¸€ä¸ªæœªæ¥äº‹ä»¶ï¼Œå¦‚æœäº‹ä»¶æœªå°±ç»ªï¼Œåº”æš‚åœå½“å‰ &lt;code&gt;Task&lt;/code&gt;ï¼ˆå¯ä»¥å»æ‰§è¡Œå…¶ä»– &lt;code&gt;Task&lt;/code&gt;ï¼‰ï¼Œäº‹ä»¶å°±ç»ªåï¼Œæ¢å¤æ‰§è¡Œ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Waker&lt;/code&gt; - å”¤é†’å™¨ï¼Œå½“äº‹ä»¶å°±ç»ªåï¼Œé€šçŸ¥è¿è¡Œæ—¶é‡æ–°è°ƒåº¦å’Œè¿™ä¸ª &lt;code&gt;Waker&lt;/code&gt; ç»‘å®šçš„ &lt;code&gt;Task&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pin&lt;/code&gt; - å›ºå®šå¯¹è±¡ï¼Œæ˜¯ä¸ºäº†è§£å†³ç”Ÿæˆå™¨çŠ¶æ€æœºçš„è‡ªå¼•ç”¨é—®é¢˜&lt;/li&gt;
&lt;/ul&gt;</description>
			<content type="html"><![CDATA[<p>è¿™ç¯‡æ–‡ç« å°†éå¸¸ç›´è§‚ã€æ˜“æ‡‚åœ°è§£é‡ŠRustå¼‚æ­¥è¿è¡Œæ—¶çš„å®ç°ã€‚ä»£ç ä¸è¶…è¿‡300è¡Œï¼Œåªä¾èµ–æ ‡å‡†åº“ï¼Œæ”¯æŒ <code>spawn</code> å¤šä¸ª <code>Task</code> å¹¶å‘æ‰§è¡Œã€‚</p>
<p>é¦–å…ˆï¼ŒRustæ ‡å‡†åº“å¯¹å¼‚æ­¥çš„æŠ½è±¡ä¸»è¦é›†ä¸­äºå‡ ä¸ªç±»å‹ï¼Œåˆ†åˆ«æ˜¯ï¼š</p>
<ul>
<li><code>Future</code> - å¯¹äºä¸€ä¸ªå¼‚æ­¥æ“ä½œçš„æŠ½è±¡ï¼Œä»£è¡¨ä¸€ä¸ªæœªæ¥äº‹ä»¶ï¼Œå¦‚æœäº‹ä»¶æœªå°±ç»ªï¼Œåº”æš‚åœå½“å‰ <code>Task</code>ï¼ˆå¯ä»¥å»æ‰§è¡Œå…¶ä»– <code>Task</code>ï¼‰ï¼Œäº‹ä»¶å°±ç»ªåï¼Œæ¢å¤æ‰§è¡Œ</li>
<li><code>Waker</code> - å”¤é†’å™¨ï¼Œå½“äº‹ä»¶å°±ç»ªåï¼Œé€šçŸ¥è¿è¡Œæ—¶é‡æ–°è°ƒåº¦å’Œè¿™ä¸ª <code>Waker</code> ç»‘å®šçš„ <code>Task</code></li>
<li><code>Pin</code> - å›ºå®šå¯¹è±¡ï¼Œæ˜¯ä¸ºäº†è§£å†³ç”Ÿæˆå™¨çŠ¶æ€æœºçš„è‡ªå¼•ç”¨é—®é¢˜</li>
</ul>
<h3 id="ä¸ºä»€ä¹ˆrustçš„å¼‚æ­¥è¦è¿™æ ·è®¾è®¡">ä¸ºä»€ä¹ˆRustçš„å¼‚æ­¥è¦è¿™æ ·è®¾è®¡ï¼Ÿ</h3>
<p>è¦è®¨è®ºè¿™ä¸ªé—®é¢˜ï¼Œéœ€è¦å…ˆå°±å…¶ä»–ç”Ÿæ€é¢†åŸŸå†…çš„å¼‚æ­¥æ¨¡å‹è®¾è®¡åšä¸€äº›æ¯”è¾ƒã€‚</p>
<p>æœ€ä¸ºäººæ‰€ç†ŸçŸ¥æˆ‘æƒ³åº”è¯¥å°±æ˜¯ <code>Javascript</code> äº†ï¼Œæœ€åˆ <code>Javascript</code> æ˜¯è¢«è®¾è®¡ç”¨äºåœ¨æµè§ˆå™¨å†…æ‰§è¡Œè„šæœ¬ä»£ç ï¼Œå¹¶ä¸”å‡ºäºä½¿ç”¨ç®€å•ï¼Œé‡‡ç”¨äº†å•çº¿ç¨‹æ¨¡å‹ï¼ˆå¥½å¤„å¯ä»¥å‚è€ƒ <code>Redis</code>ï¼‰ã€‚å¯æ˜¯ç”¨æˆ·çš„ä»£ç æ‰§è¡Œæµå¹¶ä¸ä¸€å®šæ˜¯çº¿æ€§çš„ï¼Œæ¯”å¦‚ç‚¹å‡»æŒ‰é’®ï¼Œéœ€è¦åŸºäºäº‹ä»¶ä½œå‡ºå“åº”ã€‚ä¸ºæ­¤è®¾è®¡å‡ºäº†äº‹ä»¶å¾ªç¯ï¼Œè€Œå“åº”å‡½æ•°åˆ™åˆ©ç”¨å›è°ƒçš„æ–¹å¼æ³¨å†Œåˆ°äº‹ä»¶å¾ªç¯ä¸Šï¼Œå½“äº‹ä»¶è¢«è§¦å‘æ—¶ï¼Œå›è°ƒå‡½æ•°è¢«è§¦å‘æ‰§è¡Œï¼ˆéœ€è¦æŒ‡å‡ºçš„æ˜¯ï¼Œå›è°ƒå‡½æ•°çš„æ‰§è¡Œä¹Ÿæ˜¯åœ¨å…¨å±€çš„å•ä¸€çº¿ç¨‹ä¸­ï¼Œè¿™ä¹Ÿå¯¼è‡´å¦‚æœåœ¨ä»£ç ä¸­æœ‰é˜»å¡æ“ä½œï¼Œå›è°ƒå‡½æ•°çš„æ‰§è¡Œä¹Ÿä¼šè¢«æ¨è¿Ÿï¼‰ã€‚</p>
<p>ç„¶åå°±æ˜¯è¢« <code>Go</code> å‘æ‰¬å…‰å¤§çš„è½»é‡çº§çº¿ç¨‹äº†ã€‚å¼‚æ­¥çš„å‡ºç°æ˜¯ä¼´éšç€çº¿ç¨‹çš„å¤ç”¨è€Œå‡ºç°çš„ï¼Œåƒ <code>Javascript</code> çš„å•çº¿ç¨‹å›è°ƒæ¨¡å‹ä¹Ÿæ˜¯åœ¨å¤ç”¨å…¨å±€çš„ä¸»çº¿ç¨‹ã€‚è€Œ <code>Go</code> åˆ™é€šè¿‡åœ¨ç”¨æˆ·ç©ºé—´å®ç°æ–°çš„çº¿ç¨‹ï¼Œè¿™äº›ç”¨æˆ·ç©ºé—´çš„æ–°çº¿ç¨‹å†å¤ç”¨åº•å±‚çš„æ“ä½œç³»ç»Ÿçº¿ç¨‹ï¼Œé‡åˆ°é˜»å¡è°ƒç”¨æ—¶ï¼Œé‡æ–°è°ƒåº¦ç”¨æˆ·ç©ºé—´çš„çº¿ç¨‹ï¼Œç”±äºè°ƒåº¦è¿™äº›çº¿ç¨‹ä¸éœ€è¦æ ¸å†…å¤–çš„åˆ‡æ¢ï¼Œåˆ›å»ºã€ç»´æŒã€é”€æ¯çš„å¼€é”€ä¹Ÿè¿œå°äºæ“ä½œç³»ç»Ÿçº¿ç¨‹ï¼Œå¯ä»¥å¤§é‡åœ°åˆ›å»ºï¼Œå› æ­¤å¸¸è¢«ç§°ä¸ºè½»é‡çº§çº¿ç¨‹ã€‚</p>
<p>åœ¨è®¨è®º <code>Rust</code> çš„å¼‚æ­¥æ¨¡å‹å‰ï¼Œé¦–å…ˆéœ€è¦å£°æ˜çš„æ˜¯ï¼Œç±»ä¼¼çš„å¼‚æ­¥æ¨¡å‹å·²ç»å­˜åœ¨äºå…¶ä»–ç”Ÿæ€é¢†åŸŸï¼Œæ¯”å¦‚ <code>ES2017</code> ã€<code>Python</code> å’Œ <code>.NET</code>ï¼Œå› æ­¤å¯ä»¥è¯´ <code>Rust</code> ä»å®ƒä»¬èº«ä¸Šå€Ÿé‰´äº†è®¸å¤šï¼Œç”šè‡³åœ¨æ–°ç‰ˆæœ¬çš„ <a href="https://github.com/tokio-rs/tokio">tokio</a> ã€ <a href="https://github.com/async-rs/async-std">async-std</a> å’Œ <a href="https://github.com/stjepang/smol">smol</a> 3ä¸ªä¸»æµ <code>Rust</code> å¼‚æ­¥è¿è¡Œæ—¶èº«ä¸Šè¿˜èƒ½çœ‹åˆ° <code>Go</code> çš„å½±å­ã€‚</p>
<p><code>Rust</code> çš„å¼‚æ­¥æ¨¡å‹åŒæ—¶å€Ÿé‰´äº†è½»é‡çº§çº¿ç¨‹å’Œå›è°ƒã€‚</p>
<p>ä»è½»é‡çº§çº¿ç¨‹çœ‹ï¼Œ<code>Rust</code> æ ‡å‡†åº“å†…çš„ <code>Future</code> å¯ä»¥å˜ç›¸åœ°çœ‹æˆä¸€ç§â€œçº¿ç¨‹â€ï¼Œæˆ‘ä»¬ä¹ æƒ¯ç§°å…¶ä¸º <code>Task</code> ã€‚ä¸€ä¸ª <code>Task</code> å¯ä»¥å¤„äºè¿è¡ŒçŠ¶æ€å’Œæš‚åœçŠ¶æ€ï¼Œå½“ <code>Task</code> é‡åˆ°é˜»å¡è°ƒç”¨æ—¶ï¼Œéœ€è¦ä»è¿è¡ŒçŠ¶æ€åˆ‡æ¢åˆ°æš‚åœçŠ¶æ€ï¼Œè€Œå½“é˜»å¡æ¢å¤æ—¶ï¼Œéœ€è¦å†ä»æš‚åœçŠ¶æ€åˆ‡æ¢å›è¿è¡ŒçŠ¶æ€ï¼Œè€Œå®Œæˆè¿™ç§åˆ‡æ¢æ“ä½œçš„è§’è‰²ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸º <code>Executor</code> æ‰§è¡Œå™¨ã€‚</p>
<p>è¿™ç§åˆ‡æ¢ç±»ä¼¼äºçº¿ç¨‹çš„è°ƒåº¦ï¼Œä¸è¿‡åŒºåˆ«åœ¨äº <code>Task</code> æ²¡æœ‰è‡ªå·±ç‹¬ç«‹çš„æ‰§è¡Œæ ˆä»¥åŠéœ€è¦ä¸»åŠ¨è®©å‡ºçº¿ç¨‹ä½¿ç”¨æƒï¼ˆéæŠ¢å ï¼‰ã€‚å¯¹äºå‰è€…ï¼Œéœ€è¦ç¼–è¯‘å™¨æ”¯æŒå°†æš‚åœæ—¶çš„ <code>Task</code> çŠ¶æ€ä¿å­˜èµ·æ¥ï¼Œä¾¿äºåç»­çš„æ¢å¤æ‰§è¡Œï¼Œä¹Ÿå°±æ˜¯å®ç°çŠ¶æ€æœºã€‚è€Œçº¿ç¨‹æ‹¥æœ‰ç‹¬ç«‹çš„æ‰§è¡Œæ ˆï¼Œä¸éœ€è¦ç¼–è¯‘å™¨çš„æ”¯æŒå³å¯å®Œæˆè¿™ç§æ“ä½œã€‚å¯¹äºåè€…ï¼Œ<code>Task</code> æ— æ³•è¢«æŠ¢å ï¼Œå¦‚æœä¸€ä¸ªæ¶æ„ <code>Task</code> å®Œå…¨ä¸è®©å‡ºçº¿ç¨‹ä½¿ç”¨æƒï¼Œåˆ™ä¼šå¯¼è‡´å…¶ä»– <code>Task</code> çš„é¥¥é¥¿é—®é¢˜ã€‚ä»è¿™2ä¸ªæ–¹é¢çœ‹ï¼Œ<code>Goroutine</code> æ˜¯éå¸¸æ¥è¿‘åŸç”Ÿçº¿ç¨‹çš„ï¼Œä½†æ˜¯ç‹¬ç«‹çš„æ‰§è¡Œæ ˆï¼Œå¦‚ä½•åˆ†é…è¿™ä¸ªæ ˆçš„å¤§å°ï¼Œå¦‚æœæº¢å‡ºäº†ï¼Œå¦‚ä½•åŠ¨æ€å¢é•¿ï¼Œè€ŒåŠ¨æ€å¢é•¿ä¼šå¸¦æ¥é¢å¤–çš„æ€§èƒ½å¼€é”€ï¼Œè¿™äº›é—®é¢˜éƒ½éœ€è¦å»è§£å†³ã€‚è€Œ <code>Task</code> æ²¡æœ‰ç‹¬ç«‹çš„æ‰§è¡Œæ ˆï¼Œä¸éœ€è¦è§£å†³è¿™äº›é—®é¢˜ï¼ŒåŒæ—¶ä¸ä¼šæœ‰å†…å­˜çš„æµªè´¹ï¼ˆæ ˆçš„å¤§å°åˆ†é…ä¸å¯èƒ½å®Œå…¨å’Œéœ€æ±‚ä¸€è‡´ï¼‰ï¼›æŠ¢å è™½ç„¶å¯¹äºè§£å†³è´Ÿè½½å‡è¡¡æœ‰å¸®åŠ©ï¼Œä½†åŒæ—¶ä¹Ÿä¼šå¤šå‡ºä¸€äº›é¢å¤–çš„åˆ‡æ¢æ¬¡æ•°å¼€é”€ï¼Œå› æ­¤æ€»ä½“çš„åååè€Œå°äºéæŠ¢å å¼ã€‚</p>
<p>ä»å›è°ƒçœ‹çš„è¯ï¼Œ<code>Task</code> é˜»å¡æ¢å¤æ—¶ï¼Œéœ€è¦ä¸€ç§æœºåˆ¶æ¥é€šçŸ¥å¯¹åº”çš„ <code>Task</code> å¯ä»¥è¢«é‡æ–°è°ƒåº¦ï¼Œå®Œæˆè¿™ç§åŠŸèƒ½çš„è§’è‰²å°±æ˜¯ <code>Waker</code> å”¤é†’å™¨ï¼Œè€Œ <code>Waker</code> ä¹Ÿæ˜¯é€šè¿‡æ³¨å†Œå›è°ƒæ¥å®ç°çš„ã€‚</p>
<p>å¯¹äº <code>Pin</code> ç±»å‹ï¼Œåˆ™æ˜¯åœ¨çŠ¶æ€æœºçš„å®ç°è¿‡ç¨‹ä¸­ï¼Œä¼šå­˜åœ¨è‡ªå¼•ç”¨é—®é¢˜ï¼šå½“ <code>Task</code> æ¢å¤æ‰§è¡Œåï¼Œå¯èƒ½ä¼šå¼•ç”¨ä¸Šä¸€é˜¶æ®µäº§ç”Ÿçš„å˜é‡ï¼Œè€Œè¿™äº›å˜é‡éƒ½æ˜¯ä¿å­˜åœ¨è‡ªåŠ¨ç”Ÿæˆçš„åŒ¿åç»“æ„ä¸­ï¼Œè¿™æ ·å°±å‡ºç°äº†ä¸€ä¸ª <code>Field</code> å¯èƒ½å»å¼•ç”¨è‡ªèº«ç»“æ„çš„å¦ä¸€ä¸ª <code>Field</code>ã€‚è€Œè¿™æ ·çš„å¯¹è±¡æ˜¯æ— æ³•å®‰å…¨åœ°ç§»åŠ¨çš„ï¼Œè€Œç›®å‰çš„å®ç°å°±æ˜¯è®©å®ƒä¸å†ç§»åŠ¨ï¼Œä¹Ÿå°±æ˜¯æ— æ³•å®‰å…¨çš„è·å–å…¶å¯å˜å€Ÿç”¨ï¼Œ<code>Pin</code> ç±»å‹ä¾¿æ˜¯å¯¹è¿™ç§ç±»å‹çš„å°è£…ã€‚</p>
<p>ç»¼ä¸Šï¼Œ<code>Rust</code> çš„å¼‚æ­¥æ¨¡å‹å¯ä»¥è¯´æ˜¯åœ¨ç›®å‰å„ç”Ÿæ€é¢†åŸŸé‡Œçš„ä¸€ç§é€‰æ‹©ï¼Œå®ƒä¸æ˜¯å®Œç¾çš„ï¼Œå´ä¹Ÿè¶³å¤Ÿä¼˜ç§€ã€‚å½“ç„¶ç›®å‰ä¹Ÿä¸å­˜åœ¨å®Œç¾çš„å¼‚æ­¥æ¨¡å‹ï¼Œå¯¹äºä¸€äº›é—­æºå®ç°ï¼Œçœ‹ä¸åˆ°ä»£ç ï¼Œä¸åšåˆ¤æ–­ã€‚</p>
<h3 id="å®ç°-waker">å®ç° <code>Waker</code></h3>
<pre><code class="language-rust">pub struct Waker {
    waker: RawWaker,
}

pub struct RawWaker {
    /// A data pointer, which can be used to store arbitrary data as required
    /// by the executor. This could be e.g. a type-erased pointer to an `Arc`
    /// that is associated with the task.
    /// The value of this field gets passed to all functions that are part of
    /// the vtable as the first parameter.
    data: *const (),
    /// Virtual function pointer table that customizes the behavior of this waker.
    vtable: &amp;'static RawWakerVTable,
}

pub struct RawWakerVTable {
    /// This function will be called when the [`RawWaker`] gets cloned, e.g. when
    /// the [`Waker`] in which the [`RawWaker`] is stored gets cloned.
    ///
    /// The implementation of this function must retain all resources that are
    /// required for this additional instance of a [`RawWaker`] and associated
    /// task. Calling `wake` on the resulting [`RawWaker`] should result in a wakeup
    /// of the same task that would have been awoken by the original [`RawWaker`].
    ///
    /// [`Waker`]: struct.Waker.html
    /// [`RawWaker`]: struct.RawWaker.html
    clone: unsafe fn(*const ()) -&gt; RawWaker,

    /// This function will be called when `wake` is called on the [`Waker`].
    /// It must wake up the task associated with this [`RawWaker`].
    ///
    /// The implementation of this function must make sure to release any
    /// resources that are associated with this instance of a [`RawWaker`] and
    /// associated task.
    ///
    /// [`Waker`]: struct.Waker.html
    /// [`RawWaker`]: struct.RawWaker.html
    wake: unsafe fn(*const ()),

    /// This function will be called when `wake_by_ref` is called on the [`Waker`].
    /// It must wake up the task associated with this [`RawWaker`].
    ///
    /// This function is similar to `wake`, but must not consume the provided data
    /// pointer.
    ///
    /// [`Waker`]: struct.Waker.html
    /// [`RawWaker`]: struct.RawWaker.html
    wake_by_ref: unsafe fn(*const ()),

    /// This function gets called when a [`RawWaker`] gets dropped.
    ///
    /// The implementation of this function must make sure to release any
    /// resources that are associated with this instance of a [`RawWaker`] and
    /// associated task.
    ///
    /// [`RawWaker`]: struct.RawWaker.html
    drop: unsafe fn(*const ()),
}
</code></pre>
<p>æ ‡å‡†åº“ä¸­å¯¹ <code>Waker</code> çš„å®šä¹‰ä¸­åªæœ‰ä¸€ä¸ª <code>RawWaker</code>ï¼Œå¹¶ä¸” <code>RawWaker</code> ç»“æ„å†…æœ‰ <code>data</code> å’Œ <code>vtable</code> 2ä¸ª <code>Field</code>ã€‚çœ‹åˆ°è¿™é‡Œå·²ç»å‘ç°äº† <code>RawWaker</code> å…¶å®å°±æ˜¯ä¸ªç”±æ•°æ®å’Œè™šè¡¨ç»„æˆçš„èƒ–æŒ‡é’ˆï¼Œå’Œ <code>Trait Object</code> å¦‚å‡ºä¸€è¾™ï¼Œä¹‹æ‰€ä»¥ä¸ç›´æ¥å°† <code>Waker</code> å®šä¹‰æˆ <code>Trait Object</code> çš„åŸå› ï¼Œæ˜¯ä¸ºäº† <code>Rust</code> çš„å¼‚æ­¥æ¨¡å‹å¯ä»¥çµæ´»åœ°é€‚åº”äºå„ç±»ç³»ç»Ÿï¼ŒåŒ…æ‹¬æ²¡æœ‰å†…å­˜åˆ†é…å™¨çš„åµŒå…¥å¼ç³»ç»Ÿä¸Šã€‚</p>
<p>æ—¢ç„¶ <code>Waker</code> çš„ä½œç”¨æ˜¯å½“äº‹ä»¶å°±ç»ªæ—¶é€šçŸ¥ <code>Executor</code> å¯ä»¥é‡æ–°è°ƒåº¦æŸä¸ªä»»åŠ¡ï¼Œä¸å¦¨å¯ä»¥å°† <code>Waker</code> æ„é€ æ–¹æ³•è®¾è®¡æˆæ¥å—ä¸€ä¸ªé—­åŒ…ï¼Œè€Œè™šè¡¨çš„å„ç±»æ–¹æ³•å…ˆå–å‡ºé—­åŒ…ï¼Œç„¶åæ‰§è¡Œé—­åŒ…å°±è¡Œäº†ï¼š</p>
<pre><code class="language-rust">struct WakerFn&lt;F&gt;(F);

impl&lt;F: Fn() + 'static + Send&gt; WakerFn&lt;F&gt; {
    const VTABLE: RawWakerVTable =
        RawWakerVTable::new(Self::clone, Self::wake, Self::wake_by_ref, Self::drop);

    unsafe fn clone(data: *const ()) -&gt; RawWaker {
        let arc = std::mem::ManuallyDrop::new(Arc::from_raw(data as *const F));
        // å¢åŠ å¼•ç”¨è®¡æ•°ï¼Œä½†æ˜¯ä¸æ‰§è¡Œææ„æ–¹æ³•ï¼Œå› ä¸ºä¸‹é¢éœ€è¦è½¬æ¢æˆè£¸æŒ‡é’ˆï¼Œé˜²æ­¢æ‚¬å‚æŒ‡é’ˆ
        let _ = arc.clone();
        RawWaker::new(data, &amp;Self::VTABLE)
    }

    unsafe fn wake(data: *const ()) {
        let arc = Arc::from_raw(data as *const F);
        arc();
    }

    unsafe fn wake_by_ref(data: *const ()) {
        let f = &amp;*(data as *const F);
        f();
    }

    unsafe fn drop(data: *const ()) {
        drop(Arc::from_raw(data as *const F))
    }

    fn get_waker(f: F) -&gt; Waker {
        let data = Arc::into_raw(Arc::new(f)) as *const ();
        let vtable = &amp;Self::VTABLE;
        unsafe { Waker::from_raw(RawWaker::new(data, vtable)) }
    }
}
</code></pre>
<h3 id="å®ç°-executor">å®ç° <code>Executor</code></h3>
<p><code>Executor</code> çš„ä½œç”¨å°±æ˜¯æ‰§è¡Œ <code>Task</code>ï¼Œå¯ä»¥å®ç°ä¸€ä¸ªç®€å•çš„ä»»åŠ¡é˜Ÿåˆ—ï¼Œä¸åœåœ°ä»é˜Ÿåˆ—ä¸­å–å‡ºä»»åŠ¡ï¼Œç„¶åæ‰§è¡Œï¼š</p>
<pre><code class="language-rust">struct RawTask {
    future: Mutex&lt;Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt; + Send&gt;&gt;&gt;,
}

type Task = Arc&lt;RawTask&gt;;

struct Executor {
    rx_futures: Receiver&lt;Task&gt;,
    tx_futures: Sender&lt;Task&gt;,
}

impl Executor {
    fn new(rx_futures: Receiver&lt;Task&gt;, tx_futures: Sender&lt;Task&gt;) -&gt; Self {
        Self {
            rx_futures,
            tx_futures,
        }
    }

    fn run(&amp;self) {
        while let Ok(task) = self.rx_futures.recv() {
            let tx_futures_w = self.tx_futures.clone();
            let task_w = task.clone();
            let waker = WakerFn::get_waker(move || {
                // é‡æ–°è°ƒåº¦ä»»åŠ¡
                tx_futures_w.send(task_w.clone()).unwrap();
            });
            let mut cx = Context::from_waker(&amp;waker);
            let _ = task.future.lock().unwrap().as_mut().poll(&amp;mut cx);
        }
    }
}
</code></pre>
<p>è¿™é‡Œå¯ä»¥çœ‹åˆ° <code>Task</code> å†…çš„ <code>Future</code> çš„ <code>Output</code> å…³è”ç±»å‹è¢«å®šä¹‰æˆäº† <code>()</code> ï¼Œè¿™æ˜¯å› ä¸º <code>Executor</code> åªä¼šæ¥æ”¶é¡¶çº§çš„ <code>Future</code> ï¼Œéé¡¶çº§çš„ <code>Future</code> ç»„åˆå­ä¼šç”±ç¼–è¯‘å™¨ç”Ÿæˆçš„ç”Ÿæˆå™¨è‡ªåŠ¨å¤„ç†ï¼Œè‡³äºå¦‚ä½•æ¥æ”¶é¡¶çº§ <code>Future</code> çš„ç»“æœå¯ä»¥ç”±ä¸‹é¢çš„ <code>Runtime</code> å®ç°ã€‚</p>
<h3 id="å®ç°-runtime">å®ç° <code>Runtime</code></h3>
<pre><code class="language-rust">struct Runtime {
    tx_futures: Option&lt;Sender&lt;Task&gt;&gt;,
    // ç”±äº Sender æ²¡æœ‰å®ç° Syncï¼Œæ‰€ä»¥å®ç°ä¸€ä¸ªç®€å•çš„ Spin
    lock: AtomicBool,
}

unsafe impl Sync for Runtime {}

impl Runtime {
    const fn uninit() -&gt; Self {
        Self {
            tx_futures: None,
            lock: AtomicBool::new(false),
        }
    }

    fn init(&amp;mut self, tx_futures: Sender&lt;Task&gt;) {
        self.tx_futures = Some(tx_futures);
    }

    fn spawn&lt;F, R&gt;(&amp;self, f: F) -&gt; impl Future&lt;Output = R&gt;
    where
        F: Future&lt;Output = R&gt; + Send + 'static,
        R: Send + 'static,
    {
        let waiter = Arc::new(Waiter::&lt;R&gt;::new());
        let waiter_f = WaiterFuture::new(waiter.clone());
        // åŒ…è£…task
        let f2 = async move {
            let r = f.await;
            waiter.complete(r);
        };
        let raw_task = RawTask {
            future: Mutex::new(Box::pin(f2)),
        };
        let task: Task = Arc::new(raw_task);

        // è·å–é”
        while self.lock.compare_and_swap(false, true, Ordering::SeqCst) {}
        // è°ƒåº¦ä»»åŠ¡
        self.tx_futures
            .as_ref()
            .expect(&quot;Runtimeæœªåˆå§‹åŒ–&quot;)
            .send(task)
            .unwrap();
        // é‡Šæ”¾é”
        self.lock.store(false, Ordering::SeqCst);
        waiter_f
    }

    fn block_on&lt;F, R&gt;(&amp;self, f: F) -&gt; F::Output
    where
        F: Future&lt;Output = R&gt; + Send + 'static,
        R: Send + 'static,
    {
        let (tx, rx) = mpsc::channel();
        // åŒ…è£…task
        let f2 = async move {
            let r = f.await;
            tx.send(r).unwrap();
        };
        let raw_task = RawTask {
            future: Mutex::new(Box::pin(f2)),
        };
        let task: Task = Arc::new(raw_task);
        // è·å–é”
        while self.lock.compare_and_swap(false, true, Ordering::SeqCst) {}
        // è°ƒåº¦ä»»åŠ¡
        self.tx_futures
            .as_ref()
            .expect(&quot;Runtimeæœªåˆå§‹åŒ–&quot;)
            .send(task)
            .unwrap();
        // é‡Šæ”¾é”
        self.lock.store(false, Ordering::SeqCst);
        rx.recv().unwrap()
    }
}
</code></pre>
<p><code>block_on</code> æ–¹æ³•æ¥æ”¶ä¸€ä¸ª <code>Future</code>ï¼Œæˆ‘ä»¬éœ€è¦å°†å…¶åŒ…è£…æˆä¸€ä¸ª <code>Task</code>ï¼Œç„¶åå‘é€åˆ° <code>Executor</code>ï¼Œè€Œå®ƒçš„ç»“æœå¯ä»¥ç”¨ä¸€ä¸ª <code>channel</code> æ¥æ¥æ”¶ã€‚è€Œ <code>spawn</code> æ–¹æ³•åˆ™éœ€è¦è¿”å›ä¸€ä¸ªæ–°çš„ <code>Future</code> ï¼Œå¹¶ä¸” <code>spawn</code> ä¼šæ´¾ç”Ÿä¸€ä¸ªé¡¶çº§ <code>Future</code> ï¼Œä¹Ÿå°±æ˜¯ä¼šå¹¶å‘æ‰§è¡Œï¼Œè€Œ <code>channel</code> çš„ <code>recv</code> æ–¹æ³•ä¼šé˜»å¡çº¿ç¨‹ï¼Œä¸ºæ­¤è®¾è®¡äº† <code>WaiterFuture</code> ç”¨äºå¼‚æ­¥æ¥æ”¶ç»“æœï¼ˆå½“ç„¶ä¹Ÿå¯ä»¥ä¸å»æ¥æ”¶ï¼‰ï¼š</p>
<pre><code class="language-rust">struct Waiter&lt;T&gt; {
    val: Mutex&lt;Option&lt;T&gt;&gt;,
    waker: Mutex&lt;Option&lt;Waker&gt;&gt;,
}

impl&lt;T&gt; Waiter&lt;T&gt; {
    fn new() -&gt; Self {
        Self {
            val: Mutex::new(None),
            waker: Mutex::new(None),
        }
    }

    fn complete(&amp;self, val: T) {
        *self.val.lock().unwrap() = Some(val);
        if let Some(waker) = self.waker.lock().unwrap().take() {
            waker.wake();
        } else {
            // TODO:
        }
    }
}

struct WaiterFuture&lt;T&gt; {
    waiter: Arc&lt;Waiter&lt;T&gt;&gt;,
}

impl&lt;T&gt; WaiterFuture&lt;T&gt; {
    fn new(waiter: Arc&lt;Waiter&lt;T&gt;&gt;) -&gt; Self {
        Self { waiter }
    }
}

impl&lt;T&gt; Future for WaiterFuture&lt;T&gt; {
    type Output = T;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        unsafe {
            let w = self.get_unchecked_mut();
            let mut val = w.waiter.val.lock().unwrap();
            if val.is_some() {
                Poll::Ready(val.take().unwrap())
            } else {
                // æ³¨å†Œwaker
                let mut w_waker = w.waiter.waker.lock().unwrap();
                if w_waker.is_none() {
                    let waker = cx.waker().clone();
                    *w_waker = Some(waker);
                }
                Poll::Pending
            }
        }
    }
}
</code></pre>
<p>å½“ <code>Waiter</code> å†…çš„æ•°æ®æ²¡æœ‰å°±ç»ªæ—¶ï¼Œæ³¨å†Œå½“å‰ <code>Task</code> çš„ <code>Waker</code>ï¼›å½“æ´¾ç”Ÿçš„é¡¶çº§ <code>Future</code> å®Œæˆæ—¶ï¼Œè°ƒç”¨ <code>complete</code> æ–¹æ³•ï¼Œå†™å…¥æ•°æ®ï¼Œæ‰§è¡Œå”¤é†’å™¨ï¼ˆé‡æ–°è°ƒåº¦å½“å‰çš„ <code>Task</code>ï¼‰ã€‚</p>
<h3 id="è¿è¡Œæ—¶çš„åˆå§‹åŒ–">è¿è¡Œæ—¶çš„åˆå§‹åŒ–</h3>
<p>ç”±äºæ–°ä»»åŠ¡çš„æ´¾ç”Ÿå¯èƒ½åœ¨å¤šä¸ªçº¿ç¨‹ä¸­ï¼Œä¸ºæ­¤å¯ä»¥ç®€å•åœ°åˆå§‹åŒ–ä¸€ä¸ªå…¨å±€è¿è¡Œæ—¶ï¼Œå¹¶å°†è¿è¡Œæ—¶æ ‡è®°ä¸º <code>Sync</code>ï¼ˆå› ä¸ºæˆ‘ä»¬å¯¹ <code>Sender</code> å·²ç»åšäº†è‡ªæ—‹é”ä¿æŠ¤ï¼‰ï¼š</p>
<pre><code class="language-rust">fn main() {
    let (tx_futures, rx_futures) = mpsc::channel();
    // åˆå§‹åŒ–Executor
    let executor = Executor::new(rx_futures, tx_futures.clone());
    thread::spawn(move || {
        executor.run();
    });
    // åˆå§‹åŒ–Runtime
    unsafe {
        let rt_ptr: *mut Runtime = &amp;RT as *const _ as *mut _;
        (*rt_ptr).init(tx_futures);
    }
    let r = RT.block_on(async { 2 });
    dbg!(r);
}

static RT: Runtime = Runtime::uninit();
</code></pre>
<p>è¿è¡Œä»£ç ï¼š</p>
<pre><code class="language-bash">$ cargo run
</code></pre>
<pre><code class="language-none">[src/main.rs:28] r = 2
</code></pre>
<p>ä¸ºäº†éªŒè¯ <code>Waker</code> æ˜¯å¦å·¥ä½œæ­£å¸¸ï¼Œå¯ä»¥å®ç°ä¸€ä¸ªè™šå‡çš„IOæ“ä½œï¼š</p>
<pre><code class="language-rust">struct FakeIo {
    val: Arc&lt;Mutex&lt;Option&lt;i32&gt;&gt;&gt;,
    start: bool,
    dur: Duration,
}

impl FakeIo {
    fn new(dur: Duration) -&gt; Self {
        Self {
            val: Arc::new(Mutex::new(None)),
            start: false,
            dur,
        }
    }
}

impl Future for FakeIo {
    type Output = i32;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        let v = self.val.lock().unwrap();
        if v.is_some() {
            return Poll::Ready(v.unwrap());
        }
        drop(v);
        if !self.start {
            let w = cx.waker().clone();
            let v = self.val.clone();
            let dur = self.dur;
            unsafe {
                self.get_unchecked_mut().start = true;
            }
            thread::spawn(move || {
                thread::sleep(dur);
                *v.lock().unwrap() = Some(100);
                w.wake();
            });
        }
        Poll::Pending
    }
}
</code></pre>
<p><code>FakeIo</code> ä¼šåˆ›å»ºä¸€ä¸ªå­çº¿ç¨‹ï¼Œä¸€å®šæ—¶é—´åæ‰§è¡Œ <code>Waker</code>ï¼Œå¯ä»¥ç”¨æ¥æ¨¡æ‹ŸIOæ“ä½œã€‚</p>
<p>æ‰§è¡Œä¸€ä¸ª <code>FakeIo</code>ï¼š</p>
<pre><code class="language-rust">let r = RT.block_on(FakeIo::new(Duration::from_secs(2)));
dbg!(r);
</code></pre>
<p>2ç§’åç»“æœï¼š</p>
<pre><code class="language-none">[src/main.rs:28] r = 100
</code></pre>
<p>æˆ‘ä»¬ä¹Ÿå¯ä»¥åœ¨ä¸€ä¸ªä»»åŠ¡ä¸­æ´¾ç”Ÿä¸€ä¸ªæ–°ä»»åŠ¡å¹¶å¼‚æ­¥æ¥æ”¶å®ƒçš„ç»“æœï¼ˆä¹Ÿå¯ä»¥ä¸æ¥æ”¶ï¼Œä½†å®ƒä»ç„¶ä¼šå¹¶å‘æ‰§è¡Œï¼‰ï¼š</p>
<pre><code class="language-rust">let r = RT.block_on(async {
    let a = RT.spawn(FakeIo::new(Duration::from_secs(2))).await;
    a + 1
});
dbg!(r);
</code></pre>
<pre><code class="language-none">[src/main.rs:28] r = 101
</code></pre>
<h3 id="ç»“å°¾">ç»“å°¾</h3>
<p>å¥½äº†ï¼Œä¸€ä¸ªéå¸¸ç²¾ç®€ã€æ— ä¾èµ–çš„å¼‚æ­¥è¿è¡Œæ—¶å°±å·²ç»å®ç°ï¼Œè™½ç„¶æ²¡æœ‰çº¿ç¨‹æ± ã€çœŸå¼‚æ­¥IOï¼Œå¯èƒ½å­˜åœ¨é‡å¤å”¤é†’ç­‰é—®é¢˜ï¼Œä½†æ˜¯å´éå¸¸æ¸…æ™°åœ°é˜è¿°äº† <code>Rust</code> çš„å¼‚æ­¥å®ç°åŸç†ï¼š<code>Runtime</code> å‘ <code>Executor</code> å‘é€ä»»åŠ¡ï¼Œ<code>Executor</code> æ‰§è¡Œä»»åŠ¡ï¼Œ<code>Waker</code> å”¤é†’æš‚åœçš„ä»»åŠ¡ï¼Œå¦‚æ­¤å¾€å¤ï¼Œä»¥åŠ <code>Pin</code> ç±»å‹é˜²æ­¢å­˜åœ¨è‡ªå¼•ç”¨çš„ç»“æ„å®‰å…¨åœ°è·å–åˆ°å¯å˜å€Ÿç”¨ã€‚</p>
<p>å®Œæ•´çš„ä»£ç è§ï¼š<a href="https://github.com/xiaopengli89/plain-rt">plain-rt</a></p>]]></content>
		</item>
		
		<item>
			<title>Rusté«˜é˜¶ç”Ÿå‘½å‘¨æœŸç»‘å®š</title>
			<link>/posts/rust-hrtbs/</link>
			<pubDate>Fri, 03 Jul 2020 23:40:45 +0800</pubDate>
			
			<guid>/posts/rust-hrtbs/</guid>
			<description>&lt;p&gt;Rustä¸­ï¼Œ&lt;code&gt;lifetime&lt;/code&gt; å…¶å®ä¹Ÿæ˜¯ä¸€ç§ç±»å‹å‚æ•°ï¼Œå¯ä»¥çœ‹æˆèŒƒå‹çš„ä¸€ç§ç‰¹æ®Šå½¢å¼ã€‚ç¼–è¯‘æ—¶éœ€è¦å°†æ‰€æœ‰ç±»å‹ï¼ˆåŒ…æ‹¬ &lt;code&gt;lifetime&lt;/code&gt; ï¼‰ç¡®å®šä¸‹æ¥ï¼Œæ¯”å¦‚ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn foo&amp;lt;&#39;a&amp;gt;(x: &amp;amp;&#39;a i32) {
	// ...
}

&#39;a: {
	let x = 1;
	foo::&amp;lt;&#39;a&amp;gt;(&amp;amp;x);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ä¸Šé¢çš„ &lt;code&gt;&#39;a&lt;/code&gt; ç”Ÿå‘½å‘¨æœŸå…¶å®å°±æ˜¯å˜é‡ &lt;code&gt;x&lt;/code&gt; æ‰€åœ¨çš„blockã€‚&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>Rustä¸­ï¼Œ<code>lifetime</code> å…¶å®ä¹Ÿæ˜¯ä¸€ç§ç±»å‹å‚æ•°ï¼Œå¯ä»¥çœ‹æˆèŒƒå‹çš„ä¸€ç§ç‰¹æ®Šå½¢å¼ã€‚ç¼–è¯‘æ—¶éœ€è¦å°†æ‰€æœ‰ç±»å‹ï¼ˆåŒ…æ‹¬ <code>lifetime</code> ï¼‰ç¡®å®šä¸‹æ¥ï¼Œæ¯”å¦‚ï¼š</p>
<pre><code class="language-rust">fn foo&lt;'a&gt;(x: &amp;'a i32) {
	// ...
}

'a: {
	let x = 1;
	foo::&lt;'a&gt;(&amp;x);
}
</code></pre>
<p>ä¸Šé¢çš„ <code>'a</code> ç”Ÿå‘½å‘¨æœŸå…¶å®å°±æ˜¯å˜é‡ <code>x</code> æ‰€åœ¨çš„blockã€‚</p>
<p>è¿™ä¸ªä¾‹å­å¾ˆç®€å•ï¼Œä½†å¦‚æœæˆ‘ä»¬æ¢ä¸ªé—­åŒ…ç±»å‹çœ‹çœ‹ï¼š</p>
<pre><code class="language-rust">fn foo&lt;'a&gt;(f: Box&lt;dyn Fn(&amp;'a i32)&gt;) {
    let x = 1;
    f(&amp;x);
	{
		let y = 2;
		f(&amp;y);
	}
}
</code></pre>
<p>ç¬¬ä¸€æ¬¡è°ƒç”¨ <code>f(&amp;x)</code> æ—¶ç”Ÿå‘½å‘¨æœŸ <code>'a</code> ç­‰äºå˜é‡ <code>x</code> çš„ç”Ÿå‘½å‘¨æœŸï¼›è€Œåœ¨ç¬¬äºŒæ¬¡è°ƒç”¨ <code>f(&amp;y)</code> æ—¶ï¼Œç”Ÿå‘½å‘¨æœŸ <code>'a</code> åˆç­‰äºäº†å˜é‡ <code>y</code> çš„ç”Ÿå‘½å‘¨æœŸï¼›è€Œå˜é‡ <code>x</code> å’Œå˜é‡ <code>y</code> çš„ç”Ÿå‘½å‘¨æœŸæ˜¾ç„¶æ˜¯ä¸åŒçš„ã€‚å› æ­¤æ— æ³•ç”¨ä¸€ä¸ªé™æ€çš„ç”Ÿå‘½å‘¨æœŸæ¥æè¿° <code>'a</code> ï¼Œæˆ‘ä»¬å¸Œæœ›çš„æ˜¯ï¼Œé—­åŒ… <code>f</code> åœ¨å…·ä½“è°ƒç”¨æ—¶ç»‘å®šå…·ä½“çš„ç”Ÿå‘½å‘¨æœŸï¼Œæ¯”å¦‚è°ƒç”¨ <code>f(&amp;x)</code> æ—¶ç»‘å®šçš„æ˜¯ <code>x</code> çš„ç”Ÿå‘½å‘¨æœŸï¼Œè€Œè°ƒç”¨ <code>f(&amp;y)</code> æ—¶ç»‘å®šçš„æ˜¯ <code>y</code> çš„ç”Ÿå‘½å‘¨æœŸã€‚</p>
<p>Rustä¸­å¯ä»¥ç”¨ <code>é«˜é˜¶ç”Ÿå‘½å‘¨æœŸç»‘å®šï¼ˆHRTBsï¼‰</code> æ¥å®ç°&quot;åŠ¨æ€&quot;ç”Ÿå‘½å‘¨æœŸç»‘å®šï¼Œå…¶è¯­æ³•å¦‚ä¸‹ï¼š</p>
<pre><code class="language-rust">for&lt;'a&gt; Trait
</code></pre>
<p>æ¯”å¦‚ä¸Šé¢çš„ä¾‹å­å°±å¯ä»¥å†™æˆï¼š</p>
<pre><code class="language-rust">fn foo(f: Box&lt;dyn for&lt;'a&gt; Fn(&amp;'a i32)&gt;) {
    let x = 1;
    f(&amp;x);
	{
		let y = 2;
		f(&amp;y);
	}
}
</code></pre>
<p>è¿™æ ·ç”Ÿå‘½å‘¨æœŸ <code>'a</code> å°±ä¸å†æ˜¯é™æ€çš„äº†ï¼Œä»–ä¼šéšç€é—­åŒ… <code>f</code> çš„è°ƒç”¨ç»‘å®šåˆ°ä¸åŒçš„ç”Ÿå‘½å‘¨æœŸï¼š<code>f(&amp;x)</code> è°ƒç”¨æ—¶ç»‘å®šåˆ° <code>x</code> çš„ç”Ÿå‘½å‘¨æœŸï¼Œ<code>f(&amp;y)</code> è°ƒç”¨æ—¶ç»‘å®šåˆ° <code>y</code> çš„ç”Ÿå‘½å‘¨æœŸã€‚</p>
<p>ä¸è¿‡å¤§å¤šæ•°æ—¶å€™æˆ‘ä»¬å¾ˆå°‘è§åˆ° <code>HRTBs</code> ï¼Œå› ä¸ºé—­åŒ…çš„ç”Ÿå‘½å‘¨æœŸçœç•¥çš„è¯ï¼Œç¼–è¯‘å™¨ä¼šå¸®æˆ‘ä»¬è‡ªåŠ¨ç”Ÿæˆ <code>é«˜é˜¶ç”Ÿå‘½å‘¨æœŸç»‘å®š</code> ã€‚</p>
<p>è€Œ <code>HRTBs</code> çš„å…¨ç§°æ˜¯ <code>Higher-Rank Trait Bounds</code>ï¼Œç¿»è¯‘æˆ <code>é«˜é˜¶ç‰¹è´¨ç»‘å®š</code> å¯èƒ½æ›´ä¸ºåˆé€‚ï¼Œå¹¶ä¸”å®ƒåªèƒ½åœ¨ç»‘å®š <code>trait</code> æ—¶å£°æ˜ï¼Œä¸è¿‡ç›®å‰åªæ”¯æŒå¯¹ç”Ÿå‘½å‘¨æœŸå‚æ•°çš„ç»‘å®šï¼Œæ‰€ä»¥æˆ‘ç¿»è¯‘å®ƒå« <code>é«˜é˜¶ç”Ÿå‘½å‘¨æœŸç»‘å®š</code> ã€‚</p>]]></content>
		</item>
		
		<item>
			<title>RuståŠ¨æ€å†…å­˜åˆ†é…</title>
			<link>/posts/rust-box-heap/</link>
			<pubDate>Wed, 01 Jul 2020 16:57:56 +0800</pubDate>
			
			<guid>/posts/rust-box-heap/</guid>
			<description>&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/std/boxed/index.html&#34;&gt;Box&lt;/a&gt; æ˜¯ä¸€ä¸ªåœ¨Rustä¸­ç»å¸¸è¢«ç”¨åˆ°çš„æ™ºèƒ½æŒ‡é’ˆï¼Œå®ƒçš„ä½œç”¨æ˜¯å®ç°å †å†…å­˜åˆ†é…ï¼Œå¹¶ä¸”ç®¡ç†è¯¥å—å†…å­˜çš„ç”Ÿå‘½å‘¨æœŸã€‚å°¤å…¶åœ¨å®ç°é€’å½’æ•°æ®ç»“æ„æ—¶ï¼Œé€šè¿‡ &lt;a href=&#34;https://doc.rust-lang.org/std/boxed/index.html&#34;&gt;Box&lt;/a&gt; æ‰èƒ½è®©ä¸€ä¸ªç±»å‹å¤§å°ä¸ä¼šæ— é™è†¨èƒ€ã€‚åŒæ—¶ &lt;a href=&#34;https://doc.rust-lang.org/std/boxed/index.html&#34;&gt;Box&lt;/a&gt; çš„å†…å­˜å¸ƒå±€åŒ &lt;code&gt;C&lt;/code&gt; äºŒè¿›åˆ¶å…¼å®¹ï¼Œä¹Ÿå°±æ˜¯è¯´åœ¨ä½¿ç”¨ &lt;code&gt;FFI&lt;/code&gt; æ—¶ï¼Œå¯ä»¥ç›´æ¥åœ¨å‚æ•°æˆ–è¿”å›å€¼ä¸­ä½¿ç”¨ &lt;a href=&#34;https://doc.rust-lang.org/std/boxed/index.html&#34;&gt;Box&lt;/a&gt;ã€‚&lt;/p&gt;
&lt;p&gt;è¿™ç¯‡æ–‡ç« å°†ä»‹ç»åˆ©ç”¨Rustçš„åŠ¨æ€å†…å­˜åˆ†é…å®ç°ä¸€ä¸ªç®€å•çš„è‡ªå®šä¹‰ &lt;code&gt;Box&lt;/code&gt; ã€‚&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p><a href="https://doc.rust-lang.org/std/boxed/index.html">Box</a> æ˜¯ä¸€ä¸ªåœ¨Rustä¸­ç»å¸¸è¢«ç”¨åˆ°çš„æ™ºèƒ½æŒ‡é’ˆï¼Œå®ƒçš„ä½œç”¨æ˜¯å®ç°å †å†…å­˜åˆ†é…ï¼Œå¹¶ä¸”ç®¡ç†è¯¥å—å†…å­˜çš„ç”Ÿå‘½å‘¨æœŸã€‚å°¤å…¶åœ¨å®ç°é€’å½’æ•°æ®ç»“æ„æ—¶ï¼Œé€šè¿‡ <a href="https://doc.rust-lang.org/std/boxed/index.html">Box</a> æ‰èƒ½è®©ä¸€ä¸ªç±»å‹å¤§å°ä¸ä¼šæ— é™è†¨èƒ€ã€‚åŒæ—¶ <a href="https://doc.rust-lang.org/std/boxed/index.html">Box</a> çš„å†…å­˜å¸ƒå±€åŒ <code>C</code> äºŒè¿›åˆ¶å…¼å®¹ï¼Œä¹Ÿå°±æ˜¯è¯´åœ¨ä½¿ç”¨ <code>FFI</code> æ—¶ï¼Œå¯ä»¥ç›´æ¥åœ¨å‚æ•°æˆ–è¿”å›å€¼ä¸­ä½¿ç”¨ <a href="https://doc.rust-lang.org/std/boxed/index.html">Box</a>ã€‚</p>
<p>è¿™ç¯‡æ–‡ç« å°†ä»‹ç»åˆ©ç”¨Rustçš„åŠ¨æ€å†…å­˜åˆ†é…å®ç°ä¸€ä¸ªç®€å•çš„è‡ªå®šä¹‰ <code>Box</code> ã€‚</p>
<h3 id="å†…å­˜åˆ†é…å™¨">å†…å­˜åˆ†é…å™¨</h3>
<p>å¯¹äºæ¯ä¸€ä¸ªç¨‹åºï¼Œæ ‡å‡†åº“ä¸­éƒ½ä¼šå¸¦æœ‰ä¸€ä¸ªå…¨å±€çš„å†…å­˜åˆ†é…å™¨ï¼Œå¹¶ä¸”å†…å­˜åˆ†é…å™¨éœ€è¦å®ç° <code>GlobalAlloc</code> è¿™ä¸ª <code>trait</code> ï¼Œåœ¨ä½¿ç”¨ <code>alloc</code> å’Œ <code>dealloc</code> æ—¶ä¼šä½¿ç”¨è¯¥å†…å­˜åˆ†é…å™¨åŠ¨æ€åˆ†é…å’Œé‡Šæ”¾å†…å­˜ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œè¿™ä¸ªå†…å­˜åˆ†é…å™¨æ˜¯ <code>std::alloc::System</code> ï¼Œç”±å…·ä½“çš„æ“ä½œç³»ç»Ÿæä¾›ï¼Œæ¯”å¦‚ <code>Unix</code> å¹³å°çš„ <code>malloc</code>ï¼Œ<code>Windows</code> å¹³å°çš„ <code>HeapAlloc</code> ã€‚</p>
<p>æˆ‘ä»¬ä¹Ÿå¯ä»¥åˆ©ç”¨ <code>#[global_allocator]</code> è¿™ä¸ª <code>attribute</code> æ›¿æ¢é»˜è®¤çš„å†…å­˜åˆ†é…å™¨ã€‚</p>
<pre><code class="language-rust">use std::alloc::{GlobalAlloc, System, Layout};

struct MyAllocator;

unsafe impl GlobalAlloc for MyAllocator {
    unsafe fn alloc(&amp;self, layout: Layout) -&gt; *mut u8 {
        System.alloc(layout)
    }

    unsafe fn dealloc(&amp;self, ptr: *mut u8, layout: Layout) {
        System.dealloc(ptr, layout)
    }
}

#[global_allocator]
static GLOBAL: MyAllocator = MyAllocator;
</code></pre>
<h3 id="å®ç°-mybox-æ™ºèƒ½æŒ‡é’ˆ">å®ç° <code>MyBox</code> æ™ºèƒ½æŒ‡é’ˆ</h3>
<p>ç”± <code>alloc</code> åˆ†é…å¥½å†…å­˜ï¼Œä¼šè¿”å›æŒ‡å‘è¯¥å—å†…å­˜çš„æŒ‡é’ˆï¼Œå› æ­¤é¦–å…ˆ <code>MyBox</code> å†…éœ€è¦æŒæœ‰ä¸€ä¸ªè£¸æŒ‡é’ˆï¼Œæ¥ä»£è¡¨å¯¹è¯¥å—å†…å­˜çš„æ‰€æœ‰æƒã€‚</p>
<pre><code class="language-rust">pub struct MyBox&lt;T&gt; {
    inner: *mut T,
}
</code></pre>
<p>ç„¶åå®ç°å…¶æ„é€ æ–¹æ³•ï¼Œæ–¹æ³•æ˜¯å…ˆ <code>alloc</code> å†…å­˜ï¼Œç„¶åå¾€å†…å­˜åœ°å€å†…å†™å…¥æ•°æ®ï¼Œæ¯”å¦‚ä»¿æ ‡å‡†åº“çš„ <code>Box</code> ï¼š</p>
<pre><code class="language-rust">impl&lt;T&gt; MyBox&lt;T&gt; {
    pub fn new(t: T) -&gt; Self {
        unsafe {
            let layout = Layout:ğŸ†•:&lt;T&gt;();
            let ptr = alloc(layout) as *mut T;
            ptr.write(t);
            Self { inner: ptr }
        }
    }
}

fn main() {
	let _ = MyBox::new(1);
}
</code></pre>
<p>è¿™ç§æ–¹æ³•é¦–å…ˆéœ€è¦åœ¨æ ˆä¸Šåˆ›å»ºä¸€ä¸ªå˜é‡ <code>T</code> ï¼Œç„¶åå†æ‹·è´åˆ°å †ä¸Šã€‚ä¹Ÿå¯ä»¥å®ç°ç±»ä¼¼ <code>Java</code> é£æ ¼çš„æ„é€ æ–¹æ³•ï¼Œä½†æ˜¯åœ¨æ„é€ æ–¹æ³•å†…ï¼Œå¿…é¡»åˆå§‹åŒ–æ‰€æœ‰å­—æ®µçš„å€¼ï¼Œå¦åˆ™åé¢ä½¿ç”¨æ—¶ä¼š <code>UB</code>ï¼Œå› æ­¤æˆ‘ä»¬å°†è¿™ç§æ„é€ æ–¹å¼æ ‡è®°ä¸º <code>unsafe</code> ï¼š</p>
<pre><code class="language-rust">impl&lt;T&gt; MyBox&lt;T&gt; {
    pub unsafe fn init(f: impl FnOnce(&amp;mut T)) -&gt; Self {
        let layout = Layout:ğŸ†•:&lt;T&gt;();
        let ptr = alloc(layout) as *mut T;
        f(&amp;mut *ptr);
        Self { inner: ptr }
    }
}

struct Foo {
	name: String,
}

fn main() {
	let _ = unsafe {
		MyBox::&lt;Foo&gt;::init(|obj| {
			obj.name = String::from(&quot;hello&quot;);
		})
	};
}
</code></pre>
<p>å†…å­˜åˆ†é…äº†å°±éœ€è¦é‡Šæ”¾ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ææ„æ–¹æ³•å†…å®Œæˆå†…å­˜çš„é‡Šæ”¾ï¼Œå®ç° <code>Drop</code>ï¼š</p>
<pre><code class="language-rust">impl&lt;T&gt; Drop for MyBox&lt;T&gt; {
    fn drop(&amp;mut self) {
        let layout = Layout:ğŸ†•:&lt;T&gt;();
        unsafe {
            dealloc(self.inner as *mut u8, layout);
        }
    }
}
</code></pre>
<p>ä¸ºäº†æ–¹ä¾¿åœ°è®¿é—® <code>MyBox</code> å†…çš„æ•°æ®ï¼Œåˆ©ç”¨Rustè‡ªåŠ¨è§£å¼•ç”¨çš„ç‰¹æ€§ï¼Œæˆ‘ä»¬å¯ä»¥å®ç° <code>Deref</code> å’Œ <code>DerefMut</code> è¿™2ä¸ª <code>trait</code> ï¼š</p>
<pre><code class="language-rust">use core::ops::{Deref, DerefMut};

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        unsafe { &amp;*self.inner }
    }
}

impl&lt;T&gt; DerefMut for MyBox&lt;T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        unsafe { &amp;mut *self.inner }
    }
}
</code></pre>
<p>ç„¶åä¾¿å¯ä»¥ä½¿ç”¨ <code>*</code> è§£å¼•ç”¨æ“ä½œç¬¦å®ç°å¯¹å†…éƒ¨æ•°æ®çš„è®¿é—®ï¼š</p>
<pre><code class="language-rust">fn main() {
	let mut a = MyBox::new(1);
	*a = 2;
}
</code></pre>
<p>æœ€åå¯ä»¥å®ç° <code>fmt::Debug</code> å’Œ <code>fmt::Display</code> 2ä¸ª <code>trait</code> æ¥æ‰“å°å†…éƒ¨çš„æ•°æ®ï¼š</p>
<pre><code class="language-rust">impl&lt;T: fmt::Debug&gt; fmt::Debug for MyBox&lt;T&gt; {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        fmt::Debug::fmt(&amp;**self, f)
    }
}

impl&lt;T: fmt::Display&gt; fmt::Display for MyBox&lt;T&gt; {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        fmt::Display::fmt(&amp;**self, f)
    }
}

fn main() {
	let mut a = MyBox::new(1);
	*a = 2;
	println!(&quot;{}&quot;, a);
}
</code></pre>
<h3 id="éªŒè¯å†…å­˜çš„å›æ”¶">éªŒè¯å†…å­˜çš„å›æ”¶</h3>
<p>æˆ‘ä»¬å¯ä»¥åœ¨è‡ªå®šä¹‰å†…å­˜åˆ†é…å™¨æ—¶ï¼Œé€šè¿‡è®°å½•å·²åˆ†é…çš„å†…å­˜å¤§å°æ¥è¿½è¸ªå†…å­˜çš„åˆ†é…å’Œå›æ”¶æƒ…å†µï¼š</p>
<pre><code class="language-rust">use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};

struct MyAllocator;

static ALLOCATED: AtomicUsize = AtomicUsize::new(0);

unsafe impl GlobalAlloc for MyAllocator {
    unsafe fn alloc(&amp;self, layout: Layout) -&gt; *mut u8 {
        let ret = System.alloc(layout);
        if !ret.is_null() {
            ALLOCATED.fetch_add(layout.size(), SeqCst);
        }
        ret
    }

    unsafe fn dealloc(&amp;self, ptr: *mut u8, layout: Layout) {
        System.dealloc(ptr, layout);
        ALLOCATED.fetch_sub(layout.size(), SeqCst);
    }
}

#[global_allocator]
static GLOBAL: MyAllocator = MyAllocator;
</code></pre>
<p>æµ‹è¯•ä¸‹å¾ªç¯åˆ›å»º 1_000_000 ä¸ª <code>MyBox</code> å®ä¾‹ï¼š</p>
<pre><code class="language-rust">fn main() {
	let i in 0..1_000_000 {
		let _ = MyBox::new(i);
	}
	println!(&quot;allocated bytes: {}&quot;, ALLOCATED.load(SeqCst));
}
</code></pre>
<p>è¿è¡Œç¨‹åºï¼š</p>
<pre><code class="language-bash">$ cargo run
</code></pre>
<pre><code class="language-none">allocated bytes: 285
</code></pre>
<p>å¦‚æœæˆ‘ä»¬æ³¨é‡Šæ‰ææ„æ–¹æ³•çš„å†…å­˜é‡Šæ”¾æ“ä½œï¼š</p>
<pre><code class="language-rust">impl&lt;T&gt; Drop for MyBox&lt;T&gt; {
    fn drop(&amp;mut self) {
        //let layout = Layout:ğŸ†•:&lt;T&gt;();
        //unsafe {
        //    dealloc(self.inner as *mut u8, layout);
        //}
    }
}
</code></pre>
<p>å†æ¬¡è¿è¡Œç¨‹åºçš„ç»“æœï¼š</p>
<pre><code class="language-none">allocated bytes: 4000285
</code></pre>
<p>è¯´æ˜æˆ‘ä»¬çš„å®ç°ç¡®å®å®ç°äº†å†…å­˜çš„åŠ¨æ€åˆ†é…å’Œå›æ”¶ã€‚</p>]]></content>
		</item>
		
		<item>
			<title>ä¸ä½¿ç”¨Rustæ ‡å‡†åº“ç¼–å†™ä¸€ä¸ªå¯è¿è¡Œçš„ç¨‹åº</title>
			<link>/posts/rust-no-std/</link>
			<pubDate>Wed, 01 Jul 2020 00:02:35 +0800</pubDate>
			
			<guid>/posts/rust-no-std/</guid>
			<description>&lt;p&gt;Rustæ˜¯ä¸€é—¨ç³»ç»Ÿç¼–ç¨‹è¯­è¨€ï¼Œæ¯”å¦‚ä½¿å¾—ç¼–å†™æ“ä½œç³»ç»Ÿå†…æ ¸å˜å¾—å¯èƒ½ã€‚è€Œåœ¨ç¼–å†™å†…æ ¸æ—¶ï¼Œæ˜¯ä¸èƒ½æœ‰ä»»ä½•å’Œæ“ä½œç³»ç»Ÿç›¸å…³çš„ä¾èµ–çš„ï¼Œå› ä¸ºæ“ä½œç³»ç»Ÿå†…æ ¸æ˜¯è¿è¡Œäºè£¸æœºä¹‹ä¸Šçš„ï¼Œè¿™å°±åƒé¸¡å’Œé¸¡è›‹çš„å…³ç³»ã€‚è€Œæ ‡å‡†åº“çš„å®ç°æ˜¯åŸºäºæ“ä½œç³»ç»Ÿçš„ï¼Œè¯¸å¦‚çº¿ç¨‹ã€æ–‡ä»¶ã€ç½‘ç»œç­‰ç­‰ã€‚å› æ­¤åœ¨ç¼–å†™å†…æ ¸ä»£ç æ—¶ä¸èƒ½ä½¿ç”¨æ ‡å‡†åº“ã€‚è¿™ç¯‡æ–‡ç« å°†ä»‹ç»å¦‚ä½•ä¸ä½¿ç”¨Rustæ ‡å‡†åº“ç¼–å†™ä¸€ä¸ªå¯è¿è¡Œçš„ç¨‹åºã€‚&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>Rustæ˜¯ä¸€é—¨ç³»ç»Ÿç¼–ç¨‹è¯­è¨€ï¼Œæ¯”å¦‚ä½¿å¾—ç¼–å†™æ“ä½œç³»ç»Ÿå†…æ ¸å˜å¾—å¯èƒ½ã€‚è€Œåœ¨ç¼–å†™å†…æ ¸æ—¶ï¼Œæ˜¯ä¸èƒ½æœ‰ä»»ä½•å’Œæ“ä½œç³»ç»Ÿç›¸å…³çš„ä¾èµ–çš„ï¼Œå› ä¸ºæ“ä½œç³»ç»Ÿå†…æ ¸æ˜¯è¿è¡Œäºè£¸æœºä¹‹ä¸Šçš„ï¼Œè¿™å°±åƒé¸¡å’Œé¸¡è›‹çš„å…³ç³»ã€‚è€Œæ ‡å‡†åº“çš„å®ç°æ˜¯åŸºäºæ“ä½œç³»ç»Ÿçš„ï¼Œè¯¸å¦‚çº¿ç¨‹ã€æ–‡ä»¶ã€ç½‘ç»œç­‰ç­‰ã€‚å› æ­¤åœ¨ç¼–å†™å†…æ ¸ä»£ç æ—¶ä¸èƒ½ä½¿ç”¨æ ‡å‡†åº“ã€‚è¿™ç¯‡æ–‡ç« å°†ä»‹ç»å¦‚ä½•ä¸ä½¿ç”¨Rustæ ‡å‡†åº“ç¼–å†™ä¸€ä¸ªå¯è¿è¡Œçš„ç¨‹åºã€‚</p>
<h3 id="ç¦ç”¨æ ‡å‡†åº“">ç¦ç”¨æ ‡å‡†åº“</h3>
<p>é»˜è®¤æƒ…å†µä¸‹ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨ä¸ºæˆ‘ä»¬çš„é¡¹ç›®å¼•ç”¨æ ‡å‡†åº“ï¼Œå› æ­¤é¦–å…ˆç¬¬ä¸€æ­¥æ˜¯è¦ç¦ç”¨æ ‡å‡†åº“ï¼Œå¯ä»¥ä½¿ç”¨ <code>#![no_std]</code> è¿™ä¸ª <code>crate-level attribute</code> æ¥ç¦ç”¨æ ‡å‡†åº“ï¼š</p>
<pre><code class="language-rust">#![no_std]

fn main() {
    println!(&quot;Hello, World!&quot;);
}
</code></pre>
<p>å¦‚æœæˆ‘ä»¬ç°åœ¨å°è¯•è¿è¡Œå®ƒçš„è¯ï¼Œä¼šå¾—åˆ°ä¸‹é¢çš„é”™è¯¯ï¼š</p>
<pre><code class="language-bash">$ cargo build
</code></pre>
<pre><code class="language-none">error: cannot find macro `println` in this scope
 --&gt; src/main.rs:4:5
  |
4 |     println!(&quot;Hello world!&quot;);
  |     ^^^^^^^

error: `#[panic_handler]` function required, but not found

error: language item required, but not found: `eh_personality`

error: aborting due to 3 previous errors

error: could not compile `panic-hander`.

To learn more, run the command again with --verbose.
</code></pre>
<p>è¿™é‡Œä¸€å…±æœ‰3ä¸ªé”™è¯¯ï¼Œç¬¬1ä¸ªï¼š</p>
<pre><code class="language-none">error: cannot find macro `println` in this scope
</code></pre>
<p>è¿™ä¸ªé”™è¯¯æ˜¯å› ä¸º <code>println!</code> è¿™ä¸ªå®æ˜¯å®šä¹‰åœ¨æ ‡å‡†åº“ <code>std::println</code> é‡Œçš„ï¼Œè€Œæˆ‘ä»¬ç¦ç”¨äº†æ ‡å‡†åº“ï¼Œè‡ªç„¶æ— æ³•å†ä½¿ç”¨å®ƒã€‚</p>
<p>ç¬¬2ä¸ªï¼š</p>
<pre><code class="language-none">error: `#[panic_handler]` function required, but not found
</code></pre>
<p>é»˜è®¤æƒ…å†µä¸‹çš„Rustç¨‹åºæ˜¯å¸¦æœ‰ä¸€ä¸ªéå¸¸å°çš„Runtimeçš„ï¼Œå…¶ä¸­åŒ…æ‹¬è®¾ç½®äº†panicå¼‚å¸¸å¤„ç†ï¼šæ‰“å°å¯¼è‡´å¼‚å¸¸çš„backtraceã€‚å¦‚æœä¸ä½¿ç”¨æ ‡å‡†åº“çš„è¯ï¼Œå°±éœ€è¦æˆ‘ä»¬è‡ªå·±è®¾ç½®ä¸€ä¸ªpanicå¼‚å¸¸å¤„ç†å‡½æ•°ï¼š</p>
<pre><code class="language-rust">#![no_std]

use core::panic::PanicInfo;

fn main() {}

#[panic_handler]
fn panic_handler(info: &amp;PanicInfo) -&gt; ! {
    loop {}
}
</code></pre>
<p>è¿™ä¸ªå¼‚å¸¸å¤„ç†å‡½æ•°çš„è¿”å›å€¼æ˜¯ä¸ª <a href="https://doc.rust-lang.org/std/primitive.never.html">never</a> ç±»å‹ï¼Œè¿™ä¸ªå‡½æ•°ä¸èƒ½è¢«å…¶ä»–å‡½æ•°è°ƒç”¨ã€‚å¯ä»¥å…ˆå†™ä¸ª <code>loop {}</code> ä½œä¸ºå‡½æ•°å®ç°ï¼Œå‚æ•° <code>PanicInfo</code> åˆ™åŒ…å«äº†å‘ç”Ÿå¼‚å¸¸çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚</p>
<p>ç¬¬3ä¸ªï¼š</p>
<pre><code class="language-none">error: language item required, but not found: `eh_personality`
</code></pre>
<p>æç¤ºç¼ºå°‘ä¸€ä¸ª <code>eh_personality</code> çš„è¯­è¨€é¡¹ã€‚é»˜è®¤æƒ…å†µä¸‹å½“å‡½æ•°å‘ç”Ÿpanicæ—¶ï¼Œçº¿ç¨‹ä¼šåœæ­¢ï¼ŒRustå±•å¼€çº¿ç¨‹æ ˆï¼Œå¹¶ææ„æ ˆä¸Šçš„å˜é‡ã€‚è¿™æ˜¯å› ä¸ºRustæ”¯æŒæ•è·å¼‚å¸¸ï¼Œè€Œä¸ºäº†é˜²æ­¢å½“å‡½æ•°å¼‚å¸¸é€€å‡ºæ—¶ï¼Œæ²¡æœ‰ææ„æ ˆä¸Šå˜é‡è€Œå¯¼è‡´å†…å­˜æˆ–å…¶ä»–ç³»ç»Ÿèµ„æºçš„æ³„æ¼ã€‚åŒæ ·çš„ï¼Œåœ¨ä¸ä½¿ç”¨æ ‡å‡†åº“æ—¶ï¼Œéœ€è¦æˆ‘ä»¬è‡ªå·±å®ç°ä¸€ä¸ª <code>eh_personality</code> ã€‚</p>
<pre><code class="language-rust">#![no_std]
#![feature(lang_items)]

use core::panic::PanicInfo;

fn main() {}

#[panic_handler]
fn panic_handler(info: &amp;PanicInfo) -&gt; ! {
    loop {}
}

#[lang = &quot;eh_personality&quot;]
pub extern &quot;C&quot; fn rust_eh_personality() {}
</code></pre>
<p>å†æ¬¡ç¼–è¯‘æ—¶ï¼š</p>
<pre><code class="language-none">error: requires `start` lang_item
</code></pre>
<p>æç¤ºç¼ºå°‘ä¸€ä¸ª <code>start</code> è¯­è¨€é¡¹ã€‚åœ¨æ­£å¸¸æƒ…å†µä¸‹ <code>main</code> å‡½æ•°æ˜¯ä½œä¸ºRustç¨‹åºçš„å…¥å£ï¼Œå…¶å®ä¸ç„¶ï¼Œåœ¨ <code>main</code> å‡½æ•°æ‰§è¡Œå‰ï¼Œéœ€è¦å…ˆå®Œæˆæ‰§è¡Œç¯å¢ƒçš„åˆå§‹åŒ–ï¼Œå¦‚æ ˆçš„åˆ›å»ºï¼Œå‚æ•°ä¿å­˜åˆ°å¯¹åº”çš„å¯„å­˜å™¨ä¸­ï¼Œè¿™äº›æ“ä½œæ˜¯åœ¨Cåº“çš„å…¥å£å‡½æ•°ä¸­å®Œæˆçš„ï¼Œç„¶åCåº“å†è°ƒç”¨Rustçš„Runtimeå…¥å£å‡½æ•°ï¼Œè¯¥å‡½æ•°è¢« <code>start</code> è¯­è¨€é¡¹æ ‡è®°ï¼ŒRuntimeåœ¨å®Œæˆä¸€äº›åˆå§‹åŒ–é…ç½®åï¼Œå†è°ƒç”¨ç”¨æˆ·å®šä¹‰çš„ <code>main</code> å‡½æ•°ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦é‡æ–°å®ç°æœ€å¼€å§‹çš„å…¥å£å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°ä¾èµ–äºå…·ä½“çš„æ“ä½œç³»ç»Ÿã€‚å½“ç„¶ï¼Œåœ¨è¿™ä¸ªä¹‹å‰å…ˆéœ€è¦ç¦ç”¨é»˜è®¤çš„ <code>main</code> å‡½æ•°ï¼š</p>
<pre><code class="language-rust">#![no_main]
</code></pre>
<p>åœ¨Linuxä¸Šå…¥å£å‡½æ•°æ˜¯ <code>_start</code>ï¼š</p>
<pre><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn _start(_argc: isize, _argv: *const *const u8) -&gt; i32 {
	0
}
</code></pre>
<p>åœ¨Macä¸Šæ˜¯ <code>main</code>ï¼š</p>
<pre><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn main(_argc: isize, _argv: *const *const u8) -&gt; i32 {
	0
}
</code></pre>
<p><code>no_mangle</code> æ˜¯ä¸ºäº†é˜²æ­¢ç¼–è¯‘å™¨ä¿®æ”¹ç¬¦å·ã€‚</p>
<p>æˆ‘åœ¨Macä¸Šç¼–è¯‘æ—¶ï¼š</p>
<pre><code class="language-none">ld: dynamic main executables must link with libSystem.dylib for architecture x86_64
</code></pre>
<p>è¿™æ˜¯å› ä¸ºMacå¹³å°ä¸å…è®¸é™æ€é“¾æ¥åˆ°äºŒè¿›åˆ¶åº“ï¼Œéœ€è¦æ·»åŠ ç¼–è¯‘å™¨å‚æ•°ï¼š</p>
<pre><code class="language-bash">$ cargo rustc -- -C link-arg=-lSystem
</code></pre>
<p>å¦‚æœæ˜¯åœ¨Linuxä¸Šç¼–è¯‘çš„è¯ï¼š</p>
<pre><code class="language-none">/src/main.rs:8: multiple definition of `_start'; /usr/lib/gcc/x86_64-pc-linux-gnu/10.1.0/../../../../lib/Scrt1.o:(.text+0x0): first defined here
          /usr/bin/ld: /usr/lib/gcc/x86_64-pc-linux-gnu/10.1.0/../../../../lib/Scrt1.o: in function `_start':
          (.text+0x16): undefined reference to `__libc_csu_fini'
          /usr/bin/ld: (.text+0x1d): undefined reference to `__libc_csu_init'
          /usr/bin/ld: (.text+0x24): undefined reference to `main'
          /usr/bin/ld: (.text+0x2a): undefined reference to `__libc_start_main'
          collect2: error: ld returned 1 exit status
</code></pre>
<p>å› ä¸ºç¼–è¯‘å™¨è¿˜æ˜¯é“¾æ¥äº†Cåº“çš„ç¬¦å·ï¼Œå¹¶ä¸”å’Œæˆ‘ä»¬çš„å…¥å£å‡½æ•°å‘ç”Ÿäº†å†²çªï¼Œéœ€è¦æ·»åŠ ç¼–è¯‘å™¨å‚æ•°ï¼š</p>
<pre><code class="language-bash">$ cargo rustc -- -C link-args=-nostartfiles -lc
</code></pre>
<p>é¡ºåˆ©ç¼–è¯‘é€šè¿‡ï¼</p>
<h3 id="hello-world-å‘¢">Hello, World å‘¢ï¼Ÿ</h3>
<p>ç”±äºæˆ‘ä»¬çš„ç¨‹åºä»€ä¹ˆéƒ½æ²¡æœ‰åšï¼Œå› æ­¤è¿è¡Œä¸ä¼šäº§ç”Ÿä»»ä½•æ•ˆæœï¼ˆå½“ç„¶ä¹Ÿä¸ä¼šæŠ¥é”™ï¼‰ã€‚</p>
<p>å¦‚æœæˆ‘ä»¬æƒ³æ‰“å° <code>Hello, World</code> çš„è¯ï¼Œå¯ä»¥å€Ÿç”¨ <code>libc</code> è¿™ä¸ªåº“ï¼š</p>
<pre><code class="language-toml">libc = &quot;0.2.71&quot;
</code></pre>
<pre><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn main(_argc: isize, _argv: *const *const u8) -&gt; i32 {
    unsafe {
        libc::printf(b&quot;Hello, World!\n&quot; as *const _ as *const libc::c_char);
    }
    0
}
</code></pre>
<p>ç¼–è¯‘åè¿è¡Œï¼š</p>
<pre><code class="language-none">Hello, World!
</code></pre>
<p>æˆ‘ä»¬æ¥å¤„ç†ä¸‹panicï¼Œç„¶åå°è¯•è§¦å‘ä¸‹panicï¼š</p>
<pre><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn main(_nargs: i32, _args: *const *const u8) -&gt; i32 {
    unsafe {
        libc::printf(b&quot;Hello, World!\n&quot; as *const _ as *const libc::c_char);
    }
    panic!(&quot;panic&quot;);
    0
}

#[panic_handler]
fn panic_handler(info: &amp;PanicInfo) -&gt; ! {
    if let Some(l) = info.location() {
        unsafe {
            libc::printf(
                b&quot;\npanic at %s:%d\n&quot; as *const _ as *const libc::c_char,
                l.file().as_bytes() as *const _ as *const libc::c_char,
                l.line() as libc::uint32_t,
            );
        }
    }
    unsafe { libc::exit(0) }
}
</code></pre>
<p>è¿è¡Œçš„ç»“æœï¼š</p>
<pre><code class="language-rust">Hello, World!
panicsrc/main.rs
panic at src/main.rs:12
</code></pre>
<p>ç¬¬3è¡Œæ˜¯æˆ‘ä»¬æ‰“å°çš„å¼‚å¸¸å¤„ç†ã€‚ç¬¬2è¡Œæ˜¯ç¼–è¯‘å™¨ä¸ºæˆ‘ä»¬åŠ çš„ã€‚</p>
<h3 id="ç»“å°¾">ç»“å°¾</h3>
<p>å¥½äº†ï¼Œåˆ°è¿™é‡Œå°±å·²ç»å®ç°äº†ä¸€ä¸ªä¸å¸¦æ ‡å‡†åº“çš„Rustç¨‹åºã€‚è™½ç„¶æ¯”å¹³æ—¶å†™çš„Rustç¨‹åºå¤šäº†äº›ä¸œè¥¿ï¼Œä½†å…¶å®æ˜¯æ ‡å‡†åº“ä¸ºæˆ‘ä»¬åšäº†å¾ˆå¤šï¼Œç°åœ¨åªæ˜¯æˆ‘ä»¬è‡ªå·±å»å®Œæˆè¿™äº›ç½¢äº†ã€‚Rustæ˜¯åå‰¯å…¶å®çš„ç³»ç»Ÿçº§ç¼–ç¨‹è¯­è¨€ï¼Œè™½ç„¶å­¦ä¹ æ›²çº¿æœ‰äº›é™¡å³­ï¼Œä½†æ˜¯éšç€æ·±å…¥ç†è§£ï¼Œè¿™äº›éƒ½æ˜¯Rustçš„ç›®æ ‡æ‰€åœ¨ï¼ŒRustæ˜¯è¿‘å‡ åå¹´é‡Œå‡ºç°çš„çœŸæ­£ä¸ºè§£å†³ç³»ç»Ÿç¼–ç¨‹é—®é¢˜è€Œè®¾è®¡çš„å‡ºè‰²è¯­è¨€ã€‚</p>]]></content>
		</item>
		
		<item>
			<title>Rustè¿‡ç¨‹å®ï¼ˆä¸€ï¼‰</title>
			<link>/posts/rust-procedural-macro-1/</link>
			<pubDate>Sat, 27 Jun 2020 17:22:04 +0800</pubDate>
			
			<guid>/posts/rust-procedural-macro-1/</guid>
			<description>&lt;h3 id=&#34;rustå®&#34;&gt;Rustå®&lt;/h3&gt;
&lt;p&gt;å®å±äºå…ƒç¼–ç¨‹ï¼Œç”¨äºç”Ÿæˆä»£ç ï¼Œå‡å°‘é‡å¤ä»£ç çš„ç¼–å†™ï¼ŒåŒæ—¶ä¸åŒäºè¿è¡Œæ—¶åå°„ï¼Œå®ä¼šåœ¨ç¼–è¯‘æ—¶è¢«å±•å¼€ï¼Œæ²¡æœ‰è¿è¡Œæ—¶å¼€é”€ã€‚åœ¨Rustä¸­ï¼Œå®å¤§ä½“åˆ†ä¸º2ç±»ï¼šå£°æ˜å®å’Œè¿‡ç¨‹å®ã€‚&lt;/p&gt;
&lt;p&gt;å£°æ˜å®è¾ƒä¸ºç®€å•ï¼Œç±»ä¼¼æ¨¡å¼åŒ¹é…ï¼Œåˆ©ç”¨é€’å½’å’Œæ›¿æ¢æŠŠé‡å¤çš„ä»£ç ç‰‡æ®µéšè—èµ·æ¥ï¼Œå…¸å‹çš„å®ç°æ˜¯æ ‡å‡†åº“ä¸­ &lt;code&gt;vec!&lt;/code&gt;ï¼Œ&lt;code&gt;println!&lt;/code&gt;ã€‚&lt;/p&gt;
&lt;p&gt;è¿‡ç¨‹å®åˆ™ç¨å¾®å¤æ‚ï¼Œä½†æ˜¯åŠŸèƒ½å¼ºå¤§çš„å¤šï¼Œå¯ä»¥ç²¾ç¡®åœ°æ§åˆ¶è¯­æ³•æ ‘çš„ç”Ÿæˆã€‚åŒæ—¶è¿‡ç¨‹å®ä½¿ç”¨Rustä»£ç ç¼–å†™ï¼Œçµæ´»æ€§å’Œè¡¨è¾¾èƒ½åŠ›ä¸°å¯Œã€‚è¿‡ç¨‹å®ç»å¸¸è¢«ç”¨äº3ç§æƒ…æ™¯ä¸‹ï¼š&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;è‡ªåŠ¨å®ç° &lt;code&gt;trait&lt;/code&gt;ï¼Œä½¿ç”¨ &lt;code&gt;derive&lt;/code&gt; æ´¾ç”Ÿå®&lt;/li&gt;
&lt;li&gt;è£…é¥° &lt;code&gt;field&lt;/code&gt; æˆ– å‡½æ•°ï¼Œä½¿ç”¨ &lt;code&gt;attribute&lt;/code&gt; å±æ€§å®&lt;/li&gt;
&lt;li&gt;å®ç° &lt;code&gt;DSL&lt;/code&gt;ï¼Œä½¿ç”¨ &lt;code&gt;function&lt;/code&gt; å‡½æ•°å®&lt;/li&gt;
&lt;/ol&gt;</description>
			<content type="html"><![CDATA[<h3 id="rustå®">Rustå®</h3>
<p>å®å±äºå…ƒç¼–ç¨‹ï¼Œç”¨äºç”Ÿæˆä»£ç ï¼Œå‡å°‘é‡å¤ä»£ç çš„ç¼–å†™ï¼ŒåŒæ—¶ä¸åŒäºè¿è¡Œæ—¶åå°„ï¼Œå®ä¼šåœ¨ç¼–è¯‘æ—¶è¢«å±•å¼€ï¼Œæ²¡æœ‰è¿è¡Œæ—¶å¼€é”€ã€‚åœ¨Rustä¸­ï¼Œå®å¤§ä½“åˆ†ä¸º2ç±»ï¼šå£°æ˜å®å’Œè¿‡ç¨‹å®ã€‚</p>
<p>å£°æ˜å®è¾ƒä¸ºç®€å•ï¼Œç±»ä¼¼æ¨¡å¼åŒ¹é…ï¼Œåˆ©ç”¨é€’å½’å’Œæ›¿æ¢æŠŠé‡å¤çš„ä»£ç ç‰‡æ®µéšè—èµ·æ¥ï¼Œå…¸å‹çš„å®ç°æ˜¯æ ‡å‡†åº“ä¸­ <code>vec!</code>ï¼Œ<code>println!</code>ã€‚</p>
<p>è¿‡ç¨‹å®åˆ™ç¨å¾®å¤æ‚ï¼Œä½†æ˜¯åŠŸèƒ½å¼ºå¤§çš„å¤šï¼Œå¯ä»¥ç²¾ç¡®åœ°æ§åˆ¶è¯­æ³•æ ‘çš„ç”Ÿæˆã€‚åŒæ—¶è¿‡ç¨‹å®ä½¿ç”¨Rustä»£ç ç¼–å†™ï¼Œçµæ´»æ€§å’Œè¡¨è¾¾èƒ½åŠ›ä¸°å¯Œã€‚è¿‡ç¨‹å®ç»å¸¸è¢«ç”¨äº3ç§æƒ…æ™¯ä¸‹ï¼š</p>
<ol>
<li>è‡ªåŠ¨å®ç° <code>trait</code>ï¼Œä½¿ç”¨ <code>derive</code> æ´¾ç”Ÿå®</li>
<li>è£…é¥° <code>field</code> æˆ– å‡½æ•°ï¼Œä½¿ç”¨ <code>attribute</code> å±æ€§å®</li>
<li>å®ç° <code>DSL</code>ï¼Œä½¿ç”¨ <code>function</code> å‡½æ•°å®</li>
</ol>
<h3 id="è¿‡ç¨‹å®çš„ç¼–å†™">è¿‡ç¨‹å®çš„ç¼–å†™</h3>
<p>è¿‡ç¨‹å®çš„æ„å»ºæœ‰ç‰¹æ®Šçš„è§„åˆ™ï¼Œè¿‡ç¨‹å®çš„å®šä¹‰å¿…é¡»ç½®äºç‹¬ç«‹çš„ <code>crate</code> ä¸­ï¼Œå¹¶ä¸”éœ€è¦æŒ‡æ˜ <code>lib</code> å¼€å¯ <code>proc-macro</code> ã€‚</p>
<p>é¦–å…ˆåˆ›å»ºä¸€ä¸ª <code>mymacro</code> çš„ <code>lib</code> é¡¹ç›®ï¼š</p>
<pre><code class="language-bash">$ cargo new mymacro --lib
</code></pre>
<p>ç„¶åå†åœ¨ <code>mymacro</code> å†…åˆ›å»ºä¸ª <code>mymacro_derive</code> çš„ <code>lib</code> é¡¹ç›®ï¼š</p>
<pre><code class="language-bash">$ cd mymacro
$ cargo new mymacro_derive --lib
</code></pre>
<p>åœ¨ <code>mymacro/Cargo.toml</code> å†…æ·»åŠ  <code>mymacro_derive</code> çš„ä¾èµ–ï¼š</p>
<pre><code class="language-toml">[dependencies]
mymacro_derive = { path = &quot;mymacro_derive&quot; }
</code></pre>
<p>åœ¨ <code>mymacro/mymacro_derive/Cargo.toml</code> å†…å¼€å¯ <code>proc-macro</code>ï¼š</p>
<pre><code class="language-toml">[lib]
proc-macro = true
</code></pre>
<p>åœ¨ <code>mymacro/mymacro_derive/src/lib.rs</code> ä¸­éœ€è¦å¼•å…¥ <code>proc_macro</code> ï¼š</p>
<pre><code class="language-rust">extern crate proc_macro;
</code></pre>
<p>æ¥ä¸‹æ¥å°±å¯ä»¥å®ç°æˆ‘ä»¬çš„è¿‡ç¨‹å®äº†ã€‚å…ˆä» <code>derive</code> æ´¾ç”Ÿå® å¼€å§‹å§ã€‚</p>
<h3 id="derive-æ´¾ç”Ÿå®"><code>derive</code> æ´¾ç”Ÿå®</h3>
<p><code>derive</code> æ´¾ç”Ÿå®å¯ä»¥è‡ªåŠ¨å®ç°æˆ‘ä»¬çš„è‡ªå®šä¹‰ <code>trait</code>ï¼Œä¸ºæ­¤æˆ‘ä»¬å…ˆåœ¨ <code>mymacro/src/lib.rs</code> å®šä¹‰æˆ‘ä»¬çš„ <code>trait</code>ï¼š</p>
<pre><code class="language-rust">pub trait MyMacro {
    fn show_fields();
}
</code></pre>
<p>ç„¶ååœ¨ <code>mymacro/mymacro_derive/src/lib.rs</code> ä¸‹é¢å®ç°æˆ‘ä»¬çš„ä»£ç ï¼š</p>
<pre><code class="language-rust">extern crate proc_macro;

use proc_macro::TokenStream;

#[proc_macro_derive(MyMacro)]
pub fn mymacro_derive(input: TokenStream) -&gt; TokenStream {
    todo!()
}
</code></pre>
<p><code>#[proc_macro_derive(MyMacro)]</code> æŒ‡ç¤ºæˆ‘ä»¬ä¸º <code>MyMacro</code> å®ç° <code>derive</code> æ´¾ç”Ÿå®ï¼›å‡½æ•° <code>mymacro_derive</code> çš„å‚æ•°å’Œè¿”å›å€¼éƒ½æ˜¯ <code>proc_macro::TokenStream</code> æ ‡è®°æµã€‚</p>
<p>ä¸è¿‡ç›´æ¥æ“ä½œ <code>proc_macro::TokenStream</code> ååˆ†ä¸ä¾¿ï¼Œä¸ºæ­¤æœ‰2ä¸ª <code>crate</code> å¯ä»¥å¸®åŠ©æˆ‘ä»¬ï¼š<code>syn</code> å’Œ <code>quote</code>ã€‚<code>syn</code> å¯ä»¥å¸®æˆ‘ä»¬æŠŠæ ‡è®°æµè½¬æ¢æˆè¯­æ³•æ ‘ï¼Œ<code>quote</code> å¯ä»¥å†æŠŠ <code>syn</code> çš„æ•°æ®ç»“æ„è½¬æ¢å›æ ‡è®°æµã€‚æˆ‘ä»¬æ·»åŠ ä¸‹ <code>syn</code> å’Œ <code>quote</code> çš„ä¾èµ–ï¼š</p>
<pre><code class="language-toml">[dependencies]
syn = { version = &quot;1.0&quot;, features = [ &quot;extra-traits&quot; ] }
quote = &quot;1.0&quot;
</code></pre>
<p>æŠŠæ ‡è®°æµè½¬æ¢ä¸ºè¯­æ³•æ ‘ï¼š</p>
<pre><code class="language-rust">use syn::DeriveInput;

#[proc_macro_derive(MyMacro)]
pub fn mymacro_derive(input: TokenStream) -&gt; TokenStream {
    let ast: DeriveInput = syn::parse(input).unwrap();
    dbg!(ast);
    todo!()
}
</code></pre>
<p>è¿™é‡Œæˆ‘ä»¬æŠŠè½¬æ¢åçš„è¯­æ³•æ ‘æ‰“å°äº†å‡ºæ¥ï¼ˆéœ€è¦åœ¨ <code>sync</code> ä¾èµ–ä¸­å¯ç”¨ <code>extra-traits</code> è¿™ä¸ª <code>feature</code>ï¼‰ã€‚</p>
<p>åœ¨ <code>mymacro/src/lib.rs</code> ä¸­å†™ä¸ªæµ‹è¯•ï¼š</p>
<pre><code class="language-rust">pub use mymacro_derive::*;

// --snip--

#[derive(MyMacro)]
struct Dog {
	name: String,
	age: u8,
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
	fn dog_show() {
        Dog::show_fields();
	}
}
</code></pre>
<p>æ‰§è¡Œæµ‹è¯•ï¼š</p>
<pre><code class="language-bash">$ cargo test dog_show
</code></pre>
<p>ä¼šå¾—åˆ°ä¸‹é¢çš„è¾“å‡ºï¼š</p>
<pre><code class="language-none">[mymacro_derive/src/lib.rs:9] ast = DeriveInput {
    attrs: [],
    vis: Inherited,
    ident: Ident {
        ident: &quot;Dog&quot;,
        span: #0 bytes(131..134),
    },
    generics: Generics {
        lt_token: None,
        params: [],
        gt_token: None,
        where_clause: None,
    },
    data: Struct(
...
error: proc-macro derive panicked
 --&gt; src/lib.rs:9:14
  |
9 |     #[derive(MyMacro)]
  |              ^^^^^^^
  |
  = help: message: not yet implemented
...
</code></pre>
<p>å› ä¸ºæˆ‘ä»¬è¿˜æ²¡æœ‰å…·ä½“å®ç°ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨æç¤ºç¼–è¯‘å¤±è´¥ã€‚ä¸è¿‡æˆ‘ä»¬å¯ä»¥åœ¨å…¶ä¸­çœ‹åˆ° <code>ast</code> ä¸­çš„å¾ˆå¤šæœ‰ç”¨çš„å†…å®¹ã€‚</p>
<p>æˆ‘ä»¬åˆ©ç”¨ <code>ast</code> ä¸­çš„ä¿¡æ¯å®ç° <code>MyMacro</code> ä¸­çš„ <code>show_fields</code> å…³è”æ–¹æ³•ï¼š</p>
<pre><code class="language-rust">extern crate proc_macro;

use proc_macro::TokenStream;
use quote::quote;
use syn::{Data, DeriveInput, Type};

#[proc_macro_derive(MyMacro)]
pub fn mymacro_derive(input: TokenStream) -&gt; TokenStream {
    let ast: DeriveInput = syn::parse(input).unwrap();

    // æå–ç»“æ„åç§°
    let name = ast.ident;

    // åªæ”¯æŒä¸ºç»“æ„ç±»å‹æ´¾ç”Ÿ
    let fields = if let Data::Struct(s) = ast.data {
        s.fields
    } else {
        panic!(&quot;derive MyMacro must on struct&quot;);
    };

    // æå–æ‰€æœ‰å±æ€§åç§°åŠå…¶ç±»å‹
    let fields: Vec&lt;String&gt; = fields
        .into_iter()
        .map(|f| {
            let f_name = f.ident.unwrap();
            let f_type = f.ty;

            let p = if let Type::Path(p) = f_type {
                p
            } else {
                panic!(&quot;field type must be Path&quot;);
            };

            let f_type: Vec&lt;String&gt; = p
                .path
                .segments
                .into_iter()
                .map(|s| s.ident.to_string())
                .collect();
            let f_type = f_type.join(&quot;::&quot;);

            format!(&quot;{}: {}&quot;, f_name, f_type)
        })
        .collect();

    // æ ¼å¼åŒ–æˆæ–‡æœ¬
    let fields_txt = format!(
        r#&quot;{{
    {}
}}&quot;#,
        fields.join(&quot;\n    &quot;)
    );

    // ä¸ºè¾“å…¥çš„ç»“æ„å®ç° MyMacro
    let gen = quote! {
        impl MyMacro for #name {
            fn show_fields() {
                println!(&quot;{}&quot;, #fields_txt);
            }
        }
    };

    // è¾“å‡º TokenStream
    TokenStream::from(gen)
}
</code></pre>
<p><code>quote!</code> è¿™ä¸ªå®å¸®åŠ©æˆ‘ä»¬ä»¥Rustçš„è¯­æ³•æ–¹å¼ç”Ÿæˆéœ€è¦è¾“å‡ºçš„ç»“æ„ï¼Œå¹¶ä¸”æä¾›äº† <code>#</code> æ¨¡æ¿è¯­æ³•ï¼Œå°†åå­—æ›¿æ¢æˆå¯¹åº”çš„å€¼ï¼Œæœ€åå°†ç”Ÿæˆçš„ç»“æ„è¾“å‡ºæˆæ ‡è®°æµã€‚</p>
<p>å†è¿è¡Œä¸‹æµ‹è¯•ï¼š</p>
<pre><code class="language-bash">$ cargo test dog_show -- --nocapture
</code></pre>
<p>è¾“å‡ºå¦‚ä¸‹ï¼š</p>
<pre><code class="language-none">...
running 1 test
{
    name: String
    age: u8
}
test test::dog_show ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>æˆåŠŸè¾“å‡ºäº† <code>Dog</code> ç»“æ„çš„æ‰€æœ‰å±æ€§åç§°åŠç±»å‹ã€‚æˆ‘ä»¬å¯ä»¥è¿è¡Œä»¥ä¸‹å‘½ä»¤æ‰“å°å‡ºå±•å¼€åçš„ä»£ç ï¼š</p>
<pre><code class="language-bash">$ cargo rustc -- -Z unstable-options --pretty=expanded
</code></pre>
<pre><code class="language-rust">#![feature(prelude_import)]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std;
pub use mymacro_derive::*;

pub trait MyMacro {
    fn show_fields();
}

struct Dog {
    name: String,
    age: u8,
}
impl MyMacro for Dog {
    fn show_fields() {


        {
            ::std::io::_print(::core::fmt::Arguments::new_v1(&amp;[&quot;&quot;, &quot;\n&quot;],
                                                             &amp;match (&amp;&quot;{\n    name: String\n    age: u8\n}&quot;,)
                                                                  {
                                                                  (arg0,) =&gt;
                                                                  [::core::fmt::ArgumentV1::new(arg0,
                                                                                                ::core::fmt::Display::fmt)],
                                                              }));
        };
    }
}
</code></pre>
<p>å¯ä»¥çœ‹åˆ°å±•å¼€åçš„ä»£ç ï¼Œç¼–è¯‘å™¨å·²ç»ä¸ºæˆ‘ä»¬å®ç°äº† <code>MyMacro</code>ï¼Œ<code>show_fields</code> æ–¹æ³•æ‰“å°å‡ºäº† <code>Dog</code> ç»“æ„çš„æ‰€æœ‰å±æ€§ã€‚</p>
<p>åˆ©ç”¨ <code>derive</code> æ´¾ç”Ÿå®å¯ä»¥æ–¹ä¾¿åœ°ä¸ºæˆ‘ä»¬è‡ªåŠ¨å®ç° <code>trait</code> ï¼Œè®¿é—®ç»“æ„çš„å…ƒä¿¡æ¯ï¼Œå¹¶ä¸”ä¸ä¼šæœ‰ä»»ä½•è¿è¡Œæ—¶å¼€é”€ï¼</p>
<p>å¾…ç»­ &hellip;</p>]]></content>
		</item>
		
		<item>
			<title>Rusté—­åŒ…</title>
			<link>/posts/rust-closure/</link>
			<pubDate>Tue, 23 Jun 2020 22:59:21 +0800</pubDate>
			
			<guid>/posts/rust-closure/</guid>
			<description>&lt;h3 id=&#34;é—­åŒ…closureçš„å®ç°åŸç†&#34;&gt;é—­åŒ…(Closure)çš„å®ç°åŸç†&lt;/h3&gt;
&lt;p&gt;é—­åŒ…åœ¨è°ƒç”¨å½¢å¼ä¸Šå’Œå‡½æ•°éå¸¸ç›¸ä¼¼ï¼š&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ä¼ é€’å‚æ•°&lt;/li&gt;
&lt;li&gt;æ‰§è¡Œä¸€æ®µä»£ç &lt;/li&gt;
&lt;li&gt;è¿”å›ç»“æœ&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ä½†æ˜¯é—­åŒ…å¯ä»¥æ•è·å½“å‰ä¸Šä¸‹æ–‡ç¯å¢ƒä¸­çš„å˜é‡ï¼Œè€Œå‡½æ•°ä¸å¯ä»¥ï¼ˆè®¿é—®å…¨å±€é™æ€å˜é‡é™¤å¤–ï¼Œä½†æ˜¯è¿™å’Œé—­åŒ…çš„å®ç°å®Œå…¨ä¸ä¸€æ ·ï¼‰ã€‚&lt;/p&gt;
&lt;p&gt;é—­åŒ…çš„åˆ›å»ºå’Œè°ƒç”¨ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let env_var = 1;
let fn1 = |x| x + env_var;

let result1 = fn1(2);
assert_eq!(result1, 3);

let result2 = fn1(3);
assert_eq!(result2, 4);
&lt;/code&gt;&lt;/pre&gt;</description>
			<content type="html"><![CDATA[<h3 id="é—­åŒ…closureçš„å®ç°åŸç†">é—­åŒ…(Closure)çš„å®ç°åŸç†</h3>
<p>é—­åŒ…åœ¨è°ƒç”¨å½¢å¼ä¸Šå’Œå‡½æ•°éå¸¸ç›¸ä¼¼ï¼š</p>
<ol>
<li>ä¼ é€’å‚æ•°</li>
<li>æ‰§è¡Œä¸€æ®µä»£ç </li>
<li>è¿”å›ç»“æœ</li>
</ol>
<p>ä½†æ˜¯é—­åŒ…å¯ä»¥æ•è·å½“å‰ä¸Šä¸‹æ–‡ç¯å¢ƒä¸­çš„å˜é‡ï¼Œè€Œå‡½æ•°ä¸å¯ä»¥ï¼ˆè®¿é—®å…¨å±€é™æ€å˜é‡é™¤å¤–ï¼Œä½†æ˜¯è¿™å’Œé—­åŒ…çš„å®ç°å®Œå…¨ä¸ä¸€æ ·ï¼‰ã€‚</p>
<p>é—­åŒ…çš„åˆ›å»ºå’Œè°ƒç”¨ï¼š</p>
<pre><code class="language-rust">let env_var = 1;
let fn1 = |x| x + env_var;

let result1 = fn1(2);
assert_eq!(result1, 3);

let result2 = fn1(3);
assert_eq!(result2, 4);
</code></pre>
<p>ç¼–è¯‘å™¨åœ¨ç¼–è¯‘è¿‡ç¨‹ä¸­ä¼šåˆ›å»ºå¯¹åº”çš„åŒ¿åç»“æ„ï¼Œå¹¶æ ¹æ®éœ€è¦å®ç°ä¸‰ä¸ª <code>trait</code>ï¼š<a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html">FnOnce</a>ã€<a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html">FnMut</a>ã€<a href="https://doc.rust-lang.org/std/ops/trait.Fn.html">Fn</a> ï¼Œè€Œé—­åŒ…çš„åˆ›å»ºå°±æ˜¯è¯¥åŒ¿åç»“æ„çš„å®ä¾‹åŒ–ï¼Œé—­åŒ…è°ƒç”¨åˆ™æ˜¯3ä¸ª <code>trait</code> çš„æ–¹æ³•è°ƒç”¨ã€‚</p>
<p>ä»¥ä¸‹æ˜¯3ä¸ª <code>trait</code> çš„å®šä¹‰ï¼š</p>
<pre><code class="language-rust">pub trait FnOnce&lt;Args&gt; {
    /// The returned type after the call operator is used.
    #[stable(feature = &quot;fn_once_output&quot;, since = &quot;1.12.0&quot;)]
    type Output;

    /// Performs the call operation.
    #[unstable(feature = &quot;fn_traits&quot;, issue = &quot;29625&quot;)]
    extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;
}

pub trait FnMut&lt;Args&gt;: FnOnce&lt;Args&gt; {
    /// Performs the call operation.
    #[unstable(feature = &quot;fn_traits&quot;, issue = &quot;29625&quot;)]
    extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;
}

pub trait Fn&lt;Args&gt;: FnMut&lt;Args&gt; {
    /// Performs the call operation.
    #[unstable(feature = &quot;fn_traits&quot;, issue = &quot;29625&quot;)]
    extern &quot;rust-call&quot; fn call(&amp;self, args: Args) -&gt; Self::Output;
}
</code></pre>
<p>å…¶ä¸­ <code>Args</code> ä¸ºé—­åŒ…å‚æ•°ç±»å‹ï¼Œä½¿ç”¨å…ƒç»„ ( <code>Tuple</code>) æ¥è¡¨ç¤ºå‚æ•°åˆ—è¡¨ï¼Œ<code>Output</code> æ˜¯è¿”å›å€¼ç±»å‹ã€‚</p>
<p>å¹¶ä¸”å¯ä»¥å‘ç° <code>FnMut</code> æ´¾ç”Ÿè‡ª <code>FnOnce</code>ï¼Œè€Œ <code>Fn</code> åˆæ´¾ç”Ÿè‡ª <code>FnMut</code>ï¼Œè¿™é‡Œéœ€è¦è¿™æ ·ç†è§£ï¼š</p>
<p><em><strong>å¦‚æœä¸€ä¸ªå‡½æ•°æ¥æ”¶ä¸€ä¸ª <code>FnOnce</code> å‚æ•°ï¼Œæ€»å¯ä»¥ä¼ é€’ä¸€ä¸ª <code>FnMut</code></strong></em><br>
<em><strong>å¦‚æœä¸€ä¸ªå‡½æ•°æ¥æ”¶ä¸€ä¸ª <code>FnMut</code>ï¼Œæ€»å¯ä»¥ä¼ é€’ä¸€ä¸ª <code>Fn</code></strong></em></p>
<p>æˆ‘ä»¬å¯ä»¥æ‰‹åŠ¨æ„é€ ä¸€ä¸ª <code>FnOnce</code> é—­åŒ…ç»“æ„å®ç°ï¼š</p>
<pre><code class="language-rust">#![feature(unboxed_closures)]
#![feature(fn_traits)]

use std::ops::{Fn, FnMut, FnOnce};

struct MyFn {
    env_var: String,
}

impl FnOnce&lt;(i32, i32)&gt; for MyFn {
    type Output = String;
	
    extern &quot;rust-call&quot; fn call_once(self, args: (i32, i32)) -&gt; Self::Output {
        println!(&quot;{}&quot;, args.0 + args.1);
        self.env_var
    }
}

fn main() {
    let env_var = String::from(&quot;env_var&quot;);
    let my_fn = MyFn { env_var, };
	
    let o1: String = my_fn(1, 1); // è¿™é‡Œè°ƒç”¨ call_once æ–¹æ³•, my_fn å˜é‡ move è¿›æ–¹æ³•
	assert_eq!(o1, String::from(&quot;env_var&quot;));
	
	let o2: String = my_fn(2, 2); // ç¼–è¯‘ä¸è¿‡ï¼Œå› ä¸º my_fn å˜é‡å·²ç»è¢« move æ‰äº†
}
</code></pre>
<p>æ¥ç€ä¸º <code>MyFn</code> å®ç° <code>FnMut</code>ï¼š</p>
<pre><code class="language-rust">// ...
struct MyFn&lt;'a&gt; {
    env_var: &amp;'a str,
}

impl&lt;'a&gt; FnOnce&lt;(i32, i32)&gt; for MyFn&lt;'a&gt; {
    type Output = String;
    extern &quot;rust-call&quot; fn call_once(mut self, args: (i32, i32)) -&gt; Self::Output {
        self.call_mut(args)
    }
}

impl&lt;'a&gt; FnMut&lt;(i32, i32)&gt; for MyFn&lt;'a&gt; {
    extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: (i32, i32)) -&gt; Self::Output {
        println!(&quot;{}&quot;, args.0 + args.1);
        self.env_var.to_owned()
    }
}

fn main() {
    let env_var = String::from(&quot;env_var&quot;);
    let mut my_fn = MyFn { env_var: &amp;env_var };
	
    let o1: String = my_fn(1, 1); // è¿™é‡Œè°ƒç”¨ call_mut æ–¹æ³•, my_fn å˜é‡ mut borrow è¿›æ–¹æ³•
	assert_eq!(o1, String::from(&quot;env_var&quot;));
	
	let o2: String = my_fn(2, 2); // è¿˜æ˜¯è°ƒç”¨ call_mut æ–¹æ³•ï¼Œmy_fn å˜é‡ä¾ç„¶æœ‰æ•ˆ
	assert_eq!(o2, String::from(&quot;env_var&quot;));
}
</code></pre>
<p>è¿™é‡Œå¯ä»¥çœ‹åˆ°ï¼Œå¦‚æœæŸä¸ªå‚æ•°å¦‚æœéœ€è¦è°ƒç”¨ <code>call_once</code> æ–¹æ³•çš„è¯ï¼Œ<code>call_once</code> å†…éƒ¨åªè¦å†æ¬¡è°ƒç”¨ <code>call_mut</code> å³å¯ï¼Œå› ä¸ºä¸€ä¸ª <code>Ownership</code> æ€»å¯ä»¥è½¬æˆä¸€ä¸ª <code>Mut Borrow</code>ï¼ŒåŒç† <code>Mut Borrow</code> æ€»å¯ä»¥è½¬æˆ <code>Borrow</code> ã€‚</p>
<p>æµ‹è¯•ä¸€ä¸ªå‡½æ•°æ¥å— <code>FnOnce</code>ï¼Œä¼ é€’ä¸€ä¸ª <code>FnMut</code>ï¼š</p>
<pre><code class="language-rust">// ...
fn expect_fn_once&lt;F&gt;(f: F)
where
    F: FnOnce&lt;(i32, i32), Output = String&gt;,
{
    let _: String = f(1, 2); // è¿™é‡Œè°ƒç”¨çš„æ˜¯ call_once
}

fn main() {
    let env_var = String::from(&quot;env_var&quot;);
    let my_fn = MyFn { env_var: &amp;env_var };
	
	expect_fn_once(my_fn); // å› ä¸º my_fn å®ç°äº† FnOnceï¼Œæ‰€ä»¥å¯ä»¥ä½œä¸ºå‚æ•°ä¼ é€’
}
</code></pre>
<p>å¦å¤–ï¼Œ<code>FnOnce</code> ã€<code>FnMut</code> ã€<code>Fn</code> æœ‰3ä¸ªè¯­æ³•ç³–è¡¨ç¤ºï¼š</p>
<p><code>FnOnce(T1, T2) -&gt; T3</code> å¯ä»¥ç”¨æ¥è¡¨ç¤º <code>FnOnce&lt;(T1, T2), Output = T3&gt;</code></p>
<p>å› æ­¤ä¸Šé¢çš„ <code>expect_fn_once</code> æ–¹æ³•å¯ä»¥ç®€å†™ä¸ºï¼š</p>
<pre><code class="language-rust">fn expect_fn_once(f: impl FnOnce(i32, i32) -&gt; String)
{
    let _: String = f(1, 2);
}
</code></pre>
<p><code>FnMut</code> ã€<code>Fn</code> åŒç†ã€‚</p>
<h3 id="ç¼–è¯‘å™¨é—­åŒ…çš„ç”Ÿæˆè§„åˆ™">ç¼–è¯‘å™¨é—­åŒ…çš„ç”Ÿæˆè§„åˆ™</h3>
<ol>
<li>å¦‚æœé—­åŒ…åªéœ€è¦ä¸Šä¸‹æ–‡ç¯å¢ƒçš„ <code>Borrow</code> ï¼Œä¼˜å…ˆç”Ÿæˆ <code>Fn</code> ï¼Œæ–¹æ³•é»˜è®¤è°ƒç”¨ <code>call</code> ï¼Œå› ä¸ºä¸Šä¸‹æ–‡ç¯å¢ƒå¯ä»¥è¢«åŒæ—¶ <code>Borrow</code> å¤šæ¬¡ï¼Œä¾‹å¦‚ï¼š</li>
</ol>
<pre><code class="language-rust">let a = 1;

let fn1 = || {
	let _ = &amp;a;
};

let fn2 = || {
	let _ = &amp;a;
};

println!(&quot;{}&quot;, a);
</code></pre>
<ol start="2">
<li>å¦‚æœé—­åŒ…éœ€è¦ä¸Šä¸‹æ–‡ç¯å¢ƒçš„ <code>Mut Borrow</code>ï¼Œåˆ™ç”Ÿæˆ <code>FnMut</code>ï¼Œæ–¹æ³•é»˜è®¤è°ƒç”¨ <code>call_mut</code>ï¼Œå› ä¸ºä¸ä¼šä¸¢å¤± <code>Ownership</code>ï¼Œé—­åŒ…å¯ä»¥è¢«å¤šæ¬¡è°ƒç”¨ï¼Œä¸Šä¸‹æ–‡ç¯å¢ƒ <code>Mut Borrow</code> è¿›é—­åŒ…ç»“æ„ï¼Œå½“é—­åŒ…è¢« <code>drop</code> æ‰åï¼Œå¤–éƒ¨æ‰èƒ½å†æ¬¡ä½¿ç”¨è¢«æ•è·çš„å˜é‡ï¼Œä¾‹å¦‚ï¼š</li>
</ol>
<pre><code class="language-rust">let mut a = 1;

let fn1 = || {
	let _ = &amp;mut a;
};

let fn2 = || {
	let _ = &amp;a; // è¿™é‡Œæ— æ³•ç¼–è¯‘é€šè¿‡ï¼Œå› ä¸º f1 å·²ç» mut borrow äº† a
};

fn1();

println!(&quot;{}&quot;, a);
</code></pre>
<ol start="3">
<li>å¦‚æœé—­åŒ…éœ€è¦ä¸Šä¸‹æ–‡çš„ <code>Ownership</code>ï¼Œåˆ™ç”Ÿæˆ <code>FnOcne</code>ï¼Œæ–¹æ³•è°ƒç”¨ <code>call_once</code>ï¼Œå› ä¸ºè°ƒç”¨é—­åŒ…ä¼šå¯¼è‡´å¤±å» <code>Ownership</code> ï¼Œæ‰€ä»¥é—­åŒ…åªèƒ½è°ƒç”¨ä¸€æ¬¡ï¼Œä¸Šä¸‹æ–‡ç¯å¢ƒè¢« <code>move</code> è¿›é—­åŒ…ï¼Œå¤–éƒ¨ä¸å†èƒ½ä½¿ç”¨è¢«æ•è·çš„å˜é‡ï¼Œä¾‹å¦‚ï¼š</li>
</ol>
<pre><code class="language-rust">let a = String::from(&quot;a&quot;);

let fn1 = || {
	let b: String = a;
	b
};

let fn2 = || {
	let b: String = a; // è¿™é‡Œæ— æ³•ç¼–è¯‘é€šè¿‡ï¼Œå› ä¸º a å˜é‡å·²ç»è¢« move è¿›äº† fn1
};

println!(&quot;{}&quot;, a); // è¿™é‡Œä¹Ÿæ— æ³•ç¼–è¯‘é€šè¿‡
</code></pre>
<p>æœ‰æ—¶æˆ‘ä»¬éœ€è¦å¼ºåˆ¶æ•è·å˜é‡çš„ <code>Ownership</code> ï¼Œå¯ä»¥åœ¨é—­åŒ…ä¸Šä¿®é¥° <code>move</code> å…³é”®å­—ï¼Œè¿™åœ¨å¤šçº¿ç¨‹/å¼‚æ­¥ç¯å¢ƒä¸‹å¾ˆå¸¸è§ã€‚</p>]]></content>
		</item>
		
		<item>
			<title>å…³äºGo Mysql Driverå¼•å…¥QueryContextå¸¦æ¥çš„æ•°æ®ç«äº‰</title>
			<link>/posts/go-mysql-driver-race/</link>
			<pubDate>Sun, 24 May 2020 14:50:06 +0800</pubDate>
			
			<guid>/posts/go-mysql-driver-race/</guid>
			<description>&lt;p&gt;åœ¨&lt;a href=&#34;/posts/go-mysql-driver-eof/&#34;&gt;å…³äºGo Mysql Driverçš„unexpected EOFé”™è¯¯&lt;/a&gt;é‡Œæåˆ°äº†è¿æ¥æ± ï¼Œå½“è¿æ¥&lt;strong&gt;ä½¿ç”¨å®Œæ¯•&lt;/strong&gt;åä¼šæ”¾å›è¿æ¥æ± ä»¥ä¾¿å…¶ä»–çš„æ“ä½œå¯ä»¥å¤ç”¨è¿™æ¡è¿æ¥ã€‚è¿™é‡Œçš„&lt;strong&gt;ä½¿ç”¨å®Œæ¯•&lt;/strong&gt;æœ‰éå¸¸æ˜ç¡®çš„å®šä¹‰ï¼šå‘é€ç¼“å†²åŒºä¸­ä¸å†æœ‰æœªå‘é€çš„æŒ‡ä»¤ï¼Œæ¥æ”¶ç¼“å†²åŒºä¸å†æœ‰æœªæ¥æ”¶çš„æ•°æ®ï¼Œä¸‹æ¬¡èƒ½è¯»å–çš„æ•°æ®å¿…é¡»æ˜¯ä¸‹ä¸€æ¬¡å‘é€çš„æŒ‡ä»¤çš„å“åº”ã€‚&lt;/p&gt;
&lt;p&gt;é€šå¸¸æƒ…å†µä¸‹çš„SQLæ“ä½œå¦‚ä¸‹ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;rows, err := db.Query(&amp;quot;SELECT a, b FROM some_table&amp;quot;)
if err != nil {
    return err
}
defer rows.Close()

for rows.Next() {
    var a, b string
    if err := rows.Scan(&amp;amp;a, &amp;amp;b); err != nil {
        return err
    }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;</description>
			<content type="html"><![CDATA[<p>åœ¨<a href="/posts/go-mysql-driver-eof/">å…³äºGo Mysql Driverçš„unexpected EOFé”™è¯¯</a>é‡Œæåˆ°äº†è¿æ¥æ± ï¼Œå½“è¿æ¥<strong>ä½¿ç”¨å®Œæ¯•</strong>åä¼šæ”¾å›è¿æ¥æ± ä»¥ä¾¿å…¶ä»–çš„æ“ä½œå¯ä»¥å¤ç”¨è¿™æ¡è¿æ¥ã€‚è¿™é‡Œçš„<strong>ä½¿ç”¨å®Œæ¯•</strong>æœ‰éå¸¸æ˜ç¡®çš„å®šä¹‰ï¼šå‘é€ç¼“å†²åŒºä¸­ä¸å†æœ‰æœªå‘é€çš„æŒ‡ä»¤ï¼Œæ¥æ”¶ç¼“å†²åŒºä¸å†æœ‰æœªæ¥æ”¶çš„æ•°æ®ï¼Œä¸‹æ¬¡èƒ½è¯»å–çš„æ•°æ®å¿…é¡»æ˜¯ä¸‹ä¸€æ¬¡å‘é€çš„æŒ‡ä»¤çš„å“åº”ã€‚</p>
<p>é€šå¸¸æƒ…å†µä¸‹çš„SQLæ“ä½œå¦‚ä¸‹ï¼š</p>
<pre><code class="language-go">rows, err := db.Query(&quot;SELECT a, b FROM some_table&quot;)
if err != nil {
    return err
}
defer rows.Close()

for rows.Next() {
    var a, b string
    if err := rows.Scan(&amp;a, &amp;b); err != nil {
        return err
    }
    // ...
}
</code></pre>
<ol>
<li><code>db.Query</code> è¿”å›ä¸€ä¸ª <code>Rows</code> æ¸¸æ ‡å¯¹è±¡</li>
<li>æ³¨å†Œä¸€ä¸ª <code>rows.Close</code> å»¶è¿Ÿå‡½æ•°ç”¨äºå…³é—­ <code>Rows</code> å¯¹è±¡</li>
<li>é€šè¿‡ <code>rows.Next</code> è¿­ä»£å™¨è¯»å–æ¯ä¸€è¡Œæ•°æ®</li>
<li>é€šè¿‡ <code>rows.Scan</code> å°†å½“å‰è¡Œçš„æ•°æ®å­˜å…¥å£°æ˜çš„å˜é‡ä¸­</li>
</ol>
<p>æ•´ä¸ªä»£ç ç‰‡æ®µä¼šæœ‰2ç§ç»“æœ</p>
<ol>
<li>è¯»å–äº†æ‰€æœ‰æ•°æ®</li>
<li>æœªè¯»å–æˆ–è¯»å–äº†éƒ¨åˆ†æ•°æ®ï¼Œç„¶åå‘ç”Ÿé”™è¯¯</li>
</ol>
<p>ç¬¬ä¸€ç§æƒ…å†µç”±äºè¯»å–äº†æ‰€æœ‰æ•°æ®ï¼Œæ»¡è¶³<strong>ä½¿ç”¨å®Œæ¯•</strong>çš„æ¡ä»¶ï¼Œå¯ä»¥æ”¾å›è¿æ¥æ± ï¼›ç¬¬äºŒç§æƒ…å†µï¼Œç”±äºå‘ç”Ÿäº†é”™è¯¯ï¼Œè¿æ¥å¤±æ•ˆï¼Œåç»­ä¼šé‡æ–°æ‰“å¼€æ–°è¿æ¥ï¼Œæ–°è¿æ¥è‡ªç„¶æ˜¯æ»¡è¶³<strong>ä½¿ç”¨å®Œæ¯•</strong>æ¡ä»¶çš„ã€‚</p>
<p>å¦‚æœåœ¨ <code>rows.Next</code> è¿­ä»£å™¨ä¸­ï¼Œä¸­é€”é€€å‡ºï¼ˆæœªå‘ç”Ÿé”™è¯¯çš„æƒ…å†µä¸‹ï¼‰ï¼Œé‚£æ¥æ”¶ç¼“å†²åŒºä¸­è¿˜æœ‰æœªè¯»å–çš„æ•°æ®ï¼Œå› æ­¤å¯¹åº”çš„SQLé©±åŠ¨éœ€è¦åœ¨ <code>rows.Close</code> æ–¹æ³•ä¸­å†²åˆ·æ‰è¿˜æœªè¯»å–çš„æ•°æ®ï¼Œç›´è‡³ç¼“å†²åŒºä¸­è¯»å–è‡³EOFä¸ºæ­¢ã€‚å¦‚æœ <code>rows.Close</code> ä¸è¢«è°ƒç”¨ï¼Œä¸ä½†æ¥æ”¶ç¼“å†²åŒºä¸­æœ‰æ®‹ç•™çš„æ•°æ®ï¼ŒåŒæ—¶è¿æ¥ä¹Ÿä¸ä¼šè¢«æ”¾å›è¿æ¥æ± ï¼Œåˆ‡è®°ä¸å¯é—å¿˜ <code>rows.Close</code> è°ƒç”¨ã€‚</p>
<p>åœ¨ <a href="https://golang.org/pkg/database/sql/">database/sql</a> å¼•å…¥ <code>QueryContext</code> åï¼Œæ‰§è¡ŒSQLæ“ä½œæ—¶ï¼Œä¼šå•ç‹¬åˆ›å»ºä¸€ä¸ªæ–°çš„Goroutineç”¨äºè¶…æ—¶å–æ¶ˆï¼š</p>
<pre><code class="language-go">func (rs *Rows) initContextClose(ctx, txctx context.Context) {
	if ctx.Done() == nil &amp;&amp; (txctx == nil || txctx.Done() == nil) {
		return
	}
	if bypassRowsAwaitDone {
		return
	}
	ctx, rs.cancel = context.WithCancel(ctx)
	go rs.awaitDone(ctx, txctx)
}

// awaitDone blocks until either ctx or txctx is canceled. The ctx is provided
// from the query context and is canceled when the query Rows is closed.
// If the query was issued in a transaction, the transaction's context
// is also provided in txctx to ensure Rows is closed if the Tx is closed.
func (rs *Rows) awaitDone(ctx, txctx context.Context) {
	var txctxDone &lt;-chan struct{}
	if txctx != nil {
		txctxDone = txctx.Done()
	}
	select {
	case &lt;-ctx.Done():
	case &lt;-txctxDone:
	}
	rs.close(ctx.Err())
}
</code></pre>
<p>è¿™æ ·åœ¨ <code>Context</code> è¶…æ—¶å–æ¶ˆåï¼Œè¿™ä¸ªå•ç‹¬çš„Goroutineä¼šé©¬ä¸Šæ‰§è¡Œ <code>rows.Close</code> ï¼Œå†²åˆ·ç¼“å†²åŒºåæŠŠè¿æ¥æ”¾å›è¿æ¥æ± ï¼Œé˜²æ­¢å› ä¸šåŠ¡Goroutineé•¿æœŸé˜»å¡å¯¼è‡´è¿æ¥æ— æ³•æ”¾å›è¿æ¥æ± ã€‚</p>
<pre><code class="language-go">func (rs *Rows) close(err error) error {
	rs.closemu.Lock()
	defer rs.closemu.Unlock()

	if rs.closed {
		return nil
	}
	rs.closed = true

	if rs.lasterr == nil {
		rs.lasterr = err
	}

	withLock(rs.dc, func() {
		err = rs.rowsi.Close()
	})
	if fn := rowsCloseHook(); fn != nil {
		fn(rs, &amp;err)
	}
	if rs.cancel != nil {
		rs.cancel()
	}

	if rs.closeStmt != nil {
		rs.closeStmt.Close()
	}
	rs.releaseConn(err)
	return err
}
</code></pre>
<p>ä½†æ˜¯å½“è¿™ä¸ªGoroutineæ­£åœ¨å†²åˆ·ç¼“å†²åŒºçš„åŒæ—¶ï¼Œä¸šåŠ¡Goroutineæ­£åœ¨æ‰§è¡Œ <code>rows.Scan</code> æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•ä¼šè¯»å–ç¼“å†²åŒºä¸­çš„æ•°æ®ï¼Œè¿™é‡Œå°±å‘ç”Ÿäº†2ä¸ªGoroutineçš„æ•°æ®ç«äº‰ã€‚ä½†æ˜¯å’Œ <code>rows.Next</code> æ–¹æ³•å´ä¸ä¼šå¯¼è‡´æ•°æ®ç«äº‰ï¼Œæ˜¯å› ä¸º <code>rows.Next</code> å’Œ <code>rows.Close</code> ä½¿ç”¨äº†äº’æ–¥é”ä¿æŠ¤ä¸´ç•ŒåŒºã€‚<code>rows.Scan</code> å¹¶æ²¡æœ‰ä¿æŠ¤ <code>convertAssignRows</code> æ–¹æ³•ï¼ŒåŒæ—¶ <a href="https://pkg.go.dev/github.com/go-sql-driver/mysql?tab=doc">github.com/go-sql-driver/mysql</a> ä¸ºäº†æ€§èƒ½ï¼Œå…±äº«äº†ç¼“å†²åŒºå’Œ <code>lastcols</code> çš„å†…å­˜ã€‚</p>
<pre><code class="language-go">func (rs *Rows) close(err error) error {
	rs.closemu.Lock()
	defer rs.closemu.Unlock()

	if rs.closed {
		return nil
	}
	rs.closed = true

	if rs.lasterr == nil {
		rs.lasterr = err
	}

	withLock(rs.dc, func() {
		err = rs.rowsi.Close()
	})
	if fn := rowsCloseHook(); fn != nil {
		fn(rs, &amp;err)
	}
	if rs.cancel != nil {
		rs.cancel()
	}

	if rs.closeStmt != nil {
		rs.closeStmt.Close()
	}
	rs.releaseConn(err)
	return err
}

func (rs *Rows) Next() bool {
	var doClose, ok bool
	withLock(rs.closemu.RLocker(), func() {
		doClose, ok = rs.nextLocked()
	})
	if doClose {
		rs.Close()
	}
	return ok
}

func (rs *Rows) Scan(dest ...interface{}) error {
	rs.closemu.RLock()

	if rs.lasterr != nil &amp;&amp; rs.lasterr != io.EOF {
		rs.closemu.RUnlock()
		return rs.lasterr
	}
	if rs.closed {
		err := rs.lasterrOrErrLocked(errRowsClosed)
		rs.closemu.RUnlock()
		return err
	}
	rs.closemu.RUnlock()

	if rs.lastcols == nil {
		return errors.New(&quot;sql: Scan called without calling Next&quot;)
	}
	if len(dest) != len(rs.lastcols) {
		return fmt.Errorf(&quot;sql: expected %d destination arguments in Scan, not %d&quot;, len(rs.lastcols), len(dest))
	}
	for i, sv := range rs.lastcols {
		err := convertAssignRows(dest[i], sv, rs)
		if err != nil {
			return fmt.Errorf(`sql: Scan error on column index %d, name %q: %v`, i, rs.rowsi.Columns()[i], err)
		}
	}
	return nil
}
</code></pre>
<p>ä¸ºæ­¤åœ¨ <a href="https://golang.org/doc/go1.10#database/sql/driver">Go 1.10 Release Notes</a> ä¸­ä¸“é—¨æåˆ°ï¼Œé©±åŠ¨å‹¿åœ¨ <code>rows.Close</code> æ–¹æ³•ä¸­ä¿®æ”¹ç¼“å†²åŒºï¼š</p>
<blockquote>
<p>Drivers that currently hold on to the destination buffer provided by driver.Rows.Next should ensure they no longer write to a buffer assigned to the destination array outside of that call. Drivers must be careful that underlying buffers are not modified when closing driver.Rows.</p>
</blockquote>
<p>ä¸ºäº†é¿å…åœ¨è¿™ç§æƒ…å†µä¸‹å‘ç”Ÿæ•°æ®ç«äº‰ï¼Œ<a href="https://github.com/go-sql-driver/mysql/pull/943">PR#943</a> ä½¿ç”¨äº†åŒç¼“å†²æ¥å†²åˆ·ç¼“å†²åŒºã€‚</p>
<pre><code class="language-go">// A buffer which is used for both reading and writing.
// This is possible since communication on each connection is synchronous.
// In other words, we can't write and read simultaneously on the same connection.
// The buffer is similar to bufio.Reader / Writer but zero-copy-ish
// Also highly optimized for this particular use case.
// This buffer is backed by two byte slices in a double-buffering scheme
type buffer struct {
	buf     []byte // buf is a byte buffer who's length and capacity are equal.
	nc      net.Conn
	idx     int
	length  int
	timeout time.Duration
	dbuf    [2][]byte // dbuf is an array with the two byte slices that back this buffer
	flipcnt uint      // flipccnt is the current buffer counter for double-buffering
}

// flip replaces the active buffer with the background buffer
// this is a delayed flip that simply increases the buffer counter;
// the actual flip will be performed the next time we call `buffer.fill`
func (b *buffer) flip() {
	b.flipcnt += 1
}

// fill reads into the buffer until at least _need_ bytes are in it
func (b *buffer) fill(need int) error {
    // ...
    // fill data into its double-buffering target: if we've called
	// flip on this buffer, we'll be copying to the background buffer,
	// and then filling it with network data; otherwise we'll just move
	// the contents of the current buffer to the front before filling it
	dest := b.dbuf[b.flipcnt&amp;1]

	// grow buffer if necessary to fit the whole packet.
	if need &gt; len(dest) {
		// Round up to the next multiple of the default size
		dest = make([]byte, ((need/defaultBufSize)+1)*defaultBufSize)

		// if the allocated buffer is not too large, move it to backing storage
		// to prevent extra allocations on applications that perform large reads
		if len(dest) &lt;= maxCachedBufSize {
			b.dbuf[b.flipcnt&amp;1] = dest
		}
	}

	// if we're filling the fg buffer, move the existing data to the start of it.
	// if we're filling the bg buffer, copy over the data
	if n &gt; 0 {
		copy(dest[:n], b.buf[b.idx:])
	}

	b.buf = dest
    b.idx = 0
    // ...
}

func (rows *mysqlRows) Close() (err error) {
    // ...
    // flip the buffer for this connection if we need to drain it.
	// note that for a successful query (i.e. one where rows.next()
	// has been called until it returns false), `rows.mc` will be nil
	// by the time the user calls `(*Rows).Close`, so we won't reach this
	// see: https://github.com/golang/go/commit/651ddbdb5056ded455f47f9c494c67b389622a47
    mc.buf.flip()
    // ...
}
</code></pre>
<p>å½“è°ƒç”¨ <code>rows.Close</code> æ—¶ï¼Œäº¤æ¢ <code>fg buffer</code> å’Œ <code>bg buffer</code> 2ä¸ªç¼“å†²åŒºï¼Œè¿™æ ·åœ¨å†²åˆ·ç¼“å†²åŒºæ—¶ç”¨åˆ°çš„å°±æ˜¯ <code>bg buffer</code> ï¼Œè€Œ <code>rows.Scan</code> è¯»å–çš„æ˜¯æ—§çš„ <code>fg buffer</code>ï¼Œä»è€Œé¿å…äº†æ•°æ®ç«äº‰ã€‚</p>]]></content>
		</item>
		
		<item>
			<title>å…³äºGo Mysql Driverçš„unexpected EOFé”™è¯¯</title>
			<link>/posts/go-mysql-driver-eof/</link>
			<pubDate>Sat, 23 May 2020 11:55:30 +0800</pubDate>
			
			<guid>/posts/go-mysql-driver-eof/</guid>
			<description>&lt;p&gt;åœ¨ä½¿ç”¨ &lt;a href=&#34;https://pkg.go.dev/github.com/go-sql-driver/mysql?tab=doc&#34;&gt;github.com/go-sql-driver/mysql&lt;/a&gt; ä½œä¸ºå®¢æˆ·ç«¯è¿æ¥Mysqlæ—¶ï¼Œæ—¥å¿—ä¸­å¶ç„¶ä¼šå‡ºç°ä¸‹é¢çš„é”™è¯¯ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;[mysql] 2019/08/26 16:07:00 packets.go:36: unexpected EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/go-sql-driver/mysql?tab=doc&#34;&gt;github.com/go-sql-driver/mysql&lt;/a&gt; ä¸ºäº†å¤ç”¨TCPè¿æ¥ä»¥æé«˜æ€§èƒ½ï¼Œå†…éƒ¨å®ç°äº†è¿æ¥æ± ã€‚å½“éœ€è¦ä¸€æ¬¡SQLæ“ä½œæ—¶ï¼Œä¼šå…ˆä»è¿æ¥æ± ä¸­æ‹¿å‡ºä¸€æ¡å¯ç”¨çš„ç©ºé—²è¿æ¥å»æ‰§è¡Œæ“ä½œã€‚å¦‚æœæ²¡æœ‰ç©ºé—²çš„è¿æ¥ï¼Œæˆ–è€…è¿æ¥å·²ç»å¤±æ•ˆï¼Œå°±æ‰“å¼€ä¸€æ¡æ–°çš„TCPè¿æ¥ã€SSLè®¤è¯ï¼ˆå¦‚æœä½¿ç”¨SSLè¿æ¥çš„è¯ï¼‰ã€åè®®æ¡æ‰‹ã€è®¤è¯ç­‰ï¼Œå®Œæˆåˆå§‹åŒ–è¿æ¥ï¼Œå†ä½¿ç”¨è¿™æ¡è¿æ¥æ‰§è¡Œæ“ä½œï¼Œä½¿ç”¨å®Œåå†æ”¾å›è¿æ¥æ± ã€‚è¿æ¥å¤±æ•ˆçš„æ ‡è®°å¯ä»¥åœ¨ä¸Šä¸€æ¬¡ä½¿ç”¨è¿æ¥åæ ¹æ®å¯¹åº”çš„é”™è¯¯æ¥å®Œæˆï¼Œæˆ–è€…æœ¬æ¬¡æ“ä½œæŒ‡ä»¤å‘é€å¤±è´¥ä¹Ÿæ ‡è®°ä¸ºè¿æ¥å¤±æ•ˆï¼Œdriverä¼šé‡æ–°æ‰§è¡Œä¸Šé¢çš„æ­¥éª¤æ¥è¿›è¡Œé‡è¯•ï¼Œåº”ç”¨å±‚ä¸ä¼šæ„ŸçŸ¥ã€‚&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>åœ¨ä½¿ç”¨ <a href="https://pkg.go.dev/github.com/go-sql-driver/mysql?tab=doc">github.com/go-sql-driver/mysql</a> ä½œä¸ºå®¢æˆ·ç«¯è¿æ¥Mysqlæ—¶ï¼Œæ—¥å¿—ä¸­å¶ç„¶ä¼šå‡ºç°ä¸‹é¢çš„é”™è¯¯ï¼š</p>
<pre><code class="language-none">[mysql] 2019/08/26 16:07:00 packets.go:36: unexpected EOF
</code></pre>
<p><a href="https://pkg.go.dev/github.com/go-sql-driver/mysql?tab=doc">github.com/go-sql-driver/mysql</a> ä¸ºäº†å¤ç”¨TCPè¿æ¥ä»¥æé«˜æ€§èƒ½ï¼Œå†…éƒ¨å®ç°äº†è¿æ¥æ± ã€‚å½“éœ€è¦ä¸€æ¬¡SQLæ“ä½œæ—¶ï¼Œä¼šå…ˆä»è¿æ¥æ± ä¸­æ‹¿å‡ºä¸€æ¡å¯ç”¨çš„ç©ºé—²è¿æ¥å»æ‰§è¡Œæ“ä½œã€‚å¦‚æœæ²¡æœ‰ç©ºé—²çš„è¿æ¥ï¼Œæˆ–è€…è¿æ¥å·²ç»å¤±æ•ˆï¼Œå°±æ‰“å¼€ä¸€æ¡æ–°çš„TCPè¿æ¥ã€SSLè®¤è¯ï¼ˆå¦‚æœä½¿ç”¨SSLè¿æ¥çš„è¯ï¼‰ã€åè®®æ¡æ‰‹ã€è®¤è¯ç­‰ï¼Œå®Œæˆåˆå§‹åŒ–è¿æ¥ï¼Œå†ä½¿ç”¨è¿™æ¡è¿æ¥æ‰§è¡Œæ“ä½œï¼Œä½¿ç”¨å®Œåå†æ”¾å›è¿æ¥æ± ã€‚è¿æ¥å¤±æ•ˆçš„æ ‡è®°å¯ä»¥åœ¨ä¸Šä¸€æ¬¡ä½¿ç”¨è¿æ¥åæ ¹æ®å¯¹åº”çš„é”™è¯¯æ¥å®Œæˆï¼Œæˆ–è€…æœ¬æ¬¡æ“ä½œæŒ‡ä»¤å‘é€å¤±è´¥ä¹Ÿæ ‡è®°ä¸ºè¿æ¥å¤±æ•ˆï¼Œdriverä¼šé‡æ–°æ‰§è¡Œä¸Šé¢çš„æ­¥éª¤æ¥è¿›è¡Œé‡è¯•ï¼Œåº”ç”¨å±‚ä¸ä¼šæ„ŸçŸ¥ã€‚</p>
<p>åˆ°è¿™é‡Œï¼Œå¥½åƒä¸€åˆ‡éƒ½æ²¡æœ‰ä»€ä¹ˆé—®é¢˜ï¼Œå¯æ˜¯ä¸Šé¢çš„é”™è¯¯æ˜¯æ€ä¹ˆå›äº‹ï¼Ÿå¦‚æœæ˜¯è¿æ¥å¤±æ•ˆçš„è¯ï¼Œåº”è¯¥ä¼šè¿›è¡Œé‡è¯•ï¼Œå¯¹åº”ç”¨é€æ˜ã€‚</p>
<p>å…¶å®ä¸Šé¢çš„é”™è¯¯æ¥æºäºæœåŠ¡å™¨ä¸»åŠ¨å…³é—­è¶…æ—¶è¿æ¥é€ æˆçš„TCPåŠå…³é—­çŠ¶æ€ï¼Œé”™è¯¯çš„å½¢æˆåŸå› å¯ä»¥ç”¨ä¸‹é¢çš„å›¾ç®€å•è§£é‡Šï¼š</p>
<figure>
    <img src="/img/go-mysql-driver-eof.svg"/> <figcaption>
            <h4>TCPåŠè¿æ¥çŠ¶æ€</h4>
        </figcaption>
</figure>

<p>å½“éœ€è¦é‡æ–°æ‰“å¼€ä¸€æ¡Mysqlè¿æ¥æ—¶ï¼Œå…ˆæ˜¯å®ŒæˆåŸºæœ¬çš„TCPè¿æ¥æ¡æ‰‹ï¼Œç„¶åå®ŒæˆMysqlçš„åè®®æ¡æ‰‹ã€è®¤è¯ï¼Œä¹‹åå°±å¯ä»¥åœ¨è¿™æ¡è¿æ¥ä¸Šå‘é€æŒ‡ä»¤äº†ã€‚ä¸€æ¬¡æ“ä½œå®Œæˆåï¼Œè¿æ¥è¢«æ”¾å›è¿æ¥æ± ä¸­ï¼Œå¦‚æœä¹‹åä¸€æ®µæ—¶é—´è¿™æ¡è¿æ¥éƒ½æ²¡æœ‰è¢«ä½¿ç”¨è¿‡ï¼ŒMysqlæœåŠ¡å™¨ä¼šæ ¹æ®ç›¸åº”çš„é…ç½®ï¼Œä¸»åŠ¨å…³é—­è¿™æ¡è¿æ¥ã€‚æ­¤æ—¶æœåŠ¡å™¨å†…æ ¸ä¼šå‘å®¢æˆ·ç«¯å†…æ ¸å‘é€ä¸€ä¸ª[FIN, ACK]çš„TCPæ®µï¼Œå®¢æˆ·ç«¯å†…æ ¸å›åº”ä¸€ä¸ªACKæ®µï¼Œæ­¤æ—¶è¿™æ¡TCPè¿æ¥ä¼šè¿›å…¥åŠå…³é—­çŠ¶æ€ï¼šæœåŠ¡å™¨ä¸ä¼šå†å‘å®¢æˆ·ç«¯å‘é€æ•°æ®ï¼Œä½†æ˜¯å®¢æˆ·ç«¯å¯ä»¥å‘æœåŠ¡å™¨å‘é€æ•°æ®ã€‚</p>
<p>æ­¤æ—¶ä¸€ä¸ªæ–°çš„SQLæ“ä½œä»è¿æ¥æ± ä¸­æ‹¿å‡ºäº†è¿™æ¡è¿æ¥ï¼Œå‘é€æŒ‡ä»¤ï¼Œä½†æ˜¯åœ¨è¯»å–çš„æ—¶å€™ï¼Œå®¢æˆ·ç«¯å†…æ ¸å·²ç»çŸ¥é“æœåŠ¡å™¨ä¸ä¼šå†è¿”å›æ•°æ®ï¼Œå› æ­¤ç›´æ¥ç»™åº”ç”¨ç¨‹åºè¿”å›äº†EOFé”™è¯¯ã€‚ç„¶åé‡ç‚¹æ˜¯ï¼Œæ­¤æ—¶çš„è¿æ¥çŠ¶æ€å¹¶ä¸æ˜¯çœŸæ­£æ„ä¹‰ä¸Šçš„æ— æ•ˆè¿æ¥çŠ¶æ€ï¼Œç”±äºå®¢æˆ·ç«¯å·²ç»æŠŠæŒ‡ä»¤å‘é€äº†å‡ºå»ï¼Œå°¤å…¶å¦‚æœæ˜¯ä¸€æ¡UPDATEæŒ‡ä»¤çš„è¯ï¼Œæ˜¯æ— æ³•æ‰§è¡Œå®‰å…¨çš„é‡è¯•æ“ä½œçš„ã€‚æœåŠ¡å™¨å¯¹è¿™æ¡æŒ‡ä»¤çš„å¤„ç†ï¼Œå®¢æˆ·ç«¯æ˜¯å®Œå…¨æ— æ³•çŸ¥æ™“çš„ã€‚</p>
<p>é€šå¸¸ä¸€ç§ç®€å•çš„è§£å†³åŠæ³•æ˜¯ï¼Œè®¾ç½®å®¢æˆ·ç«¯çš„ç©ºé—²è¶…æ—¶æ—¶é—´ï¼Œå¹¶ä¸”çŸ­äºæœåŠ¡å™¨çš„ç©ºé—²è¶…æ—¶æ—¶é—´ï¼Œç„¶è€Œ <a href="https://golang.org/pkg/database/sql/">database/sql</a> å¹¶æ²¡æœ‰æä¾›ç±»ä¼¼&quot;maximum idle duration&quot;çš„APIï¼Œä¸è¿‡å¯ä»¥é€€ä¸€æ­¥ä½¿ç”¨ <a href="https://golang.org/pkg/database/sql/#DB.SetConnMaxLifetime">func (*DB) SetConnMaxLifetime</a> è¿™ä¸ªAPIã€‚ç„¶è€Œå¸¦æ¥çš„åå¤„å°±æ˜¯ï¼Œé™åˆ¶äº†è¿æ¥çš„é‡ç”¨æ—¶é—´ï¼Œå³ä½¿è¿æ¥ä¸€ç›´å¤„äºæ´»è·ƒçŠ¶æ€ã€‚</p>
<p>å¦ä¸€ç§åŠæ³•æ˜¯ï¼Œæ¯æ¬¡ä»è¿æ¥æ± ä¸­æ‹¿å‡ºè¿æ¥ï¼Œåœ¨å‘é€ç¬¬ä¸€æ¡æŒ‡ä»¤å‰å‘é€ä¸€ä¸ª <code>PING</code> åŒ…æ¥æ£€æŸ¥è¿æ¥æ˜¯å¦å¥åº·ï¼Œç”±äº <code>PING</code> åŒ…ä¸ä¼šäº§ç”Ÿå‰¯ä½œç”¨ï¼Œå› æ­¤åç»­çš„æ“ä½œéƒ½æ˜¯å®‰å…¨çš„ã€‚è¿™ç§åŠæ³•çš„åå¤„ä¹Ÿæ˜¾è€Œæ˜“è§ï¼Œç”±äºä»è¿æ¥æ± ä¸­å–å‡ºè¿æ¥æ˜¯ä¸ªéå¸¸é¢‘ç¹çš„æ“ä½œï¼Œè€Œæ¯æ¬¡éƒ½ä¼šå¢åŠ è‡³å°‘ä¸€æ¬¡RTTå»¶è¿Ÿã€‚</p>
<p>å¥½åœ¨ <a href="https://github.com/go-sql-driver/mysql/pull/934">PR#934</a> é€šè¿‡éå¸¸å·§å¦™çš„æ–¹å¼è§£å†³äº†è¿™ä¸€é—®é¢˜ã€‚ä½œè€…çš„è§£å†³æ€è·¯å¦‚ä¸‹ï¼š</p>
<p>é¦–å…ˆéœ€è¦æåˆ°ä¸€ä¸ªGo 1.10å <code>sql/driver</code> å¢åŠ çš„ä¸€ä¸ªæ¥å£ï¼š<a href="https://golang.org/pkg/database/sql/driver/#SessionResetter">driver.SessionResetter</a> ï¼Œå…¶ä¸­ <code>ResetSession</code> æ–¹æ³•ä¼šåœ¨æ¯æ¬¡è¿æ¥æ”¾å…¥è¿æ¥æ± æ—¶æ‰§è¡Œï¼Œè¿™é‡Œä½œè€…å…ˆç®€å•åœ°æ·»åŠ äº†ä¸€ä¸ª <code>reset</code> æ ‡è®°ã€‚</p>
<pre><code class="language-go">type mysqlConn struct {
    // ...
    reset            bool // set when the Go SQL package calls ResetSession
    // ...
}

// ResetSession implements driver.SessionResetter.
// (From Go 1.10)
func (mc *mysqlConn) ResetSession(ctx context.Context) error {
    if mc.closed.IsSet() {
        return driver.ErrBadConn
    }
    mc.reset = true
    return nil
}
</code></pre>
<p>ä¹‹åè¿æ¥è¢«æ‹¿å‡ºæ¥ï¼Œåœ¨æ‰§è¡Œå‘é€ç¬¬ä¸€æ¡æŒ‡ä»¤å‰ï¼Œä¼šå…ˆæ ¹æ®ä¹‹å‰æ·»åŠ çš„ <code>reset</code> æ ‡è®°æ£€æŸ¥è¿æ¥æ˜¯å¦å¯ç”¨ï¼ˆliveness checkï¼‰ï¼Œç”±äºå‰é¢çš„æ ‡è®°æ˜¯è¿æ¥åœ¨æ”¾å…¥è¿æ¥æ± æ—¶åŠ ä¸Šçš„ï¼Œå› æ­¤å¯ä»¥åšåˆ°åªåœ¨ç¬¬ä¸€æ¬¡å–å‡ºåæ£€æŸ¥ï¼ˆæ£€æŸ¥åæŠŠ <code>reset</code> å–æ¶ˆå°±è¡Œï¼‰ï¼Œåç»­åœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­æ— éœ€å†æ£€æŸ¥ï¼Œé™¤éå†æ¬¡è¢«æ”¾å›äº†è¿æ¥æ± ã€‚</p>
<pre><code class="language-go">// Write packet buffer 'data'
func (mc *mysqlConn) writePacket(data []byte) error {
    // ...
    // Perform a stale connection check. We only perform this check for
 	// the first query on a connection that has been checked out of the
 	// connection pool: a fresh connection from the pool is more likely
 	// to be stale, and it has not performed any previous writes that
 	// could cause data corruption, so it's safe to return ErrBadConn
 	// if the check fails.
 	if mc.reset {
 		mc.reset = false
 		conn := mc.netConn
 		if mc.rawConn != nil {
 			conn = mc.rawConn
 		}
 		if err := connCheck(conn); err != nil {
 			errLog.Print(&quot;closing bad idle connection: &quot;, err)
 			mc.Close()
 			return driver.ErrBadConn
 		}
     }
     // ...
}
</code></pre>
<p>è€Œæ£€æŸ¥è¿æ¥æ˜¯å¦å¯ç”¨çš„æ–¹æ³•ç”¨åˆ°äº†Go 1.9å <code>net.Conn</code> å¢åŠ çš„ <code>syscall.Conn</code> æ¥å£ï¼Œè¿™ä¸ªæ¥å£å¯ä»¥è·å–åŸå§‹è¿æ¥çš„æ–‡ä»¶æè¿°ç¬¦ã€‚å…ˆè°ƒç”¨ <code>syscall.Read</code> ï¼Œä¼ å…¥1ä¸ªå­—èŠ‚çš„ç¼“å†²åŒºï¼Œç”±äºè¿˜æ²¡æœ‰å‘é€ä»»ä½•æŒ‡ä»¤ï¼Œå¹¶ä¸”ç”±Go runtimeåˆ›å»ºçš„Socketéƒ½è®¾ç½®äº†éé˜»å¡ï¼ˆO_NONBLOCKï¼‰æ¨¡å¼ï¼Œæ‰€ä»¥æ–¹æ³•ä¼šç«‹å³è¿”å›ã€‚å¦‚æœæ²¡æœ‰è¿”å›é”™è¯¯ï¼ˆæˆ–è€… <code>EAGAIN</code> / <code>EWOULDBLOCK</code> è¿™2ç§é”™è¯¯ï¼‰ä¸”è¯»å–çš„æ•°æ®é•¿åº¦ä¸º0ï¼Œåˆ™è¯´æ˜è¿æ¥ä¾ç„¶æœ‰æ•ˆï¼Œåä¹‹è¿æ¥å·²ç»å¤±æ•ˆã€‚ä¹‹æ‰€ä»¥ä¸ç›´æ¥ä½¿ç”¨Goçš„åŸç”Ÿæ¥å£ <code>net.Conn.Read</code> ï¼Œæ˜¯å› ä¸ºGoçš„è°ƒåº¦å™¨ä¼šç«‹å³ä½¿å½“å‰Goroutineç¡çœ ï¼Œå¯¼è‡´å¤šæ¬¡Goroutineä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œå½±å“æ€§èƒ½ã€‚</p>
<pre><code class="language-go">func connCheck(c net.Conn) error {
 	var (
 		n    int
 		err  error
 		buff [1]byte
 	)

  	sconn, ok := c.(syscall.Conn)
 	if !ok {
 		return nil
 	}
 	rc, err := sconn.SyscallConn()
 	if err != nil {
 		return err
 	}
 	rerr := rc.Read(func(fd uintptr) bool {
 		n, err = syscall.Read(int(fd), buff[:])
 		return true
 	})
 	switch {
 	case rerr != nil:
 		return rerr
 	case n == 0 &amp;&amp; err == nil:
 		return io.EOF
 	case n &gt; 0:
 		return errUnexpectedRead
 	case err == syscall.EAGAIN || err == syscall.EWOULDBLOCK:
 		return nil
 	default:
 		return err
 	}
}
</code></pre>
<p>- å®Œ</p>]]></content>
		</item>
		
		<item>
			<title>å…³äºSocketåº”ç”¨çš„æ€§èƒ½ä¼˜åŒ–</title>
			<link>/posts/socket-optimize/</link>
			<pubDate>Thu, 21 May 2020 21:58:01 +0800</pubDate>
			
			<guid>/posts/socket-optimize/</guid>
			<description>&lt;p&gt;TCP/IPåè®®æ ˆæ˜¯è®¡ç®—æœºç½‘ç»œçš„åŸºç¡€é€šä¿¡æ¶æ„ï¼Œå…¶ä¸­IPåè®®å®Œæˆäº†è·¨é“¾è·¯çš„è·¯ç”±ã€å¯»å€ï¼ŒTCPåè®®å®Œæˆäº†é¢å‘è¿æ¥çš„å¯é å­—èŠ‚æµæŠ½è±¡ï¼Œæä¾›æ•°æ®çš„åˆ†æ®µã€é‡ä¼ ã€é‡ç»„ï¼Œæµé‡æ§åˆ¶å’Œæ‹¥å¡æ§åˆ¶ï¼Œä½¿å¾—å»ºç«‹åœ¨TCP/IPåè®®ä¹‹ä¸Šçš„åº”ç”¨åè®®ä¸ç”¨å†å…³å¿ƒå„ç§ç¡¬ä»¶ã€ç½‘ç»œç¯å¢ƒï¼ŒTCP/IPåè®®æ˜¯ä»Šå¤©çš„äº’è”ç½‘çš„åŸºçŸ³ã€‚&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>TCP/IPåè®®æ ˆæ˜¯è®¡ç®—æœºç½‘ç»œçš„åŸºç¡€é€šä¿¡æ¶æ„ï¼Œå…¶ä¸­IPåè®®å®Œæˆäº†è·¨é“¾è·¯çš„è·¯ç”±ã€å¯»å€ï¼ŒTCPåè®®å®Œæˆäº†é¢å‘è¿æ¥çš„å¯é å­—èŠ‚æµæŠ½è±¡ï¼Œæä¾›æ•°æ®çš„åˆ†æ®µã€é‡ä¼ ã€é‡ç»„ï¼Œæµé‡æ§åˆ¶å’Œæ‹¥å¡æ§åˆ¶ï¼Œä½¿å¾—å»ºç«‹åœ¨TCP/IPåè®®ä¹‹ä¸Šçš„åº”ç”¨åè®®ä¸ç”¨å†å…³å¿ƒå„ç§ç¡¬ä»¶ã€ç½‘ç»œç¯å¢ƒï¼ŒTCP/IPåè®®æ˜¯ä»Šå¤©çš„äº’è”ç½‘çš„åŸºçŸ³ã€‚</p>
<h1 id="ç½‘ç»œå¥—æ¥å­—socket">ç½‘ç»œå¥—æ¥å­—Socket</h1>
<p>Socketæ˜¯æ“ä½œç³»ç»Ÿç”¨äºç½‘ç»œç¼–ç¨‹çš„åº”ç”¨ç¨‹åºæ¥å£ï¼ˆAPIï¼‰ï¼Œå¯æ”¯æŒå¤šç§åè®®ï¼Œç°ä»£å¸¸è§çš„Socketå¥—æ¥å­—æ¥å£ï¼ˆUnix Socketã€Windows Socketç­‰ï¼‰éƒ½æºè‡ªBerkeleyå¥—æ¥å­—<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>ã€‚æ¥å£å®ç°ç”¨äºTCP/IPåè®®ï¼Œå› æ­¤å®ƒæ˜¯ç»´æŒInternetçš„åŸºæœ¬æŠ€æœ¯ä¹‹ä¸€ã€‚åŒæ—¶ä¹Ÿè¢«ç”¨äºUnixåŸŸå¥—æ¥å­—ï¼ˆUnix domain socketsï¼‰ï¼Œå¯å®ç°åœ¨å•æœºä¸Šä¸ºè¿›ç¨‹é—´é€šè®¯ï¼ˆIPCï¼‰çš„æ¥å£ã€‚</p>
<p>ä¸åŒçš„Socketåº”ç”¨ç¨‹åºé™¤äº†æ»¡è¶³æœ€åŸºæœ¬çš„é€šä¿¡éœ€æ±‚å¤–ï¼Œä¹Ÿä¼šæœ‰ä¸€äº›æ ¹æ®ä¸šåŠ¡ç›¸å…³çš„ç‰¹æ®Šéœ€æ±‚ï¼Œæœ¬ç¯‡è®°å½•å…³äºå‡ ä¸ªLinuxä¸‹ç½‘ç»œSocketåº”ç”¨çš„ä¼˜åŒ–æŠ€å·§ï¼š</p>
<h2 id="ä½å»¶è¿Ÿéœ€æ±‚">ä½å»¶è¿Ÿéœ€æ±‚</h2>
<p>ç”±äºTCPåè®®æ˜¯é¢å‘å­—èŠ‚æµçš„åè®®ï¼Œä½†æ˜¯ç”¨äºæ‰¿è½½TCPçš„åº•å±‚åè®®æ— æ³•ç›´æ¥æ”¯æŒå­—èŠ‚æµï¼Œä»¥å¤ªç½‘åè®®éœ€è¦ä¸€å¸§ä¸€å¸§åœ°å‘é€ï¼Œä¸€æ¬¡å‘é€çš„æœ€å¤§å­—èŠ‚æ•°å—é™äºMTUï¼›IPåè®®è™½ç„¶æ”¯æŒæ•°æ®çš„åˆ†åŒ…å‘é€ï¼Œä½†æ˜¯å¤§å¤šæ•°æƒ…å†µä¸‹æˆ‘ä»¬éœ€è¦é¿å…IPåè®®åˆ†åŒ…ï¼Œå› ä¸ºè¿™ä¼šå½±å“ä¸­é—´è·³ç‚¹çš„å¤„ç†æ€§èƒ½ï¼Œæ‰€ä»¥TCPåè®®å¼•å…¥äº†åˆ†æ®µï¼ˆSegmentï¼‰æœºåˆ¶ï¼Œåœ¨TCPå±‚å¯¹æ•°æ®è¿›è¡Œæ‹†åˆ†ï¼Œä¿è¯IPæ•°æ®åŒ…éƒ½æ˜¯å®Œæ•´çš„ã€‚è€Œé€šå¸¸æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¸Œæœ›æ¯æ¬¡å‘é€çš„æ•°æ®å°½å¯èƒ½çš„å¤šï¼Œä¹Ÿå°±æ˜¯æ­£å¥½å¡«æ»¡IPæ•°æ®åŒ…ï¼Œä»¥æ­¤å‡å°‘ç½‘ç»œä¼ è¾“çš„æ¬¡æ•°ï¼ˆåŒ…æ‹¬å‘é€ä¸æ¥æ”¶æ–¹ç¡®è®¤çš„æ¬¡æ•°ï¼‰ï¼ŒåŒæ—¶å‡å°‘äº†æ€»çš„åŒ…å¤´æ•°æ®é‡ï¼Œä»¥æ­¤æé«˜æ•´ä½“çš„ç½‘ç»œååé‡ã€‚</p>
<p>Nagleç®—æ³•å®ç°äº†å¯¹æ•°æ®çš„åˆå¹¶ï¼Œè¯¥ç®—æ³•ä¼šæŠŠå¤šä¸ªå°çš„æ•°æ®åˆå¹¶æˆä¸€ä¸ªå®Œæ•´çš„æŠ¥æ–‡æ®µï¼Œä»¥æ­¤æœ€å¤§åŒ–æŠ¥æ–‡æ®µï¼Œå‡å°‘åœ¨çº¿è·¯ä¸Šä¼ è¾“æŠ¥æ–‡çš„æ¬¡æ•°ï¼Œä½†æ˜¯åŒæ—¶ä¹Ÿä¼šå¸¦æ¥å»¶è¿Ÿï¼Œå› ä¸ºå†™å…¥ç¼“å†²åŒºçš„æ•°æ®å¹¶ä¸ä¼šé©¬ä¸Šå‘é€å‡ºå»ã€‚åœ¨ä½å»¶è¿Ÿéœ€æ±‚çš„åº”ç”¨ä¸­ï¼Œå¯ä»¥ç¦ç”¨Nagleç®—æ³•ï¼š</p>
<pre><code class="language-rust">use std::net::SocketAddr;
use socket2::{Socket, Domain, Type};
use anyhow::Result;

fn no_delay() -&gt; Result&lt;()&gt; {
  // create a TCP listener bound to two addresses
  let socket = Socket::new(Domain::ipv4(), Type::stream(), None)?;

  socket.bind(&amp;&quot;127.0.0.1:12345&quot;.parse::&lt;SocketAddr&gt;()?.into())?;
  // sets the value of the TCP_NODELAY option on this socket
  socket.set_nodelay(true)?;
  socket.listen(128)?;

  let listener = socket.into_tcp_listener();
  // ...
  Ok(())
}
</code></pre>
<h2 id="å‡å°‘ç³»ç»Ÿè°ƒç”¨">å‡å°‘ç³»ç»Ÿè°ƒç”¨</h2>
<p>ç”±äºç½‘ç»œæ¥å£çš„è°ƒç”¨å±äºç³»ç»Ÿè°ƒç”¨ï¼Œä¼šè·¨è¶Šåº”ç”¨ç¨‹åºç©ºé—´å’Œå†…æ ¸ç©ºé—´çš„è¾¹ç•Œï¼Œå¯¼è‡´åº”ç”¨ç¨‹åºç©ºé—´å’Œå†…æ ¸ç©ºé—´çš„ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œå› æ­¤åœ¨å¸Œæœ›å‡å°‘å†…æ ¸è°ƒç”¨è´Ÿè½½çš„åœºæ™¯ä¸­ï¼Œå¯ä»¥åœ¨åº”ç”¨ç¨‹åºä¸­å°½å¯èƒ½ä½¿ç”¨èƒ½æ”¯æŒçš„æœ€å¤§ç¼“å†²åŒºï¼Œè¿™æ ·å¯ä»¥æœ€å¤§åŒ–ä¸€æ¬¡ç³»ç»Ÿè°ƒç”¨èƒ½å‘é€æˆ–è¯»å–çš„æ•°æ®é‡ã€‚</p>
<h2 id="å¢åŠ å†…æ ¸ç¼“å†²åŒºä¸Šé™">å¢åŠ å†…æ ¸ç¼“å†²åŒºä¸Šé™</h2>
<p>åœ¨<a href="/posts/dma/">DMA(ç›´æ¥å†…å­˜è®¿é—®)å’Œé›¶æ‹·è´</a>ä¸­è®°å½•è¿‡å¤§å¤šæ•°æ–‡ä»¶ç³»ç»Ÿé»˜è®¤çš„IOæ“ä½œéƒ½æ˜¯ç¼“å­˜IO(Buffered I/O)ï¼ŒSocketæ¥å£åŒæ ·å¦‚æ­¤ï¼Œå¦‚æœç½‘ç»œç¯å¢ƒè¶³å¤Ÿå¥½ï¼Œå‘é€ã€æ¥æ”¶åŒæ–¹çš„å¤„ç†èƒ½åŠ›è¶³å¤Ÿå¥½çš„è¯ï¼Œç¼“å†²åŒºçš„å¤§å°ä¼šæˆä¸ºç½‘ç»œé€šä¿¡çš„ç“¶é¢ˆï¼ˆå› ä¸ºå‘é€ã€æ¥æ”¶çª—å£çš„ä¸Šé™å°±æ˜¯å†…æ ¸Socketç¼“å†²åŒºå¤§å°ï¼‰ã€‚ç°ä»£çš„æ“ä½œç³»ç»Ÿéƒ½å¯ä»¥åŠ¨æ€åœ°è°ƒæ•´Socketç¼“å†²åŒºå¤§å°ï¼ˆå¦‚æœä½ åœ¨æ¥å£è°ƒç”¨é‡Œå¼ºåˆ¶æŒ‡å®šäº†ç¼“å†²åŒºå¤§å°ï¼Œé‚£ä¹ˆå†…æ ¸å°±ä¸ä¼šåŠ¨æ€è°ƒæ•´äº†ï¼Œå› æ­¤å»ºè®®ä¸è¦åœ¨æ¥å£è°ƒç”¨çš„æ—¶å€™æŒ‡å®šï¼Œå› ä¸ºç½‘ç»œç¯å¢ƒä¼šéšæ—¶å˜åŒ–ï¼‰ï¼Œä½†æ˜¯ä¼šå—ä¸€äº›å†…æ ¸å‚æ•°çš„çº¦æŸã€‚åœ¨Linuxä¸­ï¼Œå‘é€ã€æ¥æ”¶ç¼“å†²åŒºçš„ä¸Šé™å—ä»¥ä¸‹å†…æ ¸å‚æ•°çš„å½±å“ï¼š</p>
<pre><code class="language-none">net.core.wmem_max
net.core.rmem_max
</code></pre>
<p>ä¸€èˆ¬è¿™ä¸ªä¸Šé™çš„ç†æƒ³å€¼æ˜¯å¸¦å®½æ—¶å»¶ç§¯ï¼ˆBandwidth Delay Productï¼‰ï¼Œå–å†³äºé“¾è·¯å¸¦å®½å’Œå¾€è¿”æ—¶å»¶ï¼ˆRTTï¼‰ã€‚å¦‚æœç½‘ç»œç¯å¢ƒè¾ƒå¥½ï¼Œä½ ä¸æƒ³æµªè´¹ä½ æœºå™¨çš„å†…å­˜ï¼ŒåŒæ—¶ä½ çš„åº”ç”¨ç¨‹åºæ•ˆç‡è¶³å¤Ÿé«˜çš„è¯ï¼Œä¸å¦¨å¢åŠ å†…æ ¸ç¼“å†²åŒºä¸Šé™å§ï¼</p>
<h2 id="åˆ©ç”¨ä»¥å¤ªç½‘å·¨å¸§">åˆ©ç”¨ä»¥å¤ªç½‘å·¨å¸§</h2>
<p>åœ¨ä¹‹å‰æåˆ°ï¼Œä»¥å¤ªç½‘åè®®éœ€è¦ä¸€å¸§ä¸€å¸§çš„å‘é€æŠ¥æ–‡ï¼ŒåŸå› åœ¨äºä¿¡å·åœ¨é“¾è·¯ä¸Šä¼ è¾“è¿‡ç¨‹ä¸­æ— æ³•é¿å…ä¿¡å·çš„ä¸¢å¤±æˆ–é”™è¯¯ï¼Œä¸€æ—¦æœ‰ä¸€ä¸ªbitä¿¡å·å‘ç”Ÿé”™è¯¯ï¼Œé‚£ä¹‹åçš„ä¿¡å·å°±æ²¡æœ‰ä»»ä½•æ„ä¹‰äº†ã€‚é‡‡ç”¨ä»¥å¤ªç½‘å¸§çš„æ–¹å¼ï¼Œå¯ä»¥å°†è¿™ç§å½±å“é™ä½ï¼Œä¸€ä¸ªä»¥å¤ªç½‘å¸§çš„é”™è¯¯ï¼Œä¸å½±å“å…¶ä»–ä»¥å¤ªç½‘å¸§ï¼Œå¦‚æœè¦é‡ä¼ ä¹Ÿåªéœ€è¦é‡ä¼ å‡ºé”™çš„ä»¥å¤ªç½‘å¸§ã€‚è¶Šå°çš„ä»¥å¤ªç½‘å¸§ï¼Œå‡ºé”™çš„å‡ ç‡è¶Šå°ï¼Œä½†æ˜¯ç½‘ç»œçš„ååé‡ä¹Ÿè¶Šå°ï¼›è¶Šå¤§çš„ä»¥å¤ªç½‘å¸§åè¿‡æ¥ï¼Œå‡ºé”™çš„å‡ ç‡è¶Šå¤§ï¼Œä½†æ˜¯ç½‘ç»œçš„ååé‡è¶Šå¤§ï¼ˆåŒ…å«äº†å‡ºé”™çš„æ— æ•ˆå¸§ï¼‰ã€‚å› æ­¤é“¾è·¯ä¸Šçš„æ¯ä¸€ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªæœ€å¤§ä¼ è¾“å•å…ƒï¼ˆMTUï¼‰ï¼Œç”¨äºé™åˆ¶ä¼ è¾“çš„ä»¥å¤ªç½‘å¸§å¤§å°ï¼Œé€šå¸¸è¯¥å€¼ä¸º1500ã€‚</p>
<p>ä½†æ˜¯MTUçš„å¤§å°å¤šå°‘æœ€åˆé€‚ï¼Œè¦çœ‹æ‰€å¤„çš„ç½‘ç»œç¯å¢ƒï¼Œå¸¦å®½å¤§å°ã€ç½‘ç»œæ‹¥å µæƒ…å†µã€ç‰©ç†ç½‘ç»œç¡¬ä»¶æ€§èƒ½ç­‰ã€‚å¦‚æœæ˜¯æœ¬åœ°å†…éƒ¨ç½‘ç»œï¼Œæ‹¥æœ‰è¾ƒå¥½çš„ç½‘ç»œç¯å¢ƒï¼Œä¹Ÿå°±æ˜¯é“¾è·¯ä¿¡å·å‡ºé”™çš„æ¦‚ç‡éå¸¸ä½ï¼Œå¯ä»¥å°†MTUçš„å€¼é€‚å½“åœ°è°ƒå¤§ï¼Œç”šè‡³æ˜¯éå¸¸å¤§ï¼ˆå³ä»¥å¤ªç½‘å·¨å¸§ï¼‰ï¼Œå¯ä»¥æœ‰æ•ˆåœ°å¢åŠ ç½‘ç»œååé‡ã€‚</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Berkeleyå¥—æ¥å­— - <a href="https://zh.wikipedia.org/wiki/Berkeley%E5%A5%97%E6%8E%A5%E5%AD%97">ç»´åŸºç™¾ç§‘è¯æ¡</a> <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>]]></content>
		</item>
		
		<item>
			<title>2Q(åŒé“¾)ç¼“å­˜æ·˜æ±°ç­–ç•¥</title>
			<link>/posts/two-queue/</link>
			<pubDate>Tue, 19 May 2020 00:00:00 +0000</pubDate>
			
			<guid>/posts/two-queue/</guid>
			<description>&lt;p&gt;LRU(æœ€è¿‘ä½¿ç”¨)ç®—æ³•ç»å¸¸ç”¨äºç¼“å­˜åº”ç”¨ä¸­ï¼Œæœ€ç®€å•çš„å®ç°æ˜¯é€šè¿‡ä¸€ä¸ªé“¾è¡¨å®ç°ï¼š&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;æ’å…¥æ•°æ®æ—¶å‘å¤´èŠ‚ç‚¹æ’å…¥&lt;/li&gt;
&lt;li&gt;æ›´æ–°æ•°æ®æ—¶ï¼Œç§»åŠ¨èŠ‚ç‚¹åˆ°å¤´èŠ‚ç‚¹&lt;/li&gt;
&lt;li&gt;æ·˜æ±°æ•°æ®æ—¶åˆ é™¤å°¾èŠ‚ç‚¹&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ä½†æ˜¯è¿™ä¸ªç®€å•çš„å®ç°å¹¶ä¸èƒ½å¾ˆå¥½åœ°åº”ä»˜å¾ˆå¤šåœºæ™¯ï¼Œç¼“å­˜çš„ç†æƒ³æƒ…å†µæ˜¯é¢„æµ‹æœªæ¥æ•°æ®çš„ä½¿ç”¨æƒ…å†µï¼Œå°½å¯èƒ½çš„ä»ç¼“å­˜ä¸­è¯»å–æ•°æ®ï¼Œå‡å°‘å®é™…IOæ“ä½œã€‚&lt;/p&gt;
&lt;p&gt;ä»Šå¤©çš„è®°å½•æ˜¯å…³äº1ä¸ªLRUçš„å˜ç§ç®—æ³•ï¼š2Q(åŒé“¾)ï¼Œè¯¥ç®—æ³•åœ¨Linuxé¡µé«˜é€Ÿç¼“å­˜å›æ”¶ä¸­è¢«åº”ç”¨ã€‚&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>LRU(æœ€è¿‘ä½¿ç”¨)ç®—æ³•ç»å¸¸ç”¨äºç¼“å­˜åº”ç”¨ä¸­ï¼Œæœ€ç®€å•çš„å®ç°æ˜¯é€šè¿‡ä¸€ä¸ªé“¾è¡¨å®ç°ï¼š</p>
<ol>
<li>æ’å…¥æ•°æ®æ—¶å‘å¤´èŠ‚ç‚¹æ’å…¥</li>
<li>æ›´æ–°æ•°æ®æ—¶ï¼Œç§»åŠ¨èŠ‚ç‚¹åˆ°å¤´èŠ‚ç‚¹</li>
<li>æ·˜æ±°æ•°æ®æ—¶åˆ é™¤å°¾èŠ‚ç‚¹</li>
</ol>
<p>ä½†æ˜¯è¿™ä¸ªç®€å•çš„å®ç°å¹¶ä¸èƒ½å¾ˆå¥½åœ°åº”ä»˜å¾ˆå¤šåœºæ™¯ï¼Œç¼“å­˜çš„ç†æƒ³æƒ…å†µæ˜¯é¢„æµ‹æœªæ¥æ•°æ®çš„ä½¿ç”¨æƒ…å†µï¼Œå°½å¯èƒ½çš„ä»ç¼“å­˜ä¸­è¯»å–æ•°æ®ï¼Œå‡å°‘å®é™…IOæ“ä½œã€‚</p>
<p>ä»Šå¤©çš„è®°å½•æ˜¯å…³äº1ä¸ªLRUçš„å˜ç§ç®—æ³•ï¼š2Q(åŒé“¾)ï¼Œè¯¥ç®—æ³•åœ¨Linuxé¡µé«˜é€Ÿç¼“å­˜å›æ”¶ä¸­è¢«åº”ç”¨ã€‚</p>
<h1 id="2qåŒé“¾">2Q(åŒé“¾)</h1>
<p>åŸå§‹LRUç®—æ³•æè¿°çš„æ˜¯æ•°æ®ä½¿ç”¨çš„æœ€è¿‘æ—¶é—´ç‚¹ï¼Œè¶Šé è¿‘å¤´èŠ‚ç‚¹çš„æ•°æ®ä½¿ç”¨çš„æ—¶é—´ç‚¹è¶Šè¿‘ï¼Œä½†æ˜¯æ²¡æœ‰æè¿°æ•°æ®ä½¿ç”¨çš„é¢‘ç‡ï¼Œåƒå¯¹äºæ•°æ®åº“çš„éå†æ“ä½œï¼Œæ–°æ•°æ®ä¼šç«‹å³å°†ç¼“å­˜ä¸­çš„æ‰€æœ‰æ•°æ®æ·˜æ±°ï¼Œä½†æ˜¯éå†å®Œåï¼Œç¼“å­˜ä¸­çš„æ•°æ®åœ¨ä¹‹åä½¿ç”¨çš„æ¦‚ç‡éå¸¸ä½ï¼Œå³ç¼“å­˜æ±¡æŸ“ã€‚</p>
<p>2Qæ·˜æ±°ç®—æ³•æ˜¯ä¾¿æ˜¯å¯¹ä»¥ä¸Šæƒ…å†µçš„ä¸€ç§ä¼˜åŒ–ï¼Œæ·˜æ±°ç­–ç•¥æ˜¯ä½¿ç”¨2ä¸ªé˜Ÿåˆ—å®ç°ï¼Œ1ä¸ªFIFOé˜Ÿåˆ—è®°å½•åªè®¿é—®äº†ä¸€æ¬¡çš„æ•°æ®ï¼Œ1ä¸ªæ™®é€šLRUé˜Ÿåˆ—è®°å½•è®¿é—®äº†2æ¬¡ä»¥ä¸Šçš„æ•°æ®ã€‚</p>
<ol>
<li>å½“ç¬¬1æ¬¡è®¿é—®æ—¶ï¼Œå°†æ•°æ®æ·»åŠ åˆ°FIFOé˜Ÿåˆ—ï¼Œå¦‚æœFIFOé˜Ÿåˆ—è¶…è¿‡é™åˆ¶ï¼Œæ·˜æ±°FIFOé‡Œæœ€æ—§çš„æ•°æ®</li>
<li>å½“ç¬¬2æ¬¡è®¿é—®æ—¶ï¼Œå°†æ•°æ®ä»FIFOé˜Ÿåˆ—ç§»åŠ¨åˆ°LRUé˜Ÿåˆ—çš„å¤´èŠ‚ç‚¹ï¼Œå¦‚æœLRUé˜Ÿåˆ—è¶…è¿‡é™åˆ¶ï¼Œå°†LRUé‡Œæœ€æ—§çš„æ•°æ®ç§»åŠ¨åˆ°FIFOé˜Ÿåˆ—çš„å¤´èŠ‚ç‚¹</li>
<li>å½“ç¬¬3æ¬¡ä»¥ä¸Šè®¿é—®æ—¶ï¼ŒæŒ‰ç…§LRUè§„åˆ™æ›´æ–°LRUé˜Ÿåˆ—</li>
</ol>
<pre><code class="language-rust">use std::ptr::NonNull;
use std::fmt::Debug;

pub struct Node&lt;T: Debug&gt; {
	pub val: T,
	pub prev: Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
	pub next: Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
}

pub struct List&lt;T: Debug&gt; {
	pub head: Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
	pub tail: Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
	pub len: usize,
}

impl &lt;T: Debug&gt; List&lt;T&gt; {
	pub fn new() -&gt; Self {
		Self {
			head: None,
			tail: None,
			len: 0,
		}
	}

	pub fn push_front(&amp;mut self, val: T) {
		let node = Box::new(Node {
			val,
			prev: None,
			next: self.head,
		});
		let node = NonNull::new(Box::into_raw(node));
		
		if let Some(mut old_head) = self.head {
			unsafe {
				old_head.as_mut().prev = node;
			}
		} else {
			self.tail = node;
		}
		self.head = node;
		self.len +=  1;
	}

	pub fn push_front_node(&amp;mut self, node: NonNull&lt;Node&lt;T&gt;&gt;) {
		let node = Some(node);
		if let Some(mut old_head) = self.head {
			unsafe {
				old_head.as_mut().prev = node;
			}
		} else {
			self.tail = node;
		}
		self.head = node;
		self.len +=  1;
	}

	pub fn pop_back(&amp;mut self) -&gt; Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt; {
		if let Some(mut old_tail) = self.tail {
			unsafe {
				let tail = old_tail.as_mut().prev;
				if let Some(mut tail) = tail {
					tail.as_mut().next = None;	
				} else {
					self.head = None;
				}
				self.tail = tail;
				self.len -= 1;
				return Some(old_tail);
			}
		}
		None
	}

	pub fn print(&amp;self) {
		let mut cur = self.head.as_ref();
		unsafe {
			while let Some(c) = cur {
				let r = c.as_ref();
				println!(&quot;{:?}&quot;, r.val);
				cur = r.next.as_ref();
			}
		}
	}
}

struct TwoQueue {
	fifo: List&lt;(String, i32)&gt;,
	fifo_limit: usize,
	lru: List&lt;(String, i32)&gt;,
	lru_limit: usize,
}

impl TwoQueue {
	fn new(fifo_limit: usize, lru_limit: usize) -&gt; Self {
		Self {
			fifo: List::new(),
			fifo_limit,
			lru: List::new(),
			lru_limit,
		}
	}
	
	fn get(&amp;mut self, key: &amp;str) -&gt; Option&lt;i32&gt; {
		let r = self.find_in_lru(key);
		if r.is_some() {
			return r;
		}
		self.find_in_fifo(key)
	}

	fn find_in_fifo(&amp;mut self, key: &amp;str) -&gt; Option&lt;i32&gt; {
		let mut cur = self.fifo.head;
		while let Some(c0) = cur {
			unsafe {
				let c = &amp;mut *c0.as_ptr();			
				if c.val.0 == key {
					// å–ä¸‹
					if let Some(mut p) = c.prev {
						p.as_mut().next = c.next;
					} else {
						self.fifo.head = c.next;
					}
					if let Some(mut n) = c.next {
						n.as_mut().prev = c.prev;
					} else {
						self.fifo.tail = c.prev;
					}
					self.fifo.len -= 1;
					// ç§»åŠ¨åˆ°lrué˜Ÿåˆ—
					self.lru.push_front_node(c0);
					// æ£€æŸ¥lruæ˜¯å¦æ»¡
					if self.lru.len &gt; self.lru_limit {
						if let Some(node_from_lru) = self.lru.pop_back() {
							self.fifo.push_front_node(node_from_lru);
						}
					}
					// è¿”å›
					return Some(c.val.1);
				}
				cur = c.next;
			}
		}
		None
	}

	fn find_in_lru(&amp;mut self, key: &amp;str) -&gt; Option&lt;i32&gt; {
		let mut cur = self.lru.head;
		while let Some(c0) = cur {
			unsafe {
				let c = &amp;mut *c0.as_ptr();
				if c.val.0 == key {
					// å–ä¸‹
					if let Some(mut p) = c.prev {
						p.as_mut().next = c.next;
					} else {
						self.lru.head = c.next;
					}
					if let Some(mut n) = c.next {
						n.as_mut().prev = c.prev;
					} else {
						self.lru.tail = c.prev;
					}
					// ç§»åŠ¨è‡³å¤´èŠ‚ç‚¹
					c.prev = None;
					c.next = self.lru.head;
					if let Some(mut h) = self.lru.head {
						h.as_mut().prev = Some(c0);
					} else {
						self.lru.tail = Some(c0);
					}
					self.lru.head = Some(c0);
					// è¿”å›
					return Some(c.val.1);
				}
				cur = c.next;
			}
		}
		None
	}

	fn put(&amp;mut self, key: String, val: i32) {
		self.fifo.push_front((key, val));
		if self.fifo.len &gt; self.fifo_limit {
			let _ = self.fifo.pop_back();
		}
	}
}

#[test]
fn two_queue() {
	let mut tq = TwoQueue::new(3, 3);
	tq.put(&quot;a&quot;.into(), 1);
	tq.put(&quot;b&quot;.into(), 2);
	tq.put(&quot;c&quot;.into(), 3);
	tq.put(&quot;d&quot;.into(), 4);
	tq.get(&quot;b&quot;);
	println!(&quot;fifo&quot;);
	tq.fifo.print();
	println!(&quot;lru&quot;);
	tq.lru.print();
}
</code></pre>
<p>- å®Œ</p>]]></content>
		</item>
		
		<item>
			<title>Linuxè¿›ç¨‹è°ƒåº¦ä¸å®šæ—¶å™¨</title>
			<link>/posts/sched-and-timer/</link>
			<pubDate>Sun, 17 May 2020 20:14:50 +0800</pubDate>
			
			<guid>/posts/sched-and-timer/</guid>
			<description>&lt;p&gt;ç”±äºLinuxæ˜¯å±äºæŠ¢å å¼(preemptoin)å¤šä»»åŠ¡(multitasking)åˆ†æ—¶æ“ä½œç³»ç»Ÿï¼Œå› æ­¤è¿›ç¨‹çš„è°ƒåº¦åŒå®šæ—¶å™¨å¿…ç„¶å­˜åœ¨è”ç³»ï¼Œæœ¬ç¯‡æ—¥å¿—æ˜¯è®°å½•Linuxè¿›ç¨‹è°ƒåº¦ä¸å®šæ—¶å™¨çš„å…³ç³»ã€‚&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Linuxä¸Microsoft Windowsç­‰æ“ä½œç³»ç»Ÿä¸åŒï¼Œå¹¶æ²¡æœ‰å•ç‹¬çš„çº¿ç¨‹æœºåˆ¶ï¼Œä¸€ç»„çº¿ç¨‹ä»…ä»…æ˜¯å…±äº«äº†è™šæ‹Ÿå†…å­˜åœ°å€ç©ºé—´ã€æ‰“å¼€çš„æ–‡ä»¶ç­‰èµ„æºçš„è¿›ç¨‹ã€‚&lt;/p&gt;
&lt;/blockquote&gt;</description>
			<content type="html"><![CDATA[<p>ç”±äºLinuxæ˜¯å±äºæŠ¢å å¼(preemptoin)å¤šä»»åŠ¡(multitasking)åˆ†æ—¶æ“ä½œç³»ç»Ÿï¼Œå› æ­¤è¿›ç¨‹çš„è°ƒåº¦åŒå®šæ—¶å™¨å¿…ç„¶å­˜åœ¨è”ç³»ï¼Œæœ¬ç¯‡æ—¥å¿—æ˜¯è®°å½•Linuxè¿›ç¨‹è°ƒåº¦ä¸å®šæ—¶å™¨çš„å…³ç³»ã€‚</p>
<blockquote>
<p>Linuxä¸Microsoft Windowsç­‰æ“ä½œç³»ç»Ÿä¸åŒï¼Œå¹¶æ²¡æœ‰å•ç‹¬çš„çº¿ç¨‹æœºåˆ¶ï¼Œä¸€ç»„çº¿ç¨‹ä»…ä»…æ˜¯å…±äº«äº†è™šæ‹Ÿå†…å­˜åœ°å€ç©ºé—´ã€æ‰“å¼€çš„æ–‡ä»¶ç­‰èµ„æºçš„è¿›ç¨‹ã€‚</p>
</blockquote>
<h1 id="linuxè¿›ç¨‹è°ƒåº¦">Linuxè¿›ç¨‹è°ƒåº¦</h1>
<p>æ“ä½œç³»ç»Ÿçš„ä¸€ä¸ªé‡è¦èŒè´£æ˜¯å°†æœ‰é™çš„èµ„æºé€šè¿‡ç‰¹å®šçš„æœºåˆ¶åˆ†é…ç»™å¤šä¸ªç”¨æˆ·ä½¿ç”¨ï¼Œè¿™é‡Œçš„èµ„æºåŒ…æ‹¬CPUã€å†…å­˜ã€IOç­‰ï¼Œç”¨æˆ·æ—¢å¯ä»¥æŒ‡æ“ä½œè®¡ç®—æœºçš„äººï¼Œè€Œäººæ˜¯ç»™è®¡ç®—æœºä¸‹è¾¾ä»»åŠ¡çš„ï¼Œå› æ­¤æ›´å®½æ³›åœ°æŒ‡ä»»åŠ¡ï¼Œä¹Ÿå°±æ˜¯è¿›ç¨‹ã€‚</p>
<p>ç”±äºå®é™…åœºæ™¯ä¸­ï¼Œè¿›ç¨‹çš„æ•°é‡æ˜¯å¤§äºCPUå¤„ç†å™¨æ•°é‡ï¼Œå¤šä»»åŠ¡å°±æ˜¯æŒ‡åŒæ—¶å¹¶å‘åœ°è®©è¿›ç¨‹äº¤æ›¿ä½¿ç”¨CPUèµ„æºï¼Œè®©è¿›ç¨‹äº§ç”Ÿè‡ªå·±ç‹¬å CPUçš„é”™è§‰ï¼Œè™šæ‹Ÿå†…å­˜ä¹Ÿæ˜¯åŒç†ã€‚</p>
<p>æŠ¢å (preemptoin)å°±æ˜¯æŒ‡ä¸éœ€è¦ç»è¿‡è¿›ç¨‹ä¸»åŠ¨å‡ºè®©ï¼Œå†…æ ¸è°ƒåº¦å™¨å¯ä»¥å¼ºåˆ¶è®©è¿›ç¨‹è®©å‡ºCPUèµ„æºï¼Œç„¶åå»æ‰§è¡Œå…¶ä»–è¿›ç¨‹ã€‚</p>
<blockquote>
<p>ä¸æŠ¢å å¼å¤šä»»åŠ¡ç›¸å¯¹åº”çš„ï¼Œå«åšåä½œå¼(cooperative)å¤šä»»åŠ¡ï¼ŒGoçš„goroutineä¾¿æ˜¯ä¸€ä¸ªåº”ç”¨èŒƒä¾‹ã€‚</p>
</blockquote>
<p>ç”±äºæœ¬ç¯‡æ—¥å¿—çš„ä¸»é¢˜æ˜¯è¿›ç¨‹è°ƒåº¦ä¸å®šæ—¶å™¨çš„å…³ç³»ï¼Œæ‰€ä»¥æŠ¢å (preemptoin)ä¾¿æ˜¯è¿™é‡Œçš„åˆ‡å…¥ç‚¹ã€‚</p>
<p>ç”±äºè¿›ç¨‹æ­£åœ¨æ‰§è¡Œä»£ç ï¼Œå†…æ ¸å¦‚æœè¦å»æ‰§è¡ŒæŠ¢å æ“ä½œï¼Œæ¯”å¦‚æ‰§è¡Œ schedule()ï¼Œé‚£å¿…ç„¶éœ€è¦å»æ‰§è¡Œå†…æ ¸ä»£ç ï¼Œè€Œè¿™é‡Œè§¦å‘æ‰§è¡Œå†…æ ¸ä»£ç çš„å…¶ä¸­ä¹‹ä¸€ï¼Œä¾¿æ˜¯å®šæ—¶å™¨ä¸­æ–­ã€‚</p>
<p>ä¸è®ºæ˜¯æœ€æ—©çš„Unixè°ƒåº¦ç®—æ³•ï¼Œ2.5å†…æ ¸ç‰ˆæœ¬çš„O(1)è°ƒåº¦ç®—æ³•ï¼Œä»¥åŠ2.6ä¹‹åå‡ºç°çš„CFSå®Œå…¨å…¬å¹³è°ƒåº¦ç®—æ³•ï¼Œå…¶ä¸­è®¡ç®—è¿›ç¨‹å·²ç»æ¶ˆè€—çš„æ—¶é—´ç‰‡(timeslice)éƒ½ä¾èµ–äºè®¡ç®—æœºçš„æ—¶é—´æ¦‚å¿µï¼Œè€Œè®¡ç®—æœºçš„æ—¶é—´æ¦‚å¿µä¹Ÿæ˜¯é€šè¿‡å®šæ—¶å™¨å®ç°çš„ã€‚</p>
<h1 id="å®šæ—¶å™¨">å®šæ—¶å™¨</h1>
<p>ç³»ç»Ÿå®šæ—¶å™¨æ˜¯ä¸€ç§å¯ç¼–ç¨‹ç¡¬ä»¶èŠ¯ç‰‡ï¼Œå®ƒèƒ½ä»¥å›ºå®šçš„é¢‘ç‡äº§ç”Ÿä¸­æ–­ï¼Œè¿™å°±æ˜¯å®šæ—¶å™¨ä¸­æ–­ã€‚å¦‚æœè¯¥ä¸­æ–­ä¿¡å·æ²¡æœ‰è¢«å±è”½ï¼ŒCPUä¾¿ä¼šå»æ‰§è¡Œå¯¹åº”çš„ä¸­æ–­å¤„ç†ç¨‹åºï¼Œå°±å¯ä»¥å»æ‰§è¡Œä¸€äº›éœ€è¦å®šæ—¶æ‰§è¡Œçš„ä»£ç ï¼ŒåŒ…æ‹¬ï¼š</p>
<ol>
<li>æ›´æ–°ç³»ç»Ÿè¿è¡Œçš„æ—¶é—´</li>
<li>æ›´æ–°å®é™…æ—¶é—´</li>
<li>åœ¨SMP(å¯¹ç§°å¤šå¤„ç†å™¨)ç³»ç»Ÿä¸Šï¼Œå‡è¡¡å„ä¸ªå¤„ç†å™¨ä¸Šçš„è¿è¡Œé˜Ÿåˆ—</li>
<li>æ£€æŸ¥å½“å‰è¿›ç¨‹æ˜¯å¦ç”¨å°½äº†æ—¶é—´ç‰‡ï¼Œå¦‚æœç”¨å°½äº†åˆ™é‡æ–°è°ƒåº¦</li>
<li>è¿è¡Œå·²ç»è¶…æ—¶çš„åŠ¨æ€å®šæ—¶å™¨</li>
<li>æ›´æ–°èµ„æºæ¶ˆè€—ã€å¤„ç†å™¨æ—¶é—´çš„ç»Ÿè®¡ä¿¡æ¯</li>
</ol>
<p>ç³»ç»Ÿåœ¨å¯åŠ¨æ—¶ï¼Œä¾¿ä¼šæ ¹æ®ç³»ç»Ÿå®šæ—¶å™¨çš„èŠ‚æ‹ç‡è®¾ç½®ç¡¬ä»¶ã€‚åœ¨x86ä½“ç³»ç»“æ„ä¸­ï¼Œç³»ç»Ÿå®šæ—¶å™¨çš„é»˜è®¤èŠ‚æ‹ç‡æ˜¯100HZï¼Œä¹Ÿå°±æ˜¯è¯´æ¯ç§’ä¼šè§¦å‘100æ¬¡å®šæ—¶å™¨ä¸­æ–­ã€‚è¯¥å€¼å¯ä»¥è‡ªå®šä¹‰ï¼Œè¶Šé«˜äº§ç”Ÿä¸­æ–­çš„é¢‘ç‡å°±è¶Šé«˜ï¼Œæ—¶é’Ÿä¸­æ–­çš„è§£æåº¦ä¹Ÿè¶Šé«˜ï¼Œåƒpoll()å’Œselect()ç­‰ç³»ç»Ÿè°ƒç”¨çš„ç²¾åº¦ä¹Ÿè¶Šé«˜ï¼ŒåŒç†è¿›ç¨‹æ¶ˆè€—çš„æ—¶é—´ç‰‡è®¡ç®—å’Œè°ƒåº¦æ—¶æœºä¹Ÿæ›´ç²¾ç¡®ã€‚</p>
<p>ä½†æ˜¯é«˜èŠ‚æ‹ç‡ä¹Ÿä¼šå¸¦æ¥å‰¯ä½œç”¨ï¼Œæ„å‘³ç€æ‰§è¡Œå®šæ—¶å™¨ä¸­æ–­å¤„ç†ç¨‹åºçš„æ¬¡æ•°æ›´å¤šï¼Œè¿™ä¸ä½†å‡å°‘äº†æ‰§è¡Œå…¶ä»–ä»»åŠ¡çš„æ—¶é—´ï¼ŒåŒæ—¶è¿˜ä¼šæ‰“ä¹±å¤„ç†å™¨çš„é«˜é€Ÿç¼“å­˜ï¼ˆé«˜é€Ÿç¼“å­˜ä¾èµ–äºç©ºé—´å’Œæ—¶é—´å±€éƒ¨æ€§ï¼‰å’Œå¢åŠ è€—ç”µã€‚</p>]]></content>
		</item>
		
		<item>
			<title>DMA(ç›´æ¥å†…å­˜è®¿é—®)å’Œé›¶æ‹·è´</title>
			<link>/posts/dma/</link>
			<pubDate>Sat, 16 May 2020 18:02:00 +0800</pubDate>
			
			<guid>/posts/dma/</guid>
			<description>&lt;blockquote&gt;
&lt;p&gt;è®¸å¤šè®¾å¤‡éƒ½å¯ä»¥ä¸´æ—¶æ§åˆ¶æ€»çº¿ã€‚è¿™äº›è®¾å¤‡å¯ä»¥æ‰§è¡Œæ¶‰åŠä¸»å†…å­˜å’Œå…¶ä»–è®¾å¤‡çš„æ•°æ®ä¼ é€ã€‚ç”±äºè®¾å¤‡æ‰§è¡Œè¿™äº›æ“ä½œçš„è¿‡ç¨‹ä¸­æ— éœ€å€ŸåŠ©äº CPUï¼Œå› æ­¤è¯¥ç±»å‹çš„æ•°æ®ä¼ é€ç§°ä¸ºç›´æ¥å†…å­˜è®¿é—® (direct memory access, DMA)ã€‚&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;å¤§å¤šæ•°æ–‡ä»¶ç³»ç»Ÿé»˜è®¤çš„IOæ“ä½œéƒ½æ˜¯ç¼“å­˜IO(Buffered I/O)ï¼Œå¯¹äºè¯»(Read)æ“ä½œï¼Œå³IOè®¾å¤‡å…ˆæŠŠæ•°æ®å‘é€åˆ°å†…æ ¸ç¼“å­˜åŒº(Page Cache)ï¼Œå†…æ ¸å†å°†æ•°æ®æ‹·è´åˆ°åº”ç”¨ç¨‹åºåœ°å€ç©ºé—´çš„æ•°æ®ç¼“å­˜åŒºï¼Œè€Œå¯¹äºå†™(Write)æ“ä½œï¼Œå³åè¿‡æ¥ï¼Œä»åº”ç”¨ç¨‹åºåœ°å€ç©ºé—´çš„æ•°æ®ç¼“å­˜åŒºæ‹·è´åˆ°å†…æ ¸ç¼“å­˜åŒºï¼Œå†…æ ¸å†å°†æ•°æ®å‘é€åˆ°IOè®¾å¤‡ã€‚&lt;/p&gt;</description>
			<content type="html"><![CDATA[<blockquote>
<p>è®¸å¤šè®¾å¤‡éƒ½å¯ä»¥ä¸´æ—¶æ§åˆ¶æ€»çº¿ã€‚è¿™äº›è®¾å¤‡å¯ä»¥æ‰§è¡Œæ¶‰åŠä¸»å†…å­˜å’Œå…¶ä»–è®¾å¤‡çš„æ•°æ®ä¼ é€ã€‚ç”±äºè®¾å¤‡æ‰§è¡Œè¿™äº›æ“ä½œçš„è¿‡ç¨‹ä¸­æ— éœ€å€ŸåŠ©äº CPUï¼Œå› æ­¤è¯¥ç±»å‹çš„æ•°æ®ä¼ é€ç§°ä¸ºç›´æ¥å†…å­˜è®¿é—® (direct memory access, DMA)ã€‚<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
</blockquote>
<p>å¤§å¤šæ•°æ–‡ä»¶ç³»ç»Ÿé»˜è®¤çš„IOæ“ä½œéƒ½æ˜¯ç¼“å­˜IO(Buffered I/O)ï¼Œå¯¹äºè¯»(Read)æ“ä½œï¼Œå³IOè®¾å¤‡å…ˆæŠŠæ•°æ®å‘é€åˆ°å†…æ ¸ç¼“å­˜åŒº(Page Cache)ï¼Œå†…æ ¸å†å°†æ•°æ®æ‹·è´åˆ°åº”ç”¨ç¨‹åºåœ°å€ç©ºé—´çš„æ•°æ®ç¼“å­˜åŒºï¼Œè€Œå¯¹äºå†™(Write)æ“ä½œï¼Œå³åè¿‡æ¥ï¼Œä»åº”ç”¨ç¨‹åºåœ°å€ç©ºé—´çš„æ•°æ®ç¼“å­˜åŒºæ‹·è´åˆ°å†…æ ¸ç¼“å­˜åŒºï¼Œå†…æ ¸å†å°†æ•°æ®å‘é€åˆ°IOè®¾å¤‡ã€‚</p>
<p>ç¼“å­˜IOçš„ä¼˜åŠ¿ï¼š</p>
<ol>
<li>å¯ä»¥åˆ©ç”¨å†…æ ¸ç¼“å­˜ï¼Œå¦‚æœæ•°æ®å·²ç»åœ¨é¡µç¼“å­˜å†…ï¼Œåˆ™ä¸éœ€è¦å†è¯»å–IOè®¾å¤‡ï¼Œç›´æ¥è¿”å›é¡µç¼“å­˜ä¸­çš„æ•°æ®</li>
<li>å¯¹äºå†™æ“ä½œï¼Œåº”ç”¨ç¨‹åºåªéœ€è¦å°†æ•°æ®æ‹·è´åˆ°å†…æ ¸ç¼“å†²åŒºå³å¯è¿”å›ï¼Œæ¥ä¸‹æ¥åº”ç”¨ç¨‹åºç¼“å†²åŒºå¯ä»¥å†æ¬¡ä½¿ç”¨ï¼Œè€Œä¸éœ€è¦ç­‰å†…æ ¸å°†æ•°æ®å†™åˆ°IOè®¾å¤‡(ä¾èµ–äºåº”ç”¨ç¨‹åºé‡‡ç”¨çš„å†™æ“ä½œæœºåˆ¶)ã€‚åœ¨ä¸€äº›åœºæ™¯ä¸‹ï¼Œæ¯”å¦‚åº”ç”¨ç¨‹åºæ¯æ¬¡åªå†™1Byteï¼Œç¼“å­˜IOå¯ä»¥å°†å¤šæ¬¡çš„å†™æ“ä½œåˆå¹¶æˆä¸€æ¬¡IOå†™æ“ä½œï¼Œæœ‰æ•ˆåœ°å‡å°‘äº†IOæ“ä½œæ¬¡æ•°ï¼Œä»è€Œæä¾›ç³»ç»Ÿæ€§èƒ½</li>
</ol>
<p>ç¼“å­˜IOçš„åŠ£åŠ¿ï¼š</p>
<ol>
<li>æ•°æ®ä»IOè®¾å¤‡åˆ°åº”ç”¨ç¨‹åºåœ°å€ç©ºé—´éœ€è¦ç»è¿‡å†…æ ¸ç¼“å†²åŒºçš„ä¸­è½¬ï¼Œä¹Ÿå°±æ˜¯æ‹·è´æ“ä½œï¼Œè¿™äº›æ‹·è´æ“ä½œä¼šæ¶ˆè€—CPUï¼Œå¢åŠ äº†ç³»ç»Ÿè´Ÿè½½ã€‚åœ¨æŸäº›åœºæ™¯ä¸‹ï¼Œæ¯”å¦‚ç½‘ç»œæ–‡ä»¶æœåŠ¡ï¼Œæ•°æ®åˆ°è¾¾åº”ç”¨ç¨‹åºç¼“å†²åŒºåï¼Œåˆä¼šåŸæ ·çš„å†æ¬¡æ‹·è´åˆ°å†…æ ¸ç¼“å†²åŒºä»¥å‘é€åˆ°IOè®¾å¤‡ï¼Œè¿™é‡Œçš„ä¸­è½¬æ¬¡æ•°åˆå¢åŠ äº†ä¸€å€</li>
<li>ç”¨äºä¸­è½¬çš„ç¼“å†²åŒºï¼Œä¸è®ºæ˜¯åº”ç”¨ç¨‹åºåœ°å€ç©ºé—´ï¼Œè¿˜æ˜¯å†…æ ¸ç©ºé—´ï¼Œéƒ½ä¼šå ç”¨å†…å­˜ï¼ŒåŠ å¤§äº†ç©ºé—´æ¶ˆè€—</li>
</ol>
<h1 id="é›¶æ‹·è´">é›¶æ‹·è´</h1>
<p>åœ¨ä¸€äº›åœºæ™¯ä¸‹ï¼Œæˆ‘ä»¬éœ€è¦å‡å°‘æ•°æ®æ‹·è´çš„æ¬¡æ•°ï¼Œä»¥æé«˜ç³»ç»Ÿæ€§èƒ½ï¼Œé›¶æ‹·è´æŠ€æœ¯ä¾¿æ˜¯ç”¨æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚åœ¨Linuxæ“ä½œç³»ç»Ÿä¸­ï¼Œæœ‰ä»¥ä¸‹å‡ ç§æ–¹å¼æ¥å®ç°é›¶æ‹·è´ï¼š</p>
<h4 id="å†…å­˜æ˜ å°„mmap">å†…å­˜æ˜ å°„ï¼ˆmmap)</h4>
<p>mmapæœºåˆ¶æ˜¯å…ˆå°†æ•°æ®ä»IOè®¾å¤‡è¯»å–åˆ°å†…æ ¸ç¼“å†²åŒºï¼Œç„¶åé€šè¿‡åº”ç”¨ç¨‹åºåœ°å€ç©ºé—´å’Œå†…æ ¸å…±äº«è¯¥å†…æ ¸ç¼“å†²åŒºï¼Œè¿™æ ·å°±ä¸éœ€è¦æ‹·è´äº†ã€‚</p>
<p>ä½†æ˜¯è¿™é‡Œä¹Ÿä¼šå¸¦æ¥ä¸€æ¬¡è™šæ‹Ÿå­˜å‚¨æ“ä½œï¼Œè€Œè™šæ‹Ÿå­˜å‚¨æ“ä½œéœ€è¦ä¿®æ”¹é¡µè¡¨ä»¥åŠå†²åˆ·TLB(translate lookaside bufferï¼Œç¿»è¯‘åç¼“å†²å™¨)æ¥ç»´æŒå­˜å‚¨çš„ä¸€è‡´æ€§ï¼Œè¿™é‡Œçš„å¼€é”€ä¹Ÿä¸å°ï¼Œä½†æ˜¯å¦‚æœä¼ è¾“çš„æ•°æ®è¾ƒå¤§ï¼Œé‚£è¿˜æ˜¯å€¼å¾—çš„ã€‚</p>
<h4 id="sendfile">sendfile</h4>
<p>mmapä¼šæœ‰è™šæ‹Ÿè½¬å‚¨å¼€é”€ï¼ŒåŒæ—¶å¦‚æœæ˜¯å‘é€ç½‘ç»œæ•°æ®çš„è¯ï¼Œè¿˜éœ€è¦æŠŠæ•°æ®ä»å†…æ ¸ç¼“å†²åŒºå‘é€åˆ°socketç¼“å†²åŒºï¼Œæœ€åå‘é€åˆ°åè®®å¼•æ“ä¸­å»ï¼Œè¿™é‡Œè¿˜æ˜¯ä¼šæœ‰æ‹·è´æ“ä½œ(å†…æ ¸æ‹·è´)ã€‚sendfileæœºåˆ¶å¯ä»¥å†è¿›ä¸€æ­¥çš„å‡å°‘æ‹·è´æ¬¡æ•°ï¼ŒåŒæ—¶é¿å…è™šæ‹Ÿè½¬å‚¨æ“ä½œã€‚</p>
<p>sendfileåˆ©ç”¨DMAå¼•æ“å°†æ•°æ®æ‹·è´åˆ°å†…æ ¸ç¼“å†²åŒºä¸­ï¼Œç„¶åå°†å¸¦æœ‰æ–‡ä»¶ä½ç½®å’Œé•¿åº¦ä¿¡æ¯çš„ç¼“å†²åŒºæè¿°ç¬¦æ·»åŠ åˆ°socketç¼“å†²åŒºä¸­(è¿™é‡Œä¸éœ€è¦æ‹·è´å®Œæ•´çš„æ•°æ®)ï¼ŒDMAå¼•æ“å°†ç›´æ¥ä»å†…æ ¸ç¼“å†²åŒºæ‹·è´åˆ°åè®®å¼•æ“ä¸­å»ï¼Œè¿™é‡Œé¿å…äº†å†…æ ¸ç¼“å†²åŒºåˆ°socketç¼“å†²åŒºçš„æ‹·è´ï¼ŒåŒæ—¶æ²¡æœ‰æ˜ å°„å†…å­˜ã€‚</p>
<h1 id="dmaç›´æ¥å†…å­˜è®¿é—®">DMAï¼ˆç›´æ¥å†…å­˜è®¿é—®ï¼‰</h1>
<p>å‰é¢æåˆ°äº†é›¶æ‹·è´æŠ€æœ¯ä¸­åº”ç”¨äº†DMAï¼Œå¯ä»¥è·³è¿‡åº”ç”¨ç¨‹åºåœ°å€ç©ºé—´çš„ä¸­è½¬ï¼Œä½†æ˜¯å¦‚æœåº”ç”¨éœ€è¦è¯»å–æˆ–ä¿®æ”¹æ•°æ®å‘¢ï¼Ÿè¿™æ—¶DMAä¹Ÿå¯ä»¥è·³è¿‡å†…æ ¸ç¼“å†²åŒºï¼Œå®ç°æ•°æ®ä»IOè®¾å¤‡åˆ°ç”¨æˆ·åœ°å€ç©ºé—´çš„ç›´æ¥æ•°æ®äº¤æ¢ã€‚</p>
<p>åƒæ•°æ®åº“ç®¡ç†ç³»ç»Ÿï¼Œå¸Œæœ›è‡ªå·±ç®¡ç†é¡µç¼“å­˜ï¼Œå› ä¸ºæ•°æ®åº“çŸ¥é“è‡ªå·±å­˜å‚¨çš„æ˜¯ä»€ä¹ˆæ•°æ®ï¼Œè¯¥å¦‚ä½•æ¢é¡µç­‰ç­‰ã€‚æ¯”å¦‚åœ¨æäº¤äº‹åŠ¡æ—¶ï¼Œéœ€è¦redo logå†™å…¥ç£ç›˜ï¼Œæ‰ç®—äº‹åŠ¡æäº¤å®Œæˆï¼Œè€Œbuffer poolä¸­çš„è„é¡µå¹¶ä¸éœ€è¦ç«‹å³å†™å…¥ç£ç›˜ï¼Œå¯ä»¥åœ¨æ¢é¡µæ—¶æˆ–è€…å®šæ—¶å†™å…¥ï¼›åœ¨æ¢é¡µçš„æ—¶å€™ï¼Œå†³å®šå“ªäº›é¡µéœ€è¦ä»buffer poolä¸­æ¢å‡ºï¼Œéœ€è¦æ ¹æ®æ•°æ®åº“è‡ªå·±çš„æœºåˆ¶åˆ¤æ–­ï¼Œä¾èµ–æ“ä½œç³»ç»Ÿçš„æ¢é¡µæœºåˆ¶å°†å¤§å¤§é™ä½æ•°æ®åº“ç³»ç»Ÿçš„æ€§èƒ½ã€‚</p>
<p>å½“ç„¶å¹¶ä¸æ˜¯æ‰€æœ‰åœ°å€ç©ºé—´éƒ½æ”¯æŒDMAï¼Œå—é™ä¸ç¡¬ä»¶ï¼Œåœ¨Linuxä¸­ï¼Œåªæœ‰ZONE_DMAåŒºçš„å†…å­˜å¯æ”¯æŒDMAæ“ä½œï¼Œè¯¦æƒ…å¯å‚è€ƒLinuxå†…å­˜ç®¡ç†ã€‚</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>ç¬¬ 9 ç«  ç›´æ¥å†…å­˜è®¿é—® (Direct Memory Access, DMA) - <a href="https://docs.oracle.com/cd/E19253-01/819-7057/dma-29901/index.html">docs.oracle.com</a> <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>]]></content>
		</item>
		
	</channel>
</rss>
