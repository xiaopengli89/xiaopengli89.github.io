<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="Rust新的内联汇编语法">
<meta itemprop="description" content="昨天Rust新的内联汇编语法被合并进主分支 Inline assembly #2873 ，旧的内联汇编宏被重新命名为了 llvm_asm! ,如果使用了旧的内联汇编宏的项目需要做下修改以保持兼容。"><meta itemprop="datePublished" content="2020-07-22T12:58:16+08:00" />
<meta itemprop="dateModified" content="2020-07-22T12:58:16+08:00" />
<meta itemprop="wordCount" content="2695">
<meta itemprop="keywords" content="rust,assembly," /><meta property="og:title" content="Rust新的内联汇编语法" />
<meta property="og:description" content="昨天Rust新的内联汇编语法被合并进主分支 Inline assembly #2873 ，旧的内联汇编宏被重新命名为了 llvm_asm! ,如果使用了旧的内联汇编宏的项目需要做下修改以保持兼容。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xiaopengli89.github.io/posts/rust-asm-macro/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-22T12:58:16+08:00" />
<meta property="article:modified_time" content="2020-07-22T12:58:16+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Rust新的内联汇编语法"/>
<meta name="twitter:description" content="昨天Rust新的内联汇编语法被合并进主分支 Inline assembly #2873 ，旧的内联汇编宏被重新命名为了 llvm_asm! ,如果使用了旧的内联汇编宏的项目需要做下修改以保持兼容。"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Rust新的内联汇编语法</title>
	<link rel="stylesheet" href="https://xiaopengli89.github.io/css/style.min.037b6ee8f8c1baab6a3d0a9da11c3ff18a7552471f16c59fd98538d5ce99208b.css" integrity="sha256-A3tu6PjBuqtqPQqdoRw/8Yp1UkcfFsWf2YU41c6ZIIs=" crossorigin="anonymous">
	
	<link rel="stylesheet" href="https://atelierbram.github.io/syntax-highlighting/archive/assets/css/prism/prism-base16-railscasts.dark.css">
	<link rel="stylesheet" href="https://xiaopengli89.github.io/css/site.css">
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://xiaopengli89.github.io">Torigoth</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://xiaopengli89.github.io/posts/">Posts</a>
				<a href="https://xiaopengli89.github.io/tags/">Tags</a>
				<a href="https://xiaopengli89.github.io/about/">About</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<span class="hdr-social hide-in-mobile"><a href="mailto:x.friday@outlook.com" target="_blank" rel="noopener me" title="Email"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg></a><a href="https://www.linkedin.com/in/%E5%B0%8F%E9%B9%8F-%E6%9D%8E-078a86124/" target="_blank" rel="noopener me" title="Linkedin"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle></svg></a><a href="https://github.com/xiaopengli89" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://xiaopengli89.github.io/posts/">Posts</a></li>
			<li><a href="https://xiaopengli89.github.io/tags/">Tags</a></li>
			<li><a href="https://xiaopengli89.github.io/about/">About</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Jul 22, 2020</span></div>
				<h1>Rust新的内联汇编语法</h1>
			</header>
			<div class="content">
				<p>昨天Rust新的内联汇编语法被合并进主分支 <a href="https://github.com/rust-lang/rfcs/pull/2873">Inline assembly #2873</a> ，旧的内联汇编宏被重新命名为了 <code>llvm_asm!</code> ,如果使用了旧的内联汇编宏的项目需要做下修改以保持兼容。</p>
<p>旧的内联汇编语法仅仅是简单地对 <code>LLVM IR</code> 中的内联汇编做了下包装，新的语法更加友好，并且将 <code>Intel</code> 汇编语法作为默认语法取代之前的 <code>AT&amp;T</code> 汇编语法。</p>
<h2 id="基本用法">基本用法<a href="#基本用法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>目前可以在最新的 <code>nightly</code> 构建版Rust中使用新的内联汇编语法，同时需要开启 <code>#![feature(asm)]</code> ，当然 <code>asm!</code> 宏只能在 <code>unsafe</code> 块中使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#![feature(asm)]</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;nop&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>上面执行了一个空操作（<code>NOP</code>），<code>asm!</code> 宏的第一个参数是要被插入的汇编代码模版，可以像Rust中其他模版一样绑定变量，不过有稍许不同：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">a</span>: <span class="kt">i64</span> <span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">b</span>: <span class="kt">i64</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;mov {0}, {1}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">dbg</span><span class="o">!</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w">
</span></code></pre></div><pre><code class="language-none" data-lang="none">[src/main.rs:9] b = 1
</code></pre><p>上面的 <code>out</code> 操作数表示输出，<code>b</code> 为目标变量, <code>reg</code> 寄存器类则是让Rust编译器自动分配一个寄存器，当寄存器的值被更新后会再读取其中的值到变量 <code>b</code> 中（也就是写到变量 <code>b</code> 所在的栈地址）。</p>
<p>可以查看生成的汇编代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="err">#</span> <span class="err">%</span><span class="nl">bb.0:</span>
	<span class="nf">push</span>	<span class="nb">rbx</span>							<span class="err">#</span> <span class="err">保存寄存器</span><span class="nb">rbx</span><span class="err">的值到栈上</span>
	<span class="nf">sub</span>	<span class="nb">rsp</span><span class="p">,</span> <span class="mi">320</span>						<span class="err">#</span> <span class="err">分配栈空间</span>
	<span class="nf">mov</span>	<span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mi">280</span><span class="p">],</span> <span class="mi">1</span>		<span class="err">#</span> <span class="err">初始化变量</span> <span class="nv">a</span> <span class="err">=</span> <span class="mi">1</span>
	<span class="nf">mov</span>	<span class="nb">eax</span><span class="p">,</span> <span class="mi">1</span>							<span class="err">#</span> <span class="err">把变量</span><span class="nv">a的值写入寄存器eax</span>
	<span class="err">#</span><span class="nf">APP</span>
	<span class="nf">mov</span>	<span class="nb">rcx</span><span class="p">,</span> <span class="nb">rax</span>						<span class="err">#</span> <span class="err">把寄存器</span><span class="nb">rax</span><span class="err">的值写入寄存器</span><span class="nb">rcx</span>
	<span class="err">#</span><span class="nf">NO_APP</span>
	<span class="nf">mov</span>	<span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mi">112</span><span class="p">],</span> <span class="nb">rcx</span>		<span class="err">#</span> <span class="err">把寄存器</span><span class="nb">rcx</span><span class="err">的值写入变量</span> <span class="nv">b</span>
</code></pre></div><p>也支持多条汇编模版指令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">a</span>: <span class="kt">i64</span> <span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">b</span>: <span class="kt">i64</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;mov {0}, {1}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;add {0}, {2}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="n">out</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="k">const</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">dbg</span><span class="o">!</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w">
</span></code></pre></div><pre><code class="language-none" data-lang="none">[src/main.rs:15] b = 6
</code></pre><p><code>in</code> 和 <code>out</code> 操作数也可以同时使用，记作 <code>inout</code> ，它的作用就是读取变量的值到寄存器，操作完后再写回变量中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">a</span>: <span class="kt">i64</span> <span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">b</span>: <span class="kt">i64</span> <span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;add {0}, {1}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;add {0}, {2}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="n">inout</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="k">const</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">dbg</span><span class="o">!</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w">
</span></code></pre></div><pre><code class="language-none" data-lang="none">[src/main.rs:15] b = 8
</code></pre><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="err">#</span> <span class="err">%</span><span class="nl">bb.0:</span>
	<span class="nf">push</span>	<span class="nb">rbx</span>
	<span class="nf">sub</span>	<span class="nb">rsp</span><span class="p">,</span> <span class="mi">320</span>
	<span class="nf">mov</span>	<span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mi">280</span><span class="p">],</span> <span class="mi">1</span>		
	<span class="nf">mov</span>	<span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mi">112</span><span class="p">],</span> <span class="mi">2</span>		<span class="err">#</span> <span class="err">初始化变量</span> <span class="nv">b</span> <span class="err">=</span> <span class="mi">2</span>
	<span class="nf">mov</span>	<span class="nb">rax</span><span class="p">,</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mi">112</span><span class="p">]</span>		<span class="err">#</span> <span class="err">读取变量</span><span class="nv">b的值到寄存器rax</span>
	<span class="nf">mov</span>	<span class="nb">ecx</span><span class="p">,</span> <span class="mi">1</span>
	<span class="err">#</span><span class="nf">APP</span>
	<span class="nf">add</span>	<span class="nb">rax</span><span class="p">,</span> <span class="nb">rcx</span>
	<span class="nf">add</span>	<span class="nb">rax</span><span class="p">,</span> <span class="mi">5</span>
	<span class="err">#</span><span class="nf">NO_APP</span>
	<span class="nf">mov</span>	<span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mi">112</span><span class="p">],</span> <span class="nb">rax</span>
</code></pre></div><p><code>inout</code> 操作数也可以将输入和输出指定不同的变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">a</span>: <span class="kt">i64</span> <span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">b</span>: <span class="kt">i64</span> <span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">c</span>: <span class="kt">i64</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;add {0}, {1}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;add {0}, {2}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="n">inout</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="k">const</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">dbg</span><span class="o">!</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">dbg</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="p">);</span><span class="w">
</span></code></pre></div><pre><code class="language-none" data-lang="none">[src/main.rs:16] b = 2
[src/main.rs:17] c = 8
</code></pre><p><code>inout(reg) b =&gt; c</code> 表示输入变量 <code>b</code> 的值，输出到变量 <code>c</code> ，可以看到变量 <code>b</code> 的值还是2，而变量 <code>c</code> 的值为8。</p>
<h2 id="延迟输出-lateout">延迟输出 <code>lateout</code><a href="#延迟输出-lateout" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>默认情况下，<code>rustc</code> 对寄存器的分配采取保守策略，即每次输出都会写回到栈上变量或分配独立的寄存器，因为用于输出的寄存器可能会被随时覆盖并得到错误的结果。但是这样会导致寄存器的过多占用，从性能优化考虑，能占用的寄存器越少越好，这样可以为更多的变量分配寄存器，而不用在寄存器和内存两端来回拷贝数据。</p>
<p><code>lateout</code> 操作数则表示延迟输出，不用立即写回到栈上变量，也可能会和其他变量复用同一个寄存器。所以 <code>lateout</code> 只能用在所有的输入都已消费的情况下，防止还未写回的寄存器值被覆盖，或影响其他使用了同一个寄存器的其他变量，比如错误用法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">b</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">c</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;add {0}, {1}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;add {0}, {2}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="n">inlateout</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>由于变量 <code>a</code>, <code>b</code>, <code>c</code> 具有相同的值，rustc <strong>可能</strong> 会为它们分配同一个寄存器。执行完第一条指令后，变量 <code>c</code> 还没有被消费，但是寄存器已经被第一条指令覆盖了其中的值，此时变量 <code>c</code> 会直接使用寄存器内的值，不是预期的 <code>4</code> ，而是 <code>8</code>，最后也会得到错误的结果 <code>16</code>。</p>
<p><strong>NOTE:</strong> 不过当前的编译器还是为三个变量分配了不同的寄存器，所以以上的结果依然是正确的，但不保证以后也正确。</p>
<p>正确用法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">b</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;add {0}, {1}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="s">&#34;add {0}, 2&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="n">inlateout</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w">
</span><span class="w">		</span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w">
</span></code></pre></div><p><code>lateout</code> 操作数后没有其他输入了，因此这样使用是正确的。</p>
<h2 id="手动指定寄存器">手动指定寄存器<a href="#手动指定寄存器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>某些指令只能操作某些/某个寄存器，比如 <code>out</code> 指令，它只能读取 <code>eax</code> 或其子寄存器。</p>
<p>比如读取变量 <code>cmd</code> 的值到寄存器 <code>eax</code>，然后写入 <code>0x64</code> 端口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xd1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;out 0x64, eax&#34;</span><span class="p">,</span><span class="w"> </span><span class="k">in</span><span class="p">(</span><span class="s">&#34;eax&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">cmd</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>手动指定的寄存器不能使用模版绑定，同时也必须位于其他自动绑定的操作数末尾。</p>
<p>比如 <code>mul</code> 指令接收一个寄存器的值，然后同 <code>rax</code> 寄存器的值相乘，结果高位写入 <code>rdx</code>，低位写入 <code>rax</code> ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">mul</span><span class="p">(</span><span class="n">a</span>: <span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">u128</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">lo</span>: <span class="kt">u64</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">hi</span>: <span class="kt">u64</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">            </span><span class="c1">// The x86 mul instruction takes rax as an implicit input and writes
</span><span class="c1"></span><span class="w">            </span><span class="c1">// the 128-bit result of the multiplication to rax:rdx.
</span><span class="c1"></span><span class="w">            </span><span class="s">&#34;mul {}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">inlateout</span><span class="p">(</span><span class="s">&#34;rax&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">lo</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">lateout</span><span class="p">(</span><span class="s">&#34;rdx&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">hi</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="p">((</span><span class="n">hi</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u128</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">lo</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u128</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="忽略寄存器的值">忽略寄存器的值<a href="#忽略寄存器的值" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>某些情况下，修改了寄存器的值，但是我们不关心它的值，或者只临时存在于寄存器中，可以用 <code>_</code> 来忽略它。</p>
<p>比如计算 <code>x</code> 乘以 <code>6</code> ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Multiply x by 6 using shifts and adds
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">x</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="s">&#34;mov {tmp}, {x}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="s">&#34;shl {tmp}, 1&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="s">&#34;shl {x}, 2&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="s">&#34;add {x}, {tmp}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inout</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>我们将 <code>x</code> 绑定的寄存器的值复制一份到一个临时寄存器中，然后将2个寄存器的值分别左移1位和2位，然后相加结果保存到 <code>x</code> 。这里我们不需要一个栈上变量来保存那个临时的寄存器值，因为它只需要临时存在于寄存器中。</p>
<h2 id="符号操作数">符号操作数<a href="#符号操作数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p><code>sym</code> 操作数可以绑定一个符号，可以是一个函数或静态变量，可以实现函数调用或访问静态变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">arg</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;arg = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">call_foo</span><span class="p">(</span><span class="n">arg</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;call {}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">sym</span><span class="w"> </span><span class="n">foo</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="c1">// 1st argument in rdi, which is caller-saved
</span><span class="c1"></span><span class="w">            </span><span class="n">inout</span><span class="p">(</span><span class="s">&#34;rdi&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="c1">// All caller-saved registers must be marked as clobberred
</span><span class="c1"></span><span class="w">            </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;rax&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;rcx&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;rdx&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;rsi&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;r8&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;r9&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;r10&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;r11&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm0&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm1&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm2&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm3&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm4&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm5&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm6&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm7&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm8&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm9&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm10&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm11&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm12&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm13&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm14&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="s">&#34;xmm15&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>extern &quot;C&quot;</code> 修饰是为了让函数 <code>foo</code> 符合 <code>C</code> 的调用约定，<code>sym foo</code> 会自动绑定 <code>foo</code> 生成的符号，不需要使用 <code>#[no_mangle]</code> 或 <code>pub</code>。</p>
<h2 id="寄存器模版标识">寄存器模版标识<a href="#寄存器模版标识" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p><code>reg</code> 寄存器类会为变量分配完整的寄存器尺寸，比如在 <code>x86-64</code> 体系结构的 <code>rax</code>，<code>x86</code> 体系结构的 <code>eax</code>。<code>reg_abcd</code> 寄存器类可以分配16bit的 <code>ax</code>，<code>bx</code>, <code>cx</code>, <code>dx</code> 寄存器。</p>
<p>而寄存器模版标识可以在模板中再指定子寄存器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span>: <span class="kt">u16</span> <span class="o">=</span><span class="w"> </span><span class="mh">0x02</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;mov {0:h}, {0:l}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">inout</span><span class="p">(</span><span class="n">reg_abcd</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mh">0x0202</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>生成的汇编代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="err">#</span> <span class="err">%</span><span class="nl">bb.0:</span>
	<span class="nf">sub</span>	<span class="nb">rsp</span><span class="p">,</span> <span class="mi">248</span>
	<span class="nf">mov</span>	<span class="kt">word</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mi">86</span><span class="p">],</span> <span class="mi">2</span>
	<span class="nf">mov</span>	<span class="nb">ax</span><span class="p">,</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mi">86</span><span class="p">]</span>
	<span class="err">#</span><span class="nf">APP</span>
	<span class="nf">mov</span>	<span class="nb">ah</span><span class="p">,</span> <span class="nb">al</span>
	<span class="err">#</span><span class="nf">NO_APP</span>
	<span class="nf">mov</span>	<span class="kt">word</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mi">86</span><span class="p">],</span> <span class="nb">ax</span>
</code></pre></div><p>可以看到 <code>{0:h}</code> 和 <code>{0:l}</code> 分别被替换成了 <code>ah</code> 和 <code>al</code> 2个8bit寄存器。</p>
<h2 id="附加选项">附加选项<a href="#附加选项" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>默认情况下，<code>asm!</code> 的代码块会被编译器当作正常的 <code>FFI</code> 函数调用约定，比如会读写内存，可能产生副作用等。不过附加选项可以告诉编译器你的代码在做些什么，方便编译器进行优化。</p>
<p><strong>NOTE:</strong> 附加选项只能作为 <code>asm!</code> 宏的最后一个参数。</p>
<p><code>pure</code> 选项告诉编译器代码块不会产生副作用，它的结果只依赖于输入，比如你不会去读写内存，这样编译器可以优化执行的次数，如果代码块没有输出或只有 <code>_</code> 将导致编译错误。</p>
<p><code>nomem</code> 选项告诉编译器代码块不会读写内存，这样编译器就可以缓存跨 <code>asm!</code> 代码块的寄存器中的值。</p>
<p><code>readonly</code> 选项告诉编译器代码块不会写内存，这样编译器就可以缓存跨 <code>asm!</code> 代码块的未修改过的寄存器中的值。</p>
<p><strong>NOTE:</strong> <code>nomem</code> 和 <code>readonly</code> 不能同时使用，并且 <code>pure</code> 必须同其一一起使用。</p>
<p><code>preserves_flags</code> 选项告诉编译器代码块不会修改标识寄存器，这样 <code>asm!</code> 代码块结束后不需要重新计算标识寄存器的值。</p>
<p><code>noreturn</code> 选项告诉编译器该 <code>asm!</code> 宏永不返回，如果代码中有输出将导致编译错误。</p>
<p><code>nostack</code> 选项告诉编译器代码块不会往栈上push数据或者操作栈的 <code>red zone</code> <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。</p>
<p><code>att_syntax</code> 选项告诉编译器代码块使用 <code>AT&amp;T</code> 汇编语法。</p>
<h2 id="参考资料">参考资料<a href="#参考资料" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<ol>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/2873-inline-asm.md">Rust RFC2873 Inline Assembly</a></li>
</ol>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p><code>red zone</code> 指的是栈顶指针下方一段内存区域，它不会被中断、异常或信号占用，一般被叶子函数优化使用，减少两次栈顶指针操作。- <a href="https://en.wikipedia.org/wiki/Red_zone_(computing)">维基百科</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://xiaopengli89.github.io/tags/rust">rust</a></span><span class="tag"><a href="https://xiaopengli89.github.io/tags/assembly">assembly</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>2695 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2020-07-22 12:58 &#43;0800</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="next-post" href="https://xiaopengli89.github.io/posts/rust-lifetime-variance/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;Newer</span><br><span>Rust中的生命周期及变性</span>
			</a>
			<a class="prev-post" href="https://xiaopengli89.github.io/posts/oci-ns-network/">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>OCI容器运行时实现（二）</span>
			</a>
		</div>
		<div id="comments" class="thin">
</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2021 <a href="https://xiaopengli89.github.io">Xiaopeng Li</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://xiaopengli89.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://xiaopengli89.github.io/js/bundle.min.7d8545daa55d62427355498dd8da13f98ff79a7938ce7d2a5e2ae1ec0de3beb8.js" integrity="sha256-fYVF2qVdYkJzVUmN2NoT+Y/3mnk4zn0qXirh7A3jvrg=" crossorigin="anonymous"></script>
	
<script src="https://cdn.bootcdn.net/ajax/libs/prism/1.20.0/prism.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/prism/1.20.0/plugins/autoloader/prism-autoloader.min.js"></script>
<script>Prism.plugins.autoloader.languages_path = 'https://cdn.bootcdn.net/ajax/libs/prism/1.20.0/components/'</script>



</body>

</html>
