<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="theme-color" content="#000" />
    <title>
        
            Rust闭包 &middot;  Laika
        
    </title>

    
	<link href="https://cdn.bootcdn.net/ajax/libs/pure/2.0.3/pure-min.css" rel="stylesheet" crossorigin="anonymous">
    
    
	<link href="https://cdn.bootcdn.net/ajax/libs/pure/2.0.3/grids-responsive-min.css" rel="stylesheet">
    
    <link rel="stylesheet" href="/css/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Sans+Condensed:wght@300&family=Merriweather:ital,wght@0,300;0,700;1,300&display=swap" rel="stylesheet">
    <link rel="icon" href="/img/favicon.ico" type="image/x-icon">

    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/atom.xml" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="">
    
    
    <meta name="description" content="Rust也可以函数式，像动态创建&#34;函数&#34;一样使用闭包。">
    

    
    <meta name="keywords" content="rust,closure">
    
    <meta name="author" content="Xiaopeng Li"><link href="https://atelierbram.github.io/syntax-highlighting/archive/assets/css/prism/prism-base16-mocha.dark.css" rel="stylesheet" />
</head>
<body>
        <div class="container"><div id="navbar" class="pure-menu pure-menu-open pure-menu-horizontal pure-menu-scrollable">
    <a href="/" class="pure-menu-heading">
        
            Laika 
         
    </a>
    <ul class="pure-menu-list">
        <li class="pure-menu-item">
            <a href="/posts" class="pure-menu-link">
                <i class="fa fa-archive"></i>
                Articles
            </a>
        </li>
        <li class="pure-menu-item">
            <a href="/tags" class="pure-menu-link">
                <i class="fas fa-comments"></i>
                Categories
            </a>
        </li>
        <li class="pure-menu-item">
            <a href="/about" class="pure-menu-link">
                <i class="fas fa-smile"></i>
                About
            </a>
        </li>
    </ul>
    <ul class="pure-menu-list pull-right">
        
        <li class="pure-menu-item">
            <a href="https://github.com/xiaopengli89" title="Github" class="pure-menu-link">
                <i class="fab fa-github"></i>
                <span class="hide">Github</span>
            </a>
        </li>
        
        
        
        <li class="pure-menu-item">
            <a href="https://www.linkedin.com/in/%E5%B0%8F%E9%B9%8F-%E6%9D%8E-078a86124/" title="Linked In" class="pure-menu-link">
                <i class="fab fa-linkedin"></i>
                <span class="hide">LinkedIn</span>
            </a>
        </li>
        
        
        
        <li class="pure-menu-item">
            <a href="/posts/index.xml" title="Atom Feed" class="pure-menu-link">
                <i class="fas fa-rss-square"></i>
                <span class="hide">RSS Feed</span>
            </a>
        </li>
    </ul>
</div>
<div class="pure-u-1">
    <div class="pad">
    </div>
</div>
<div class="pure-g">


<div id="content" class="pure-u-1 pure-u-md-3-4 pure-u-sm-1">
    <div class="pad">
<div class="date">
    <time pubdate="2020-06-23">June 23, 2020</time>
    <span class="author">by Xiaopeng Li</span>
</div>

<article>
    <h1><a href="/posts/rust-closure/">Rust闭包</a></h1>
    <div class="tags">
        
        
        <a href="/tags/rust" class="pure-button">rust</a>
        
        
        <a href="/tags/closure" class="pure-button">closure</a>
        
    </div>
    <h3 id="闭包closure的实现原理">闭包(Closure)的实现原理</h3>
<p>闭包在调用形式上和函数非常相似：</p>
<ol>
<li>传递参数</li>
<li>执行一段代码</li>
<li>返回结果</li>
</ol>
<p>但是闭包可以捕获当前上下文环境中的变量，而函数不可以（访问全局静态变量除外，但是这和闭包的实现完全不一样）。</p>
<p>闭包的创建和调用：</p>
<pre><code class="language-rust">let env_var = 1;
let fn1 = |x| x + env_var;

let result1 = fn1(2);
assert_eq!(result1, 3);

let result2 = fn1(3);
assert_eq!(result2, 4);
</code></pre>
<p>编译器在编译过程中会创建对应的匿名结构，并根据需要实现三个 <code>trait</code>：<a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html">FnOnce</a>、<a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html">FnMut</a>、<a href="https://doc.rust-lang.org/std/ops/trait.Fn.html">Fn</a> ，而闭包的创建就是该匿名结构的实例化，闭包调用则是3个 <code>trait</code> 的方法调用。</p>
<p>以下是3个 <code>trait</code> 的定义：</p>
<pre><code class="language-rust">pub trait FnOnce&lt;Args&gt; {
    /// The returned type after the call operator is used.
    #[stable(feature = &quot;fn_once_output&quot;, since = &quot;1.12.0&quot;)]
    type Output;

    /// Performs the call operation.
    #[unstable(feature = &quot;fn_traits&quot;, issue = &quot;29625&quot;)]
    extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;
}

pub trait FnMut&lt;Args&gt;: FnOnce&lt;Args&gt; {
    /// Performs the call operation.
    #[unstable(feature = &quot;fn_traits&quot;, issue = &quot;29625&quot;)]
    extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;
}

pub trait Fn&lt;Args&gt;: FnMut&lt;Args&gt; {
    /// Performs the call operation.
    #[unstable(feature = &quot;fn_traits&quot;, issue = &quot;29625&quot;)]
    extern &quot;rust-call&quot; fn call(&amp;self, args: Args) -&gt; Self::Output;
}
</code></pre>
<p>其中 <code>Args</code> 为闭包参数类型，使用元组 ( <code>Tuple</code>) 来表示参数列表，<code>Output</code> 是返回值类型。</p>
<p>并且可以发现 <code>FnMut</code> 派生自 <code>FnOnce</code>，而 <code>Fn</code> 又派生自 <code>FnMut</code>，这里需要这样理解：</p>
<p><em><strong>如果一个函数接收一个 <code>FnOnce</code> 参数，总可以传递一个 <code>FnMut</code></strong></em><br>
<em><strong>如果一个函数接收一个 <code>FnMut</code>，总可以传递一个 <code>Fn</code></strong></em></p>
<p>我们可以手动构造一个 <code>FnOnce</code> 闭包结构实现：</p>
<pre><code class="language-rust">#![feature(unboxed_closures)]
#![feature(fn_traits)]

use std::ops::{Fn, FnMut, FnOnce};

struct MyFn {
    env_var: String,
}

impl FnOnce&lt;(i32, i32)&gt; for MyFn {
    type Output = String;
	
    extern &quot;rust-call&quot; fn call_once(self, args: (i32, i32)) -&gt; Self::Output {
        println!(&quot;{}&quot;, args.0 + args.1);
        self.env_var
    }
}

fn main() {
    let env_var = String::from(&quot;env_var&quot;);
    let my_fn = MyFn { env_var, };
	
    let o1: String = my_fn(1, 1); // 这里调用 call_once 方法, my_fn 变量 move 进方法
	assert_eq!(o1, String::from(&quot;env_var&quot;));
	
	let o2: String = my_fn(2, 2); // 编译不过，因为 my_fn 变量已经被 move 掉了
}
</code></pre>
<p>接着为 <code>MyFn</code> 实现 <code>FnMut</code>：</p>
<pre><code class="language-rust">// ...
struct MyFn&lt;'a&gt; {
    env_var: &amp;'a str,
}

impl&lt;'a&gt; FnOnce&lt;(i32, i32)&gt; for MyFn&lt;'a&gt; {
    type Output = String;
    extern &quot;rust-call&quot; fn call_once(mut self, args: (i32, i32)) -&gt; Self::Output {
        self.call_mut(args)
    }
}

impl&lt;'a&gt; FnMut&lt;(i32, i32)&gt; for MyFn&lt;'a&gt; {
    extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: (i32, i32)) -&gt; Self::Output {
        println!(&quot;{}&quot;, args.0 + args.1);
        self.env_var.to_owned()
    }
}

fn main() {
    let env_var = String::from(&quot;env_var&quot;);
    let mut my_fn = MyFn { env_var: &amp;env_var };
	
    let o1: String = my_fn(1, 1); // 这里调用 call_mut 方法, my_fn 变量 mut borrow 进方法
	assert_eq!(o1, String::from(&quot;env_var&quot;));
	
	let o2: String = my_fn(2, 2); // 还是调用 call_mut 方法，my_fn 变量依然有效
	assert_eq!(o2, String::from(&quot;env_var&quot;));
}
</code></pre>
<p>这里可以看到，如果某个参数如果需要调用 <code>call_once</code> 方法的话，<code>call_once</code> 内部只要再次调用 <code>call_mut</code> 即可，因为一个 <code>Ownership</code> 总可以转成一个 <code>Mut Borrow</code>，同理 <code>Mut Borrow</code> 总可以转成 <code>Borrow</code> 。</p>
<p>测试一个函数接受 <code>FnOnce</code>，传递一个 <code>FnMut</code>：</p>
<pre><code class="language-rust">// ...
fn expect_fn_once&lt;F&gt;(f: F)
where
    F: FnOnce&lt;(i32, i32), Output = String&gt;,
{
    let _: String = f(1, 2); // 这里调用的是 call_once
}

fn main() {
    let env_var = String::from(&quot;env_var&quot;);
    let my_fn = MyFn { env_var: &amp;env_var };
	
	expect_fn_once(my_fn); // 因为 my_fn 实现了 FnOnce，所以可以作为参数传递
}
</code></pre>
<p>另外，<code>FnOnce</code> 、<code>FnMut</code> 、<code>Fn</code> 有3个语法糖表示：</p>
<p><code>FnOnce(T1, T2) -&gt; T3</code> 可以用来表示 <code>FnOnce&lt;(T1, T2), Output = T3&gt;</code></p>
<p>因此上面的 <code>expect_fn_once</code> 方法可以简写为：</p>
<pre><code class="language-rust">fn expect_fn_once(f: impl FnOnce(i32, i32) -&gt; String)
{
    let _: String = f(1, 2);
}
</code></pre>
<p><code>FnMut</code> 、<code>Fn</code> 同理。</p>
<h3 id="编译器闭包的生成规则">编译器闭包的生成规则</h3>
<ol>
<li>如果闭包只需要上下文环境的 <code>Borrow</code> ，优先生成 <code>Fn</code> ，方法默认调用 <code>call</code> ，因为上下文环境可以被同时 <code>Borrow</code> 多次，例如：</li>
</ol>
<pre><code class="language-rust">let a = 1;

let fn1 = || {
	let _ = &amp;a;
};

let fn2 = || {
	let _ = &amp;a;
};

println!(&quot;{}&quot;, a);
</code></pre>
<ol start="2">
<li>如果闭包需要上下文环境的 <code>Mut Borrow</code>，则生成 <code>FnMut</code>，方法默认调用 <code>call_mut</code>，因为不会丢失 <code>Ownership</code>，闭包可以被多次调用，上下文环境 <code>Mut Borrow</code> 进闭包结构，当闭包被 <code>drop</code> 掉后，外部才能再次使用被捕获的变量，例如：</li>
</ol>
<pre><code class="language-rust">let mut a = 1;

let fn1 = || {
	let _ = &amp;mut a;
};

let fn2 = || {
	let _ = &amp;a; // 这里无法编译通过，因为 f1 已经 mut borrow 了 a
};

fn1();

println!(&quot;{}&quot;, a);
</code></pre>
<ol start="3">
<li>如果闭包需要上下文的 <code>Ownership</code>，则生成 <code>FnOcne</code>，方法调用 <code>call_once</code>，因为调用闭包会导致失去 <code>Ownership</code> ，所以闭包只能调用一次，上下文环境被 <code>move</code> 进闭包，外部不再能使用被捕获的变量，例如：</li>
</ol>
<pre><code class="language-rust">let a = String::from(&quot;a&quot;);

let fn1 = || {
	let b: String = a;
	b
};

let fn2 = || {
	let b: String = a; // 这里无法编译通过，因为 a 变量已经被 move 进了 fn1
};

println!(&quot;{}&quot;, a); // 这里也无法编译通过
</code></pre>
<p>有时我们需要强制捕获变量的 <code>Ownership</code> ，可以在闭包上修饰 <code>move</code> 关键字，这在多线程/异步环境下很常见。</p>
</article>

    </div>
</div>


                
<div id="sidebar" class="pure-u-1 pure-u-md-1-4 pure-u-sm-1">
    <div class="pad">
        <a name="about"></a>
        <h3>About Me</h3>
        <div style="text-align: center;">
            <img src="/img/DvZdstGUUAANxzC.jpg" alt="Xiaopeng Li" class="pure-img" />
            <p><em>Sorcerer in C.E.</em></p>
        </div>

        <h3>Latest Articles</h3>
        <div class="pure-menu pure-menu-open">
            <ul class="pure-menu-list">
                
                <li class="pure-menu-item">
                    <a href="/posts/plain-rt/" class="pure-menu-link">实现一个无依赖的Rust异步运行时<br>
                        <small>一个基本的Rust异步运行时实现，不依赖第三方crate，单文件，非常直观地解释Rust异步的基本原理。</small>
                    </a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="/posts/rust-hrtbs/" class="pure-menu-link">Rust高阶生命周期绑定<br>
                        <small>有时无法静态描述一个生命周期，Rust中提供了一种&#34;动态&#34;绑定生命周期的方式。</small>
                    </a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="/posts/rust-box-heap/" class="pure-menu-link">Rust动态内存分配<br>
                        <small>学习Rust的内存管理及实现一个简单的Box。</small>
                    </a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="/posts/rust-no-std/" class="pure-menu-link">不使用Rust标准库编写一个可运行的程序<br>
                        <small>Rust是一门真正的系统编程语言。</small>
                    </a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="/posts/rust-procedural-macro-1/" class="pure-menu-link">Rust过程宏（一）<br>
                        <small>开始Rust元编程，利用Rust的derive派生宏，消除重复的样板代码。</small>
                    </a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="/posts/rust-closure/" class="pure-menu-link">Rust闭包<br>
                        <small>Rust也可以函数式，像动态创建&#34;函数&#34;一样使用闭包。</small>
                    </a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="/posts/go-mysql-driver-race/" class="pure-menu-link">关于Go Mysql Driver引入QueryContext带来的数据竞争<br>
                        <small>并发编程里的常见问题--数据竞争。</small>
                    </a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="/posts/go-mysql-driver-eof/" class="pure-menu-link">关于Go Mysql Driver的unexpected EOF错误<br>
                        <small>应该是大多数Golang开发者日志里的东西了。</small>
                    </a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="/posts/socket-optimize/" class="pure-menu-link">关于Socket应用的性能优化<br>
                        <small>一点网络优化的小技巧。</small>
                    </a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="/posts/two-queue/" class="pure-menu-link">2Q(双链)缓存淘汰策略<br>
                        <small>经典LRU算法的实用变体。</small>
                    </a>
                </li>
                
            </ul>
        </div>

        <h3>Categories</h3>
        <div style="text-align:center" class="tags">
            
            
            <a href="/tags/rust" class="pure-button"> rust
                <small>(8)</small></a>
            
            
            
            <a href="/tags/database" class="pure-button"> database
                <small>(2)</small></a>
            
            
            
            <a href="/tags/golang" class="pure-button"> golang
                <small>(2)</small></a>
            
            
            
            <a href="/tags/kernel" class="pure-button"> kernel
                <small>(2)</small></a>
            
            
            
            <a href="/tags/linux" class="pure-button"> linux
                <small>(2)</small></a>
            
            
            
            <a href="/tags/memory" class="pure-button"> memory
                <small>(2)</small></a>
            
            
            
            <a href="/tags/mysql" class="pure-button"> mysql
                <small>(2)</small></a>
            
            
            
            <a href="/tags/tcp" class="pure-button"> tcp
                <small>(2)</small></a>
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
        </div>
    </div> 
</div> 

                
            </div><div class="pure-g">
	<footer class="pure-u-1 pure-u-md-1 pure-u-sm-1">
		<p>This page and its contents are copyright &copy; 2020,
			<a href="">Xiaopeng Li</a>.</p>
		<p><a href="https://github.com/pravin/hugo-theme-prav">Theme Prav</a> by <a href="https://cto.me.uk">Pravin
				Paratey</a></p>
	</footer>

	<script defer src="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.13.1/js/all.min.js" crossorigin="anonymous"></script>
</div>
</div><script src="https://cdn.bootcdn.net/ajax/libs/prism/1.20.0/prism.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/prism/1.20.0/plugins/autoloader/prism-autoloader.min.js"></script>
<script>Prism.plugins.autoloader.languages_path = 'https://cdn.bootcdn.net/ajax/libs/prism/1.20.0/components/'</script>
</body>
</html>
