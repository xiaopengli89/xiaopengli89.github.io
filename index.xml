<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Torigoth</title>
    <link>https://xiaopengli89.github.io/</link>
    <description>Recent content on Torigoth</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Wed, 22 Jul 2020 12:58:16 +0800</lastBuildDate>
    
	<atom:link href="https://xiaopengli89.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Rust新的内联汇编语法</title>
      <link>https://xiaopengli89.github.io/posts/rust-asm-macro/</link>
      <pubDate>Wed, 22 Jul 2020 12:58:16 +0800</pubDate>
      
      <guid>https://xiaopengli89.github.io/posts/rust-asm-macro/</guid>
      <description>&lt;p&gt;昨天Rust新的内联汇编语法被合并进主分支 &lt;a href=&#34;https://github.com/rust-lang/rfcs/pull/2873&#34;&gt;Inline assembly #2873&lt;/a&gt; ，旧的内联汇编宏被重新命名为了 &lt;code&gt;llvm_asm!&lt;/code&gt; ,如果使用了旧的内联汇编宏的项目需要做下修改以保持兼容。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OCI容器运行时实现（二）</title>
      <link>https://xiaopengli89.github.io/posts/oci-ns-network/</link>
      <pubDate>Mon, 20 Jul 2020 19:42:00 +0800</pubDate>
      
      <guid>https://xiaopengli89.github.io/posts/oci-ns-network/</guid>
      <description>&lt;p&gt;本篇文章在之前基础上实现容器的网络互通。&lt;/p&gt;
&lt;p&gt;实现思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在宿主机上创建网桥设备&lt;/li&gt;
&lt;li&gt;当子进程命名空间创建后，父进程获取子进程的命名空间&lt;/li&gt;
&lt;li&gt;利用管道实现父子进程同步&lt;/li&gt;
&lt;li&gt;创建虚拟设备对&lt;/li&gt;
&lt;li&gt;分别将虚拟设备对添加进子进程网络命名空间和连接到网桥&lt;/li&gt;
&lt;li&gt;分配虚拟设备ip并启动&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; 由于很多系统调用没有封装，这里将使用宿主机上的命令代替实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OCI容器运行时实现（一）</title>
      <link>https://xiaopengli89.github.io/posts/oci-ns-pid-mount-net/</link>
      <pubDate>Sat, 18 Jul 2020 22:15:35 +0800</pubDate>
      
      <guid>https://xiaopengli89.github.io/posts/oci-ns-pid-mount-net/</guid>
      <description>&lt;p&gt;一个OCI容器运行时有3个组成部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://man7.org/linux/man-pages/man7/namespaces.7.html&#34;&gt;NAMESPACES&lt;/a&gt; - 实现资源的隔离&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://man7.org/linux/man-pages/man7/cgroups.7.html&#34;&gt;CGROUPS&lt;/a&gt; - 实现资源的限制&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://man7.org/linux/man-pages/man2/pivot_root.2.html&#34;&gt;PIVOT_ROOT&lt;/a&gt; - 实现独立的根文件系统&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文将实现一个简易的 &lt;code&gt;进程&lt;/code&gt;、&lt;code&gt;根文件系统&lt;/code&gt;、&lt;code&gt;网络&lt;/code&gt; 隔离的容器运行时。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>实现一个无依赖的Rust异步运行时</title>
      <link>https://xiaopengli89.github.io/posts/plain-rt/</link>
      <pubDate>Fri, 10 Jul 2020 19:23:16 +0800</pubDate>
      
      <guid>https://xiaopengli89.github.io/posts/plain-rt/</guid>
      <description>&lt;p&gt;这篇文章将非常直观、易懂地解释Rust异步运行时的实现。代码不超过300行，只依赖标准库，支持 &lt;code&gt;spawn&lt;/code&gt; 多个 &lt;code&gt;Task&lt;/code&gt; 并发执行。&lt;/p&gt;
&lt;p&gt;首先，Rust标准库对异步的抽象主要集中于几个类型，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Future&lt;/code&gt; - 对于一个异步操作的抽象，代表一个未来事件，如果事件未就绪，应暂停当前 &lt;code&gt;Task&lt;/code&gt;（可以去执行其他 &lt;code&gt;Task&lt;/code&gt;），事件就绪后，恢复执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Waker&lt;/code&gt; - 唤醒器，当事件就绪后，通知运行时重新调度和这个 &lt;code&gt;Waker&lt;/code&gt; 绑定的 &lt;code&gt;Task&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pin&lt;/code&gt; - 固定对象，是为了解决生成器状态机的自引用问题&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Rust高阶生命周期绑定</title>
      <link>https://xiaopengli89.github.io/posts/rust-hrtbs/</link>
      <pubDate>Fri, 03 Jul 2020 23:40:45 +0800</pubDate>
      
      <guid>https://xiaopengli89.github.io/posts/rust-hrtbs/</guid>
      <description>&lt;p&gt;Rust中，&lt;code&gt;lifetime&lt;/code&gt; 其实也是一种类型参数，可以看成范型的一种特殊形式。编译时需要将所有类型（包括 &lt;code&gt;lifetime&lt;/code&gt; ）确定下来，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn foo&amp;lt;&#39;a&amp;gt;(x: &amp;amp;&#39;a i32) {
	// ...
}

&#39;a: {
	let x = 1;
	foo::&amp;lt;&#39;a&amp;gt;(&amp;amp;x);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的 &lt;code&gt;&#39;a&lt;/code&gt; 生命周期其实就是变量 &lt;code&gt;x&lt;/code&gt; 所在的block。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rust动态内存分配</title>
      <link>https://xiaopengli89.github.io/posts/rust-box-heap/</link>
      <pubDate>Wed, 01 Jul 2020 16:57:56 +0800</pubDate>
      
      <guid>https://xiaopengli89.github.io/posts/rust-box-heap/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/std/boxed/index.html&#34;&gt;Box&lt;/a&gt; 是一个在Rust中经常被用到的智能指针，它的作用是实现堆内存分配，并且管理该块内存的生命周期。尤其在实现递归数据结构时，通过 &lt;a href=&#34;https://doc.rust-lang.org/std/boxed/index.html&#34;&gt;Box&lt;/a&gt; 才能让一个类型大小不会无限膨胀。同时 &lt;a href=&#34;https://doc.rust-lang.org/std/boxed/index.html&#34;&gt;Box&lt;/a&gt; 的内存布局同 &lt;code&gt;C&lt;/code&gt; 二进制兼容，也就是说在使用 &lt;code&gt;FFI&lt;/code&gt; 时，可以直接在参数或返回值中使用 &lt;a href=&#34;https://doc.rust-lang.org/std/boxed/index.html&#34;&gt;Box&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这篇文章将介绍利用Rust的动态内存分配实现一个简单的自定义 &lt;code&gt;Box&lt;/code&gt; 。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>不使用Rust标准库编写一个可运行的程序</title>
      <link>https://xiaopengli89.github.io/posts/rust-no-std/</link>
      <pubDate>Wed, 01 Jul 2020 00:02:35 +0800</pubDate>
      
      <guid>https://xiaopengli89.github.io/posts/rust-no-std/</guid>
      <description>&lt;p&gt;Rust是一门系统编程语言，比如使得编写操作系统内核变得可能。而在编写内核时，是不能有任何和操作系统相关的依赖的，因为操作系统内核是运行于裸机之上的，这就像鸡和鸡蛋的关系。而标准库的实现是基于操作系统的，诸如线程、文件、网络等等。因此在编写内核代码时不能使用标准库。这篇文章将介绍如何不使用Rust标准库编写一个可运行的程序。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rust过程宏（一）</title>
      <link>https://xiaopengli89.github.io/posts/rust-procedural-macro-1/</link>
      <pubDate>Sat, 27 Jun 2020 17:22:04 +0800</pubDate>
      
      <guid>https://xiaopengli89.github.io/posts/rust-procedural-macro-1/</guid>
      <description>&lt;h3 id=&#34;rust宏&#34;&gt;Rust宏&lt;/h3&gt;
&lt;p&gt;宏属于元编程，用于生成代码，减少重复代码的编写，同时不同于运行时反射，宏会在编译时被展开，没有运行时开销。在Rust中，宏大体分为2类：声明宏和过程宏。&lt;/p&gt;
&lt;p&gt;声明宏较为简单，类似模式匹配，利用递归和替换把重复的代码片段隐藏起来，典型的实现是标准库中 &lt;code&gt;vec!&lt;/code&gt;，&lt;code&gt;println!&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;过程宏则稍微复杂，但是功能强大的多，可以精确地控制语法树的生成。同时过程宏使用Rust代码编写，灵活性和表达能力丰富。过程宏经常被用于3种情景下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自动实现 &lt;code&gt;trait&lt;/code&gt;，使用 &lt;code&gt;derive&lt;/code&gt; 派生宏&lt;/li&gt;
&lt;li&gt;装饰 &lt;code&gt;field&lt;/code&gt; 或 函数，使用 &lt;code&gt;attribute&lt;/code&gt; 属性宏&lt;/li&gt;
&lt;li&gt;实现 &lt;code&gt;DSL&lt;/code&gt;，使用 &lt;code&gt;function&lt;/code&gt; 函数宏&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Rust闭包</title>
      <link>https://xiaopengli89.github.io/posts/rust-closure/</link>
      <pubDate>Tue, 23 Jun 2020 22:59:21 +0800</pubDate>
      
      <guid>https://xiaopengli89.github.io/posts/rust-closure/</guid>
      <description>&lt;h3 id=&#34;闭包closure的实现原理&#34;&gt;闭包(Closure)的实现原理&lt;/h3&gt;
&lt;p&gt;闭包在调用形式上和函数非常相似：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;传递参数&lt;/li&gt;
&lt;li&gt;执行一段代码&lt;/li&gt;
&lt;li&gt;返回结果&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是闭包可以捕获当前上下文环境中的变量，而函数不可以（访问全局静态变量除外，但是这和闭包的实现完全不一样）。&lt;/p&gt;
&lt;p&gt;闭包的创建和调用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let env_var = 1;
let fn1 = |x| x + env_var;

let result1 = fn1(2);
assert_eq!(result1, 3);

let result2 = fn1(3);
assert_eq!(result2, 4);
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>关于Go Mysql Driver引入QueryContext带来的数据竞争</title>
      <link>https://xiaopengli89.github.io/posts/go-mysql-driver-race/</link>
      <pubDate>Sun, 24 May 2020 14:50:06 +0800</pubDate>
      
      <guid>https://xiaopengli89.github.io/posts/go-mysql-driver-race/</guid>
      <description>&lt;p&gt;在&lt;a href=&#34;https://xiaopengli89.github.io/posts/go-mysql-driver-eof/&#34;&gt;关于Go Mysql Driver的unexpected EOF错误&lt;/a&gt;里提到了连接池，当连接&lt;strong&gt;使用完毕&lt;/strong&gt;后会放回连接池以便其他的操作可以复用这条连接。这里的&lt;strong&gt;使用完毕&lt;/strong&gt;有非常明确的定义：发送缓冲区中不再有未发送的指令，接收缓冲区不再有未接收的数据，下次能读取的数据必须是下一次发送的指令的响应。&lt;/p&gt;
&lt;p&gt;通常情况下的SQL操作如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;rows, err := db.Query(&amp;quot;SELECT a, b FROM some_table&amp;quot;)
if err != nil {
    return err
}
defer rows.Close()

for rows.Next() {
    var a, b string
    if err := rows.Scan(&amp;amp;a, &amp;amp;b); err != nil {
        return err
    }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>